# Importaciones estándar
import math
from math import sqrt
import os
import re

# Importaciones de tkinter
import tkinter as tk
from tkinter import ttk, messagebox, filedialog,Toplevel,simpledialog
from tkinter import Scale, Frame, Entry, Label, NORMAL, DISABLED, END, HORIZONTAL
from tkinter import StringVar, PhotoImage
import time
import requests
import platform
from datetime import datetime
from pytz import timezone
import threading

# Importaciones de bibliotecas de terceros
from PIL import Image, ImageTk,ImageDraw
import numpy as np
import pandas as pd
import matplotlib.pyplot as plt 
import matplotlib.gridspec as gridspec
from matplotlib import font_manager
from matplotlib.backends.backend_pdf import PdfPages
from matplotlib.ticker import MaxNLocator
from matplotlib.backends.backend_tkagg import FigureCanvasTkAgg,NavigationToolbar2Tk
from matplotlib.figure import Figure
import matplotlib.patches as patches
from mpl_toolkits.mplot3d.art3d import Poly3DCollection
from mpl_toolkits.mplot3d import Axes3D
from matplotlib.lines import Line2D
import scipy
from scipy.interpolate import CubicSpline
from matplotlib.backends.backend_agg import FigureCanvasAgg as FigureCanvas


# Importación de la librería de documentos de Word
from docx import Document
from docx.shared import Inches
import subprocess




"*******************************************************************************************************************************"
"Autor: Juan David Garzón Obando.              Programa: Ingeniería civil         Universidad: Universidad Piloto de Colombia"

"Proyecto: Desarrollo de un programa didáctico en Python para el análisis estructural y diseño de vigas de concreto reforzado"

"*****************************************************************************************************************************"
"*************************************ANÁLISIS ESTRUCTURAL Y DISEÑO DE VIGAS *************************************************"
"*****************************************************************************************************************************"
# Función para mostrar el splash screen
def mostrar_splash():
    splash = tk.Toplevel()  
    splash.overrideredirect(True)  
    splash.geometry("800x400")  
    
    
    splash.attributes('-topmost', True)  
    
    # Obtener el tamaño de la pantalla
    screen_width = splash.winfo_screenwidth()  
    screen_height = splash.winfo_screenheight()  
    
    # Calcular las coordenadas para centrar la ventana
    center_x = (screen_width - 800) // 2  
    center_y = (screen_height - 400) // 2  

    # Establecer la posición de la ventana en el centro de la pantalla
    splash.geometry(f"800x400+{center_x}+{center_y}")

    # Cargar y redimensionar la imagen del banner
    banner_image = Image.open("Iconos_proyecto/Banner programa.png")  
    resized_banner_image = banner_image.resize((800, 400))  
    banner_image_tk = ImageTk.PhotoImage(resized_banner_image)  
    
    banner_label = tk.Label(splash, image=banner_image_tk)
    banner_label.image = banner_image_tk  
    banner_label.pack()

    # Crear un canvas para simular la barra de carga (color rojo)
    progress_canvas = tk.Canvas(splash, width=400, height=30, bd=0, highlightthickness=0, bg='white')
    progress_canvas.place(x=70, y=250)
    
    # Crear un rectángulo rojo dentro del canvas
    progress_rect = progress_canvas.create_rectangle(0, 0, 0, 30, fill='red', outline='')

    # Crear un texto para el porcentaje dentro de la barra
    progress_text = progress_canvas.create_text(200, 15, text="0%", font=("Helvetica", 12, "bold"), fill="black")

    # Función para actualizar la barra de progreso, el rectángulo rojo y el texto del porcentaje
    def actualizar_progreso():
        for i in range(101):  # 101 para llegar a 100%
            progress_canvas.coords(progress_rect, 0, 0, i * 4, 30)  
            progress_canvas.itemconfig(progress_text, text=f"{i}%")  
            splash.update_idletasks()  
            time.sleep(0.05)  
        splash.destroy()  
        ventana.deiconify()  
        ventana.state('zoomed')  

    # Iniciar la actualización de la barra de progreso en un hilo para no bloquear la ventana
    threading.Thread(target=actualizar_progreso, daemon=True).start()

    splash.mainloop()

# Variable global para controlar si la subventana ya está abierta
Ventana_Nuevo = None

# Crear la ventana principal
ventana = tk.Tk()

# Maximizar la ventana al iniciar
ventana.state('zoomed')

# Configuración de título
ventana.title("PILOT STRUCTURAL")

# Cargar y redimensionar el ícono usando PIL
ruta_icono = "Iconos_proyecto/Icono_P.png"
imagen = Image.open(ruta_icono)
imagen = imagen.resize((32, 32))  
icono = ImageTk.PhotoImage(imagen)

# Establecer el ícono de la ventana
ventana.iconphoto(True, icono)

# Establecer el tamaño mínimo de la ventana
ventana.minsize(800, 600)


# Crear la barra de menús
menu_bar = tk.Menu(ventana)

# Definir iconos
icono_guardar = None  
icono_abrir_archivo = None  

# Definir funciones de guardar y abrir
def guardar_archivo():
    # Definir el tipo de archivo a guardar 
    archivo = filedialog.asksaveasfilename(defaultextension=".pilot", 
                                            filetypes=[("Archivos de Pilot", "*.pilot"), ("Todos los archivos", "*.*")])
    if archivo:
        try:
            # Guardar el contenido del archivo
            with open(archivo, 'w') as f:
                # Aquí debes guardar el contenido relevante de tu aplicación
                f.write("Contenido de la aplicación...")
            messagebox.showinfo("Guardado", f"Archivo guardado exitosamente: {archivo}")
        except Exception as e:
            messagebox.showerror("Error", f"No se pudo guardar el archivo: {e}")

def abrir_archivo():
    # Definir los tipos de archivo que se pueden abrir (por ejemplo .miapp)
    archivo = filedialog.askopenfilename(filetypes=[("Archivos de Pilot", "*.pilot"), ("Todos los archivos", "*.*")])
    if archivo:
        try:
            # Abrir y leer el contenido del archivo
            with open(archivo, 'r') as f:
                contenido = f.read()
                # Aquí deberías cargar el contenido en tu aplicación
                print(contenido)  # Por ejemplo, mostrar el contenido en la consola
            messagebox.showinfo("Archivo abierto", f"Archivo abierto exitosamente: {archivo}")
        except Exception as e:
            messagebox.showerror("Error", f"No se pudo abrir el archivo: {e}")
            


# Parámetros de la viga empotrada
base_viga = 0.40
altura_viga = 0.40
longitud_viga = 1
base_columna = 0.5
altura_columna = 1
longitud_columna = -0.2
desfase_estribo = 0.05

# Parámetros de la viga apoyada
base_viga_apoyada = 0.40
altura_viga_apoyada = 0.40
longitud_viga_apoyada = 1
base_piramide = -0.2
altura_piramdie = -0.5
longitud_piramide = -0.2
desfase_estribo = 0.05

# Función que se ejecuta al hacer clic en el botón
def on_boton_aplicar_click(label_contenido_1, label_prueba):
    # Obtener el texto actual del label
    tipo_viga = label_prueba.cget("text")
    
    # Comprobamos si el texto de `label_prueba` tiene el valor esperado
    if tipo_viga not in ["Viga apoyada", "Viga empotrada"]:
        print("Texto en label_prueba no válido.")
        return
    
    # Eliminar solo los gráficos (por ejemplo, si hay un Canvas donde se dibujan los gráficos)
    for widget in label_contenido_1.winfo_children():
        if isinstance(widget, tk.Canvas):  # Asegúrate de destruir solo el Canvas
            widget.destroy()

    # Si el label es "Viga apoyada"
    if tipo_viga == "Viga apoyada":
        # Mostrar gráfico de viga apoyada con sus parámetros
            mostrar_grafico_viga_apoyada(
            base_viga_apoyada, 
            altura_viga_apoyada, 
            longitud_viga_apoyada, 
            base_piramide, 
            altura_piramdie, 
            longitud_piramide, 
            desfase_estribo
        )
    
    # Si el label es "Viga empotrada"
    elif tipo_viga == "Viga empotrada":
        # Mostrar gráfico de viga empotrada con sus parámetros
        mostrar_grafico_viga_empotrada(
            base_viga, 
            altura_viga, 
            longitud_viga, 
            base_columna, 
            altura_columna, 
            longitud_columna, 
            desfase_estribo
        )

# Grafico 3D viga empotrada
def dibujar_viga_empotrada(base, altura, longitud, posicion_x, posicion_y, color, ax):
    """
    Dibuja un cuboide con las dimensiones especificadas y posición inicial.
    """
    # Definir las caras del cuboide
    vertices = {
        'cara_inferior': [
            [posicion_x - base/2, posicion_x + base/2, posicion_x + base/2, posicion_x - base/2],
            [posicion_y, posicion_y, posicion_y + longitud, posicion_y + longitud],
            [0, 0, 0, 0]
        ],
        'cara_superior': [
            [posicion_x - base/2, posicion_x + base/2, posicion_x + base/2, posicion_x - base/2],
            [posicion_y, posicion_y, posicion_y + longitud, posicion_y + longitud],
            [altura, altura, altura, altura]
        ],
        'cara_frontal': [
            [posicion_x - base/2, posicion_x + base/2, posicion_x + base/2, posicion_x - base/2],
            [posicion_y, posicion_y, posicion_y, posicion_y],
            [0, 0, altura, altura]
        ],
        'cara_trasera': [
            [posicion_x - base/2, posicion_x + base/2, posicion_x + base/2, posicion_x - base/2],
            [posicion_y + longitud, posicion_y + longitud, posicion_y + longitud, posicion_y + longitud],
            [0, 0, altura, altura]
        ],
        'cara_izquierda': [
            [posicion_x - base/2, posicion_x - base/2, posicion_x - base/2, posicion_x - base/2],
            [posicion_y, posicion_y + longitud, posicion_y + longitud, posicion_y],
            [0, 0, altura, altura]
        ],
        'cara_derecha': [
            [posicion_x + base/2, posicion_x + base/2, posicion_x + base/2, posicion_x + base/2],
            [posicion_y, posicion_y + longitud, posicion_y + longitud, posicion_y],
            [0, 0, altura, altura]
        ]
    }
    
    # Dibujar cada cara del cuboide
    for cara, coordenadas in vertices.items():
        puntos = np.array(coordenadas).T  # Transponer para formato adecuado
        poligono = Poly3DCollection([puntos], color=color, edgecolor='black', alpha=0.3)
        ax.add_collection3d(poligono)

def dibujar_viga_y_columnas(base_viga, altura_viga, longitud_viga, base_columna, altura_columna, longitud_columna, desfase_estribo):
    """
    Dibuja una viga con columnas en sus extremos.
    """
    fig = plt.figure(facecolor="white",dpi=100)
    ax = fig.add_subplot(111, projection='3d')

    # Dibuja la viga
    dibujar_viga_empotrada(base_viga, altura_viga, longitud_viga, 0.5, 0, 'grey', ax)
    
    # Dibuja las columnas en los extremos de la viga
    posicion_extremo_inicial = -longitud_columna  # Columna en el extremo inicial de la viga
    posicion_extremo_final = longitud_viga        # Columna en el extremo final de la viga
    
    dibujar_viga_empotrada(base_columna, altura_columna, longitud_columna, 0.5, posicion_extremo_inicial, 'blue', ax)  # Columna inicial
    dibujar_viga_empotrada(base_columna, altura_columna, longitud_columna, 0.5, posicion_extremo_final, 'blue', ax)    # Columna final

    # Ocultar etiquetas y ticks de los ejes sin afectar el dibujo 3D
    ax.set_xticklabels([])
    ax.set_yticklabels([])
    ax.set_zticklabels([])
    ax.set_xticks([])
    ax.set_yticks([])
    ax.set_zticks([])
    ax.set_box_aspect([1, 3, -1])
    ax.set_facecolor('white')
    ax.xaxis.pane.fill = False
    ax.yaxis.pane.fill = False
    ax.zaxis.pane.fill = False
    # Cambiar el color de las líneas del gráfico
    ax.xaxis.pane.set_edgecolor('white')
    ax.yaxis.pane.set_edgecolor('white')
    ax.zaxis.pane.set_edgecolor('white')

    return fig, ax

def mostrar_grafico_viga_empotrada(base_viga, altura_viga, longitud_viga, base_columna, altura_columna, longitud_columna, desfase_estribo):
    
    # Convertir la figura de matplotlib a un canvas de Tkinter
    frame = tk.Frame(ventana,bd=10,relief="ridge")
    frame.place(x=36,y=35,width=400,height=370)
    
    # Crear la figura y el gráfico
    fig, ax = dibujar_viga_y_columnas(base_viga, altura_viga, longitud_viga, base_columna, altura_columna, longitud_columna, desfase_estribo)

    # Integrar con Tkinter
    canvas = FigureCanvasTkAgg(fig, master=frame)
    canvas_widget = canvas.get_tk_widget()
    canvas_widget.config(bg='white')  # Fondo negro para el widget Canvas
    canvas_widget.pack(fill=tk.BOTH, expand=True)
    
    # Crear un frame para el gráfico y la barra de herramientas
    frame_1 = tk.Frame(canvas_widget ,bd=2, relief="raise")
    frame_1.place(x=0, y=315, width=380 ,height=35)
    
    label_titulo = tk.Label(canvas_widget ,text="Modelo 3D - Viga empotrada",bd=2,relief="raise")
    label_titulo.place(x=1,y=1,width=380,height=35)
    
    
    # Añadir la barra de herramientas de navegación
    toolbar_opciones = NavigationToolbar2Tk(canvas, frame_1)
    toolbar_opciones.update()
    toolbar_opciones.pack(side=tk.BOTTOM, fill=tk.X)


# Función para dibujar la viga apoyada
def dibujar_viga_apoyada(base, altura, longitud, posicion_x, posicion_y, color, ax):
    """
    Dibuja un cuboide con las dimensiones especificadas y posición inicial.
    """
    vertices = {
        'cara_inferior': [
            [posicion_x - base/2, posicion_x + base/2, posicion_x + base/2, posicion_x - base/2],
            [posicion_y, posicion_y, posicion_y + longitud, posicion_y + longitud],
            [0, 0, 0, 0]
        ],
        'cara_superior': [
            [posicion_x - base/2, posicion_x + base/2, posicion_x + base/2, posicion_x - base/2],
            [posicion_y, posicion_y, posicion_y + longitud, posicion_y + longitud],
            [altura, altura, altura, altura]
        ],
        'cara_frontal': [
            [posicion_x - base/2, posicion_x + base/2, posicion_x + base/2, posicion_x - base/2],
            [posicion_y, posicion_y, posicion_y, posicion_y],
            [0, 0, altura, altura]
        ],
        'cara_trasera': [
            [posicion_x - base/2, posicion_x + base/2, posicion_x + base/2, posicion_x - base/2],
            [posicion_y + longitud, posicion_y + longitud, posicion_y + longitud, posicion_y + longitud],
            [0, 0, altura, altura]
        ],
        'cara_izquierda': [
            [posicion_x - base/2, posicion_x - base/2, posicion_x - base/2, posicion_x - base/2],
            [posicion_y, posicion_y + longitud, posicion_y + longitud, posicion_y],
            [0, 0, altura, altura]
        ],
        'cara_derecha': [
            [posicion_x + base/2, posicion_x + base/2, posicion_x + base/2, posicion_x + base/2],
            [posicion_y, posicion_y + longitud, posicion_y + longitud, posicion_y],
            [0, 0, altura, altura]
        ]
    }
    
    for cara, coordenadas in vertices.items():
        puntos = np.array(coordenadas).T
        poligono = Poly3DCollection([puntos], color=color, edgecolor='black', alpha=0.3)
        ax.add_collection3d(poligono)

# Función para dibujar las piramides 
def dibujar_piramide(base, altura, posicion_x, posicion_y, color, ax):
    """
    Dibuja una pirámide invertida con base cuadrada.
    """
    # Definir los vértices de la pirámide invertida
    vertices = [
        [posicion_x - base / 2, posicion_y, altura],  # Esquina inferior izquierda de la base
        [posicion_x + base / 2, posicion_y, altura],  # Esquina inferior derecha de la base
        [posicion_x + base / 2, posicion_y + base, altura],  # Esquina superior derecha de la base
        [posicion_x - base / 2, posicion_y + base, altura],  # Esquina superior izquierda de la base
        [posicion_x, posicion_y + base / 2, 0]  # Vértice superior (punta de la pirámide)
    ]
    
    # Definir las caras de la pirámide
    caras = [
        [vertices[0], vertices[1], vertices[4]],  # Cara frontal
        [vertices[1], vertices[2], vertices[4]],  # Cara derecha
        [vertices[2], vertices[3], vertices[4]],  # Cara trasera
        [vertices[3], vertices[0], vertices[4]],  # Cara izquierda
        [vertices[0], vertices[1], vertices[2], vertices[3]]  # Base
    ]
    
    # Dibujar cada cara de la pirámide
    for cara in caras:
        poligono = Poly3DCollection([cara], color=color, edgecolor='black', alpha=0.3)
        ax.add_collection3d(poligono)


# Función principal para dibujar la viga y las pirámides
def dibujar_viga_y_piramides(base_viga_apoyada, altura_viga_apoyada, longitud_viga_apoyada, base_piramide, altura_piramdie, longitud_piramide, desfase_estribo):
    fig = plt.figure(facecolor="white", dpi=100)
    ax = fig.add_subplot(111, projection='3d')

    # Dibujar la viga
    dibujar_viga_apoyada(base_viga_apoyada, altura_viga_apoyada, longitud_viga_apoyada, 0.5, 0, 'grey', ax)
    
    # Dibujar pirámides en los extremos de la viga
    posicion_extremo_inicial = -longitud_piramide
    posicion_extremo_final = longitud_viga_apoyada
    
    dibujar_piramide(base_piramide, altura_piramdie, 0.5, posicion_extremo_inicial, 'blue', ax)  # Pirámide inicial
    dibujar_piramide(base_piramide, altura_piramdie, 0.5, posicion_extremo_final, 'blue', ax)    # Pirámide final

    ax.set_xticklabels([])
    ax.set_yticklabels([])
    ax.set_zticklabels([])
    ax.set_xticks([])
    ax.set_yticks([])
    ax.set_zticks([])
    ax.set_box_aspect([1, 3, 1])
    ax.set_facecolor('white')
    ax.xaxis.pane.fill = False
    ax.yaxis.pane.fill = False
    ax.zaxis.pane.fill = False
    ax.xaxis.pane.set_edgecolor('white')
    ax.yaxis.pane.set_edgecolor('white')
    ax.zaxis.pane.set_edgecolor('white')

    return fig, ax

# Función para mostrar el gráfico en una ventana Tkinter
def mostrar_grafico_viga_apoyada(base_viga_apoyada, altura_viga_apoyada, longitud_viga_apoyada, base_piramide, altura_piramdie, longitud_piramide, desfase_estribo):
    frame = tk.Frame(ventana, bd=10, relief="ridge")
    frame.place(x=36, y=35, width=400, height=370)
    
    fig, ax = dibujar_viga_y_piramides(base_viga_apoyada, altura_viga_apoyada, longitud_viga_apoyada, base_piramide, altura_piramdie, longitud_piramide, desfase_estribo)

    canvas = FigureCanvasTkAgg(fig, master=frame)
    canvas_widget = canvas.get_tk_widget()
    canvas_widget.config(bg='white')
    canvas_widget.pack(fill=tk.BOTH, expand=True)
    
    frame_1 = tk.Frame(canvas_widget, bd=2, relief="raise")
    frame_1.place(x=0, y=315, width=380, height=35)
    
    label_titulo = tk.Label(canvas_widget ,text="Modelo 3D - Viga apoyada",bd=2,relief="raise")
    label_titulo.place(x=1,y=1,width=380,height=35)
    
    toolbar_opciones = NavigationToolbar2Tk(canvas, frame_1)
    toolbar_opciones.update()
    toolbar_opciones.pack(side=tk.BOTTOM, fill=tk.X)


frame_ventana = tk.Frame(ventana, bd=10, relief="ridge",bg="white")
frame_ventana.place(x=36, y=35, width=400, height=370)


frame_1 = tk.Frame(frame_ventana, bd=2, relief="raise")
frame_1.place(x=0, y=315, width=380, height=35)

label_titulo = tk.Label(frame_ventana ,text="Modelo Viga 3D",bd=2,relief="raise")
label_titulo.place(x=1,y=1,width=380,height=35)



# Cargar las imágenes para los menús
imagen_original0 = Image.open("Iconos_proyecto/Nuevo_Modelo.png")
imagen_original_abrir=Image.open("Iconos_proyecto/Abrir_archivo.png")
imagen_original_guardar=Image.open("Iconos_proyecto/Disco_guardar.png")
imagen_original_salir= Image.open("Iconos_proyecto/Cerrar_sesion.png")
imagen_original = Image.open("Iconos_proyecto/Materiales.png")
imagen_original1 = Image.open("Iconos_proyecto/Seccion_transversal.png")
imagen_original2 = Image.open("Iconos_proyecto/Seccion_Viga.png")
imagen_original3= Image.open("Iconos_proyecto/apoyo_simple.png")
imagen_original4= Image.open("Iconos_proyecto/Cargas.png")
imagen_original5= Image.open("Iconos_proyecto/Grafico_V_M.png")
imagen_original6= Image.open("Iconos_proyecto/Flexion_VG.png")
imagen_original7= Image.open("Iconos_proyecto/Calculos_previos.png")
imagen_original8= Image.open("Iconos_proyecto/barra_de_acero.png")
imagen_original9= Image.open("Iconos_proyecto/viga_acero.png")
imagen_original10= Image.open("Iconos_proyecto/longitd_desarrollo.png")
imagen_original11= Image.open("Iconos_proyecto/Cortante.png")
imagen_original12 = Image.open("Iconos_proyecto/logo_programa.png")
imagen_original13 = Image.open("Iconos_proyecto/Doc_word.png")
imagen_original14 = Image.open("Iconos_proyecto/Doc_word_cortante.png")
imagen_original15 = Image.open("Iconos_proyecto/Model_3D.png")

# Redimensionar las imágenes (ajustar el tamaño según sea necesario)
imagen_redimensionada0 = imagen_original0.resize((20, 20))
imagen_redimensionada_abrir = imagen_original_abrir.resize((20, 20))
imagen_redimensionada_guardar= imagen_original_guardar.resize((20,20))
imagen_redimensionada_salir= imagen_original_salir.resize((20,20))
imagen_redimensionada = imagen_original.resize((20, 20))
imagen_redimensionada1 = imagen_original1.resize((20, 20))
imagen_redimensionada2 = imagen_original2.resize((20, 20))
imagen_redimensionada3 = imagen_original3.resize((20,20))
imagen_redimensionada4 = imagen_original4.resize((20,20))
imagen_redimensionada5 = imagen_original5.resize((20,20))
imagen_redimensionada6 = imagen_original6.resize((20,20))
imagen_redimensionada7 = imagen_original7.resize((20,20))
imagen_redimensionada8 = imagen_original8.resize((20,20))
imagen_redimensionada9 = imagen_original9.resize((20,20))
imagen_redimensionada10 = imagen_original10.resize((20,20))
imagen_redimensionada11 = imagen_original11.resize((20,20))
imagen_redimensionada12 = imagen_original12.resize((20,20))
imagen_redimensionada13 = imagen_original13.resize((20,20))
imagen_redimensionada14 = imagen_original14.resize((20,20))
imagen_redimensionada15 = imagen_original15.resize((20,20))


# Convertir las imágenes redimensionadas a un formato compatible con Tkinter
icono_modelo_nuevo = ImageTk.PhotoImage(imagen_redimensionada0)
icono_abrir_archivo = ImageTk.PhotoImage(imagen_redimensionada_abrir)
icono_guardar      =  ImageTk.PhotoImage(imagen_redimensionada_guardar)
icono_salir        =  ImageTk.PhotoImage(imagen_redimensionada_salir)
icono_materiales = ImageTk.PhotoImage(imagen_redimensionada)
icono_seccion_transversal = ImageTk.PhotoImage(imagen_redimensionada1)
icono_seccion_viga = ImageTk.PhotoImage(imagen_redimensionada2)
icono_asignar_apoyos = ImageTk.PhotoImage(imagen_redimensionada3)
icono_asignar_cargas = ImageTk.PhotoImage(imagen_redimensionada4)
icono_graficos = ImageTk.PhotoImage(imagen_redimensionada5)
icono_flexion =  ImageTk.PhotoImage(imagen_redimensionada6)
icono_calculos = ImageTk.PhotoImage(imagen_redimensionada7)
icono_barras = ImageTk.PhotoImage(imagen_redimensionada8)
icono_VG_AS = ImageTk.PhotoImage(imagen_redimensionada9)
icono_longitud_desarrollo = ImageTk.PhotoImage(imagen_redimensionada10)
icono_cortante = ImageTk.PhotoImage(imagen_redimensionada11)
icono_pilot_structural = ImageTk.PhotoImage(imagen_redimensionada12)
icono_Doc_word = ImageTk.PhotoImage(imagen_redimensionada13)
icono_Doc_word_cortante = ImageTk.PhotoImage(imagen_redimensionada14)
icono_model_3D = ImageTk.PhotoImage(imagen_redimensionada15)


# Menú "Definir"
menu_definir = tk.Menu(menu_bar, tearoff=0)

# Menú "Archivo"
menu_archivo = tk.Menu(menu_bar, tearoff=0)
menu_archivo.add_command(label="Nuevo", image=icono_modelo_nuevo, compound="left",command=lambda: abrir_ventana_nueva())
menu_archivo.add_command(label="Abrir",image=icono_abrir_archivo,compound="left", command=abrir_archivo)
menu_archivo.add_command(label="Guardar",image=icono_guardar,compound="left",command=guardar_archivo)
menu_archivo.add_separator()
menu_archivo.add_command(label="Salir", command=ventana.quit,image=icono_salir,compound="left")
menu_bar.add_cascade(label="Archivo", menu=menu_archivo)

# Declarar checkbutton_1 como una variable global
checkbutton_1 = None
checkbutton_2 = None
checkbutton_3 = None
checkbutton_4 = None

# Clase para manejar la reproducción del GIF
class GIFPlayer:
    def __init__(self, master, gif_path, canvas, width, height):
        self.master = master
        self.canvas = canvas
        self.gif_path = gif_path
        self.width = width
        self.height = height
        
        # Verificar si el archivo existe antes de intentar cargarlo
        if not os.path.exists(gif_path):
            print(f"El archivo {gif_path} no existe.")
            return

        try:
            self.image = Image.open(gif_path)
        except Exception as e:
            print(f"Error al abrir el archivo GIF: {e}")
            return
        
        self.frames = self.load_frames()
        if not self.frames:
            print("No se pudieron cargar los fotogramas del GIF.")
            return
        
        self.current_frame = 0
        self.canvas_id = self.canvas.create_image(0, 0, anchor="nw", image=self.frames[self.current_frame])
        self.update_frame()

    def load_frames(self):
        """Carga los fotogramas del GIF"""
        frames = []
        try:
            while True:
                # Escalar cada fotograma del GIF al tamaño del Canvas
                frame = self.image.copy()
                frame = frame.resize((self.width, self.height), Image.Resampling.LANCZOS)
                frame = ImageTk.PhotoImage(frame)
                frames.append(frame)
                self.image.seek(self.image.tell() + 1)
        except EOFError:
            pass
        except Exception as e:
            print(f"Error al cargar los fotogramas del GIF: {e}")
        return frames

    def update_frame(self):
        """Actualizar el fotograma a mostrar"""
        self.current_frame = (self.current_frame + 1) % len(self.frames)
        self.canvas.itemconfig(self.canvas_id, image=self.frames[self.current_frame])
        # Llamar a update_frame nuevamente para crear la animación continua
        self.master.after(100, self.update_frame)

# Función para manejar el evento de selección en el Combobox
def on_combobox_select(event, canvas_viga, label_mensaje_ayuda,label_prueba):
    selected_option = combobox.get().strip()  # Eliminar cualquier espacio extra

    # Lógica para actualizar el mensaje según la opción seleccionada
    if selected_option == "Viga empotrada":
        gif_path = os.path.join("Iconos_proyecto", "animacion.gif")
        mensaje = "Has seleccionado la viga empotrada.\nPara el modelo sigue aplicando las otras configuraciones.\nPara completar el modelo."
    elif selected_option == "Viga apoyada":
        gif_path = os.path.join("Iconos_proyecto", "viga_apoyada.gif")
        mensaje = "Has seleccionado la viga apoyada.\nPara el modelo sigue aplicando las otras configuraciones.\nPara completar el modelo."
    else:
        print("Opción no válida")
        return

    # Actualiza el texto del label de mensaje de ayuda
    label_mensaje_ayuda.config(text=mensaje)
    
    # Actualiza el texto en label_prueba con la opción seleccionada
    label_prueba.config(text=f"{selected_option}")

    # Verificar si el archivo GIF existe y mostrarlo en el canvas
    if os.path.exists(gif_path):
        if canvas_viga is not None:
            gif_player = GIFPlayer(master=Ventana_Nuevo, gif_path=gif_path, canvas=canvas_viga, width=190, height=170)
        else:
            print("Error: canvas_viga es None.")
    else:
        print(f"El archivo {gif_path} no existe.")

# Declarar label_prueba como variable global
label_prueba = None
subventana_abierta= None


# Ruta de la carpeta base_datos
carpeta_base_datos = "base_datos"
archivo_datos = os.path.join(carpeta_base_datos, "datos_modelo.txt")

# Crear la carpeta base_datos si no existe
if not os.path.exists(carpeta_base_datos):
    os.makedirs(carpeta_base_datos)

def guardar_datos():
    """Guarda los datos de los widgets en un archivo de texto."""
    nombre_modelo = entry_nombre_modelo.get().strip()
    nombre_usuario = entry_nombre_usuario.get().strip()  # Obtenemos el nombre del usuario
    
    datos = {
        "nombre_usuario": nombre_usuario,
        "nombre_modelo": nombre_modelo,
        "detalles_modelo": text_detalles_modelo.get("1.0", tk.END).strip(),
        "combo_concreto": combo_concreto.get(),
        "combo_acero": combo_acero.get()
    }
    
    # Guardar los datos en el archivo
    with open(archivo_datos, "w") as archivo:
        for clave, valor in datos.items():
            archivo.write(f"{clave}:{valor}\n")
    
    # Actualizar los Labels con el nombre del usuario y el nombre del modelo
    label_estudiante.config(text=nombre_usuario)  # Actualiza el texto del label con el nombre del usuario
    label_modelo.config(text=nombre_modelo)  # Actualiza el texto del label con el nombre del modelo
    
    # Actualizar el título de la subventana
    if nombre_modelo:
        Ventana_Nuevo.title(f"Nuevo Modelo - {nombre_modelo}")
    
    # Cerrar la ventana
    Ventana_Nuevo.destroy()


def cargar_datos():
    """Carga los datos desde un archivo de texto si existe."""
    datos = {}
    try:
        with open(archivo_datos, "r") as archivo:
            for linea in archivo:
                clave, valor = linea.strip().split(":", 1)
                datos[clave] = valor
    except FileNotFoundError:
        pass
    return datos


# Función que se ejecuta cuando se selecciona "Nuevo" o se hace clic en el botón
def abrir_ventana_nueva():
    global Ventana_Nuevo,checkbutton_1,checkbutton_2,checkbutton_3,checkbutton_4 , gif_player, combobox, label_prueba,spinbox,checkbutton_5,combo
    global subventana_abierta
    global entry_nombre_usuario, entry_ruta_archivo, entry_nombre_modelo, text_detalles_modelo
    global combo_concreto, entry_descripcion_concreto, combo_acero, entry_descripcion_acero

    # Verificar si la subventana ya está abierta
    if Ventana_Nuevo is None or not Ventana_Nuevo.winfo_exists():
        # Crear una nueva subventana (Toplevel)
        Ventana_Nuevo = Toplevel(ventana)
        Ventana_Nuevo.title("Nuevo Modelo")
        Ventana_Nuevo.geometry("800x470")  # Tamaño de la subventana
        
        # Cargar datos para establecer el título
        datos_cargados = cargar_datos()
        nombre_modelo = datos_cargados.get("nombre_modelo", "")
        Ventana_Nuevo.title(f"Nuevo Modelo - {nombre_modelo}" if nombre_modelo else "Nuevo Modelo")

        
        # Establecer un tamaño fijo y prevenir redimensionar
        Ventana_Nuevo.resizable(False, False)
        
        # Asegurarse de que la subventana esté siempre por encima de la ventana principal
        Ventana_Nuevo.attributes('-topmost', True)
        
        
        # Crear LabelFrame en la nueva ventana
        label_Nuevo = tk.LabelFrame(Ventana_Nuevo, text="Configuraciones previas")
        label_Nuevo.place(x=10,y=10,width=200,height=400)
        
        # Crear el Treeview dentro del LabelFrame
        treeview = ttk.Treeview(label_Nuevo)
        treeview.place(x=10,y=10,width=170,height=300)
        
        # Función para redimensionar imágenes
        def cargar_icono(ruta, tamaño):
            imagen = Image.open(ruta)  # Abrir la imagen
            imagen = imagen.resize(tamaño, Image.ANTIALIAS)  # Redimensionar
            return ImageTk.PhotoImage(imagen)
        
        # Cargar las imágenes para los íconos
        icon_general = tk.PhotoImage(file="Iconos_proyecto/boton_circular.png")  
        icon_unidades = tk.PhotoImage(file="Iconos_proyecto/boton_circular.png")  
        icon_materiales = tk.PhotoImage(file="Iconos_proyecto/boton_circular.png")
        icon_modelo = tk.PhotoImage(file="Iconos_proyecto/boton_triangulo.png")
        icono_concreto_acero = tk.PhotoImage(file="Iconos_proyecto/Concreto_Acero.png")
        
        # Mantener las imágenes en una variable para evitar que se eliminen por el recolector de basura
        treeview.icons = {
        'general': icon_general,
        'unidades': icon_unidades,
        'materiales': icon_materiales,
        'nuevo modelo':icon_modelo
        }
        
        # Agregar elementos al Treeview con jerarquía
        # Opción principal
        opcion1 = treeview.insert('', 'end', 'opcion1', text='General',image=icon_general)
        opcion2 = treeview.insert('', 'end', 'opcion2', text='Unidades / Esfuerzos',image=icon_unidades)
        opcion3 = treeview.insert('', 'end', 'opcion3', text='Materiales',image=icon_materiales)

        # Sub-elementos dentro de la Opción 1
        treeview.insert(opcion1, 'end', 'subopcion1_1', text='Nuevo Modelo',image=icon_modelo)
        treeview.insert(opcion1, 'end', 'subopcion1_2', text='Estilo de Modelo',image=icon_modelo)

        # Sub-elementos dentro de la Opción 2
        treeview.insert(opcion2, 'end', 'subopcion2_1', text='Esfuerzos',image=icon_modelo)
        # Sub-elementos dentro de la Opción 3
        subopcion3_1 = treeview.insert(opcion3, 'end', 'subopcion3_1', text="Concreto / Acero", image=icon_modelo)
        
        # Seleccionar la opción "General" (sin expandir)
        treeview.selection_set(opcion1)
        
        
        # Función para bloquear la interacción con "opcion3" pero dejar ver el subnodo
        def bloquear_opcion3(event):
            seleccion = treeview.identify_row(event.y)  # Identificar qué fila se clicó
        
            if seleccion == "opcion3":  # Si el clic es sobre "Materiales"
                treeview.item(opcion3, open=True)  # Expande el nodo de "Materiales"
                treeview.selection_set(subopcion3_1)  # Forza la selección del subelemento
                treeview.focus(subopcion3_1)  # Mueve el foco al subelemento
                return "break"  # Detiene la acción predeterminada de Treeview (evita que se seleccione "Opción 3")
        
        # Vincular un evento de clic para bloquear el acceso a "opcion3"
        treeview.bind("<Button-1>", bloquear_opcion3)
        
        # Inicializar la variable que indica si la subventana está abierta
        subventana_abierta = False
        
        
        # Función que abre la subventana si no está abierta
        def abrir_subventana():
            global subventana_abierta,boton_agregar
            if not subventana_abierta:  # Solo abre la subventana si no está abierta
                subventana_abierta = True  # Marcar como abierta
                subventana = Toplevel()  # Crear la subventana
                subventana.title("Configuración del material")  # Título de la subventana
                subventana.geometry("394x280")  # Tamaño de la subventana
        
        # Hacer que la subventana esté siempre en el primer plano
                subventana.attributes('-topmost', True)
        
        # Evitar que la subventana sea redimensionable
                subventana.resizable(False, False)
                
        # Crear contenido dentro de la subventana
                label_frame_concreto = tk.LabelFrame(subventana, text="Concreto [f'c]")
                label_frame_concreto.place(x=10,y=10,width=375,height=100)
                label_materiales_concreto = tk.Label(label_frame_concreto,text="Materiales:")
                label_materiales_concreto.place(x=40,y=15)
                label_materiales_descripcion_C = tk.Label(label_frame_concreto,text="Descripción:")
                label_materiales_descripcion_C.place(x=40,y=45)
                entry_materiales_C= tk.Entry(label_frame_concreto)
                entry_materiales_C.place(x=140,y=45,width=143)
                label_frame_acero = tk.LabelFrame(subventana,text="Acero [fy]")
                label_frame_acero.place(x=10,y=120,width=375,height=100)
                label_materiales_acero = tk.Label(label_frame_acero,text="Materiales:")
                label_materiales_acero.place(x=40,y=15)
                label_materiales_descripcion_A = tk.Label(label_frame_acero,text="Descripción:")
                label_materiales_descripcion_A.place(x=40,y=45)
                entry_materiales_A= tk.Entry(label_frame_acero)
                entry_materiales_A.place(x=140,y=45,width=143)
                boton_agregar = ttk.Button(subventana,text="Agregar", command=lambda: agregar_datos(entry_materiales_C, entry_materiales_A, combo_materiales_fc, combo_materiales_fy))
                boton_agregar.place(x=140,y=235,width=100)
                
                # Guardamos la referencia de la subventana
                abrir_subventana.subventana = subventana
                
        # Crear un Combobox para f'c
                combo_materiales_fc = ttk.Combobox(label_frame_concreto, values=[
                "f'c = 17.5 MPa", 
                "f'c = 21 MPa", 
                "f'c = 24.5 MPa", 
                "f'c = 28 MPa", 
                "f'c = 35 MPa", 
                "f'c = 42 MPa"
                ], state="readonly")  # `readonly` para evitar edición manual
                combo_materiales_fc.set("Concreto")  # Valor por defecto
                combo_materiales_fc.place(x=140,y=15)
                
        # Función que actualiza el Entry de descripción de concreto según la selección en el ComboBox
                def actualizar_descripcion_concreto():
                    seleccion_fc = combo_materiales_fc.get()
                    if seleccion_fc == "f'c = 17.5 MPa":
                        entry_materiales_C.delete(0, tk.END)  # Eliminar texto actual
                        entry_materiales_C.insert(0, "Concreto 2500 Psi")
                    elif seleccion_fc == "f'c = 21 MPa":
                        entry_materiales_C.delete(0, tk.END)
                        entry_materiales_C.insert(0, "Concreto 3000 Psi")
                    elif seleccion_fc == "f'c = 24.5 MPa":
                        entry_materiales_C.delete(0, tk.END)
                        entry_materiales_C.insert(0, "Concreto 3500 Psi")
                    elif seleccion_fc == "f'c = 28 MPa":
                        entry_materiales_C.delete(0, tk.END)
                        entry_materiales_C.insert(0, "Concreto 4000 Psi")
                    elif seleccion_fc == "f'c = 35 MPa":
                        entry_materiales_C.delete(0, tk.END)
                        entry_materiales_C.insert(0, "Concreto 5000 Psi")
                    elif seleccion_fc == "f'c = 42 MPa":
                        entry_materiales_C.delete(0, tk.END)
                        entry_materiales_C.insert(0, "Concreto 6000 Psi")
                
                # Vincular el evento de cambio en el Combobox de f'c
                combo_materiales_fc.bind("<<ComboboxSelected>>", lambda event: actualizar_descripcion_concreto())
                
        # Crear un Combobox para fy
                combo_materiales_fy = ttk.Combobox(label_frame_acero, values=[
                "fy = 240 MPa", 
                "fy = 420 MPa"
                ], state="readonly")  # `readonly` para evitar edición manual
                combo_materiales_fy.set("Acero")  # Valor por defecto
                combo_materiales_fy.place(x=140,y=15)
        
        # Función que actualiza el Entry de descripción de acero según la selección en el ComboBox
                def actualizar_descripcion_acero():
                    seleccion_fy = combo_materiales_fy.get()
                    if seleccion_fy == "fy = 240 MPa":
                        entry_materiales_A.delete(0, tk.END)  # Eliminar texto actual
                        entry_materiales_A.insert(0, "Resistencia media")
                    elif seleccion_fy == "fy = 420 MPa":
                        entry_materiales_A.delete(0, tk.END)
                        entry_materiales_A.insert(0, "Resistencia alta")
                        
                # Vincular el evento de cambio en el Combobox de fy
                combo_materiales_fy.bind("<<ComboboxSelected>>", lambda event: actualizar_descripcion_acero())
                
        # Función que se llama al hacer clic en el botón "Agregar"
                def agregar_datos(entry_materiales_C, entry_materiales_A, combo_materiales_fc, combo_materiales_fy):
        # Copiar todos los valores de los ComboBox en los respectivos ComboBox de la ventana principal
                    valores_fc = combo_materiales_fc['values']  
                    valores_fy = combo_materiales_fy['values']  

        # Actualizar el ComboBox de la ventana principal con los valores
                    combo_concreto['values'] = valores_fc
                    combo_acero['values'] = valores_fy

        # Si es necesario, se puede seleccionar el primer valor por defecto
                    combo_concreto.set(valores_fc[0])
                    combo_acero.set(valores_fy[0])
                
                # Cerrar la subventana después de agregar los datos
                    subventana.destroy()
                
        # Vincular el evento de cierre de la subventana
                subventana.protocol("WM_DELETE_WINDOW", lambda: cerrar_subventana(subventana))
                
                def actualizar_descripcion_principal():
                    descripcion_concreto = {
                    "f'c = 17.5 MPa": "Concreto 2500 Psi",
                    "f'c = 21 MPa": "Concreto 3000 Psi",
                    "f'c = 24.5 MPa": "Concreto 3500 Psi",
                    "f'c = 28 MPa": "Concreto 4000 Psi",
                    "f'c = 35 MPa": "Concreto 5000 Psi",
                    "f'c = 42 MPa": "Concreto 6000 Psi"
                }
                    entry_descripcion_concreto.delete(0, tk.END)
                    entry_descripcion_concreto.insert(0, descripcion_concreto.get(combo_concreto.get(), ""))
            
                combo_concreto.bind("<<ComboboxSelected>>", lambda event: actualizar_descripcion_principal())
            
                def actualizar_descripcion_acero_principal():
                    descripcion_acero = {
                    "fy = 240 MPa": "Resistencia media",
                    "fy = 420 MPa": "Resistencia alta"
                    }
                    entry_descripcion_acero.delete(0, tk.END)
                    entry_descripcion_acero.insert(0, descripcion_acero.get(combo_acero.get(), ""))
                
                # Vincular evento de cambio en combo_acero
                combo_acero.bind("<<ComboboxSelected>>", lambda event: actualizar_descripcion_acero_principal())
                
        
        # Función para cerrar la subventana y restablecer la variable global
        def cerrar_subventana(subventana):
            global subventana_abierta
            subventana.destroy()  # Cierra la subventana
            subventana_abierta = False  # Restablece el estado para permitir abrirla nuevamente
        
        
        # Función que actualizará la información en el lado derecho
        def mostrar_informacion(event):
            global combos,subventana_abierta
            # Obtener el ítem seleccionado
            item = treeview.selection()
            if item:
                # Aquí puedes ajustar la información según la selección
                info = f"{treeview.item(item)['text']}"
                label_info.config(text=info)
                
                
                
                
                # Mostrar el campo "Nombre de Usuario" si la opción seleccionada es 'General'
                if treeview.item(item)['text'] == 'General':
                    label_nombre_usuario.place(x=40, y=50)
                    entry_nombre_usuario.place(x=170, y=50, width=168)
                    label_fecha_entrada.place(x=350,y=50)
                    entry_fecha_entrada.place(x=400,y=50,width=70)
                    labelFrame_archivo_abrir.place(x=40,y=100,width=480,height=80)
                    label_ruta_archivo.place(x=10,y=10)
                    entry_ruta_archivo.place(x=110,y=10,width=300)
                    labelFrame_archivo_información.place(x=40,y=190, width=480, height=80)
                    label_ruta_usuario.place(x=10,y=10)
                    entry_ruta_usuario.place(x=110,y=10,width=300)
                    labelFrame_opciones.place(x=40,y=280, width=480, height=80)
                    checkbutton_1.place(x=10,y=10)
                    

                    # Ocultar otros widgets si no es la opción correcta
                    label_nombre_modelo.place_forget()
                    label_descripcion_modelo.place_forget()
                    entry_nombre_modelo.place_forget()
                    text_detalles_modelo.place_forget()
                    labelFrame_complementos.place_forget()
                    checkbutton_2.place_forget()
                    checkbutton_3.place_forget()
                    checkbutton_4.place_forget()
                    labelFrame_estilo.place_forget()
                    canvas_viga.place_forget()
                    labelFrame_contenido.place_forget()
                    combobox.place_forget()
                    label_tipo_viga.place_forget()
                    label_mensaje_ayuda.place_forget()
                    label_contenido_1.place_forget()
                    label_mensaje_ayuda_1.place_forget()
                    boton_aplicar.place_forget()
                    label_prueba.place_forget()
                    label_formato.place_forget()
                    formato_decimal.place_forget()
                    slider_1.place_forget()
                    label_mensaje_formato.place_forget()
                    label_formato_unidades.place_forget()
                    label_unidades_1.place_forget()
                    label_unidades_2.place_forget()
                    label_unidades_3.place_forget()
                    label_unidades_4.place_forget()
                    combo1.place_forget()
                    combo2.place_forget()
                    combo3.place_forget()
                    combo4.place_forget()
                    checkbutton_5.place_forget()
                    labelFrame_Esfuerzos.place_forget()
                    label_longitud.place_forget()
                    label_fuerza.place_forget()
                    label_Momento.place_forget()
                    label_Tension.place_forget()
                    longitud_1.place_forget()
                    Fuerza_1.place_forget()
                    entry_momento.place_forget()
                    entry_tension.place_forget()
                    checkbutton_6.place_forget()
                    labelFrame_Nota.place_forget()
                    label_mensaje_nota.place_forget()
                    labelFrame_Materiales.place_forget()
                    label_concreto.place_forget()
                    label_descripcion_concreto.place_forget()
                    label_acero.place_forget()
                    label_descripcion_acero.place_forget()
                    combo_concreto.place_forget()
                    entry_descripcion_concreto.place_forget()
                    combo_acero.place_forget()
                    entry_descripcion_acero.place_forget()
                    labelFrame_boton.place_forget()
                    label_configuracion.place_forget()
                    
                    
                    
                    # Mostrar el campo "Nombre del modelo" si la opción seleccionada es 'Nuevo Modelo'
                elif treeview.item(item)['text'] == 'Nuevo Modelo':
                    label_nombre_modelo.place(x=40, y=50)
                    label_descripcion_modelo.place(x=40, y=100)
                    entry_nombre_modelo.place(x=170, y=50, width=320)
                    text_detalles_modelo.place(x=40, y=140, width=450, height=100)
                    labelFrame_complementos.place(x=40,y=250,width=450,height=100)
                    checkbutton_2.place(x=10,y=10)
                    checkbutton_3.place(x=230,y=10)
                    checkbutton_4.place(x=10,y=50)

                    # Ocultar otros widgets si no es la opción correcta
                    label_nombre_usuario.place_forget()
                    entry_nombre_usuario.place_forget()
                    label_fecha_entrada.place_forget()
                    entry_fecha_entrada.place_forget()
                    labelFrame_archivo_abrir.place_forget()
                    label_ruta_archivo.place_forget()
                    entry_ruta_archivo.place_forget()
                    labelFrame_archivo_información.place_forget()
                    label_ruta_usuario.place_forget()
                    entry_ruta_usuario.place_forget()
                    labelFrame_opciones.place_forget()
                    checkbutton_1.place_forget()
                    labelFrame_estilo.place_forget()
                    canvas_viga.place_forget()
                    labelFrame_contenido.place_forget()
                    combobox.place_forget()
                    label_tipo_viga.place_forget()
                    label_mensaje_ayuda.place_forget()
                    label_contenido_1.place_forget()
                    label_mensaje_ayuda_1.place_forget()
                    boton_aplicar.place_forget()
                    label_prueba.place_forget()
                    label_formato.place_forget()
                    formato_decimal.place_forget()
                    slider_1.place_forget()
                    label_mensaje_formato.place_forget()
                    label_formato_unidades.place_forget()
                    label_unidades_1.place_forget()
                    label_unidades_2.place_forget()
                    label_unidades_3.place_forget()
                    label_unidades_4.place_forget()
                    combo1.place_forget()
                    combo2.place_forget()
                    combo3.place_forget()
                    combo4.place_forget()
                    checkbutton_5.place_forget()
                    labelFrame_Esfuerzos.place_forget()
                    label_longitud.place_forget()
                    label_fuerza.place_forget()
                    label_Momento.place_forget()
                    label_Tension.place_forget()
                    longitud_1.place_forget()
                    Fuerza_1.place_forget()
                    entry_momento.place_forget()
                    entry_tension.place_forget()
                    checkbutton_6.place_forget()
                    labelFrame_Nota.place_forget()
                    label_mensaje_nota.place_forget()
                    labelFrame_Materiales.place_forget()
                    label_concreto.place_forget()
                    label_descripcion_concreto.place_forget()
                    label_acero.place_forget()
                    label_descripcion_acero.place_forget()
                    combo_concreto.place_forget()
                    entry_descripcion_concreto.place_forget()
                    combo_acero.place_forget()
                    entry_descripcion_acero.place_forget()
                    labelFrame_boton.place_forget()
                    label_configuracion.place_forget()
                    
                    
                    
                    
                    
                # Mostrar el LabelFrame vacío para 'Estilo de Modelo'
                elif treeview.item(item)['text'] == 'Estilo de Modelo':
                    labelFrame_estilo.place(x=30, y=50, width=200, height=200) 
                    canvas_viga.place(x=2,y=2,width=190,height=170)
                    labelFrame_contenido.place(x=250,y=50,width=280, height=200)
                    combobox.place(x=100,y=20)
                    label_tipo_viga.place(x=20,y=20)
                    label_mensaje_ayuda.place(x=20,y=60,width=230,height=100)
                    label_contenido_1.place(x=30,y=260,width=501,height=100)
                    label_mensaje_ayuda_1.place(x=10,y=10)
                    boton_aplicar.place(x=200,y=40,width=100)
                    #label_prueba.place(x=50,y=40,width=150)
                    
                # Ocultar otros widgets si no es la opción correcta
                    label_nombre_modelo.place_forget()
                    label_descripcion_modelo.place_forget()
                    entry_nombre_modelo.place_forget()
                    text_detalles_modelo.place_forget()
                    labelFrame_complementos.place_forget()
                    checkbutton_2.place_forget()
                    checkbutton_3.place_forget()
                    checkbutton_4.place_forget()
                    label_nombre_usuario.place_forget()
                    entry_nombre_usuario.place_forget()
                    label_fecha_entrada.place_forget()
                    entry_fecha_entrada.place_forget()
                    labelFrame_archivo_abrir.place_forget()
                    label_ruta_archivo.place_forget()
                    entry_ruta_archivo.place_forget()
                    labelFrame_archivo_información.place_forget()
                    label_ruta_usuario.place_forget()
                    entry_ruta_usuario.place_forget()
                    labelFrame_opciones.place_forget()
                    checkbutton_1.place_forget()
                    label_formato.place_forget()
                    formato_decimal.place_forget()
                    slider_1.place_forget()
                    label_mensaje_formato.place_forget()
                    label_formato_unidades.place_forget()
                    label_unidades_1.place_forget()
                    label_unidades_2.place_forget()
                    label_unidades_3.place_forget()
                    label_unidades_4.place_forget()
                    combo1.place_forget()
                    combo2.place_forget()
                    combo3.place_forget()
                    combo4.place_forget()
                    checkbutton_5.place_forget()
                    labelFrame_Esfuerzos.place_forget()
                    label_longitud.place_forget()
                    label_fuerza.place_forget()
                    label_Momento.place_forget()
                    label_Tension.place_forget()
                    longitud_1.place_forget()
                    Fuerza_1.place_forget()
                    entry_momento.place_forget()
                    entry_tension.place_forget()
                    checkbutton_6.place_forget()
                    labelFrame_Nota.place_forget()
                    label_mensaje_nota.place_forget()
                    labelFrame_Materiales.place_forget()
                    label_concreto.place_forget()
                    label_descripcion_concreto.place_forget()
                    label_acero.place_forget()
                    label_descripcion_acero.place_forget()
                    combo_concreto.place_forget()
                    entry_descripcion_concreto.place_forget()
                    combo_acero.place_forget()
                    entry_descripcion_acero.place_forget()
                    labelFrame_boton.place_forget()
                    label_configuracion.place_forget()
                    
                    
                    
                # Mostrar el contenido para 'Unidades / Fuerzas'
                elif treeview.item(item)['text'] == 'Unidades / Esfuerzos':
                    label_formato.place(x=50,y=60,width=460,height=100)
                    formato_decimal.place(x=20,y=30)
                    slider_1.place(x=250,y=10)
                    label_mensaje_formato.place(x=20,y=60)
                    label_formato_unidades.place(x=50,y=180,width=460,height=180)
                    label_unidades_1.place(x=20,y=10)
                    label_unidades_2.place(x=20,y=40)
                    label_unidades_3.place(x=20,y=70)
                    label_unidades_4.place(x=20,y=100)
                    combo1.place(x=220,y=10)
                    combo2.place(x=220,y=40)
                    combo3.place(x=220,y=70)
                    combo4.place(x=220,y=100)
                    checkbutton_5.place(x=20,y=135)
                    
                    
                    
                    # Ocultar otros widgets si no es la opción correcta
                    label_nombre_modelo.place_forget()
                    label_descripcion_modelo.place_forget()
                    entry_nombre_modelo.place_forget()
                    text_detalles_modelo.place_forget()
                    labelFrame_complementos.place_forget()
                    checkbutton_2.place_forget()
                    checkbutton_3.place_forget()
                    checkbutton_4.place_forget()
                    label_nombre_usuario.place_forget()
                    entry_nombre_usuario.place_forget()
                    label_fecha_entrada.place_forget()
                    entry_fecha_entrada.place_forget()
                    labelFrame_archivo_abrir.place_forget()
                    label_ruta_archivo.place_forget()
                    entry_ruta_archivo.place_forget()
                    labelFrame_archivo_información.place_forget()
                    label_ruta_usuario.place_forget()
                    entry_ruta_usuario.place_forget()
                    labelFrame_opciones.place_forget()
                    checkbutton_1.place_forget()
                    labelFrame_estilo.place_forget()
                    canvas_viga.place_forget()
                    labelFrame_contenido.place_forget()
                    combobox.place_forget()
                    label_tipo_viga.place_forget()
                    label_mensaje_ayuda.place_forget()
                    label_contenido_1.place_forget()
                    label_mensaje_ayuda_1.place_forget()
                    boton_aplicar.place_forget()
                    label_prueba.place_forget()
                    labelFrame_Esfuerzos.place_forget()
                    label_longitud.place_forget()
                    label_fuerza.place_forget()
                    label_Momento.place_forget()
                    label_Tension.place_forget()
                    longitud_1.place_forget()
                    Fuerza_1.place_forget()
                    entry_momento.place_forget()
                    entry_tension.place_forget()
                    checkbutton_6.place_forget()
                    labelFrame_Nota.place_forget()
                    label_mensaje_nota.place_forget()
                    labelFrame_Materiales.place_forget()
                    label_concreto.place_forget()
                    label_descripcion_concreto.place_forget()
                    label_acero.place_forget()
                    label_descripcion_acero.place_forget()
                    combo_concreto.place_forget()
                    entry_descripcion_concreto.place_forget()
                    combo_acero.place_forget()
                    entry_descripcion_acero.place_forget()
                    labelFrame_boton.place_forget()
                    label_configuracion.place_forget()
                    
                    
                    
                    
                # Mostrar el contenido para 'Unidades / Fuerzas'
                elif treeview.item(item)['text'] == 'Esfuerzos':
                    labelFrame_Esfuerzos.place(x=50,y=60,width=460,height=250)
                    label_longitud.place(x=20,y=30)
                    label_fuerza.place(x=20,y=70)
                    label_Momento.place(x=20,y=110)
                    label_Tension.place(x=20,y=150)
                    longitud_1.place(x=200,y=30)
                    Fuerza_1.place(x=200,y=70)
                    entry_momento.place(x=200,y=110,width=143)
                    entry_tension.place(x=200,y=150,width=143)
                    checkbutton_6.place(x=30,y=200)
                    labelFrame_Nota.place(x=50,y=320,width=460,height=50)
                    label_mensaje_nota.place(x=10,y=10)
                    
                    
                    
                    
                    
                    # Ocultar otros widgets si no es la opción correcta
                    label_nombre_modelo.place_forget()
                    label_descripcion_modelo.place_forget()
                    entry_nombre_modelo.place_forget()
                    text_detalles_modelo.place_forget()
                    label_nombre_usuario.place_forget()
                    entry_nombre_usuario.place_forget()
                    label_fecha_entrada.place_forget()
                    entry_fecha_entrada.place_forget()
                    labelFrame_archivo_abrir.place_forget()
                    label_ruta_archivo.place_forget()
                    entry_ruta_archivo.place_forget()
                    labelFrame_archivo_información.place_forget()
                    label_ruta_usuario.place_forget()
                    entry_ruta_usuario.place_forget()
                    labelFrame_opciones.place_forget()
                    checkbutton_1.place_forget()
                    labelFrame_complementos.place_forget()
                    checkbutton_2.place_forget()
                    checkbutton_3.place_forget()
                    checkbutton_4.place_forget()
                    labelFrame_estilo.place_forget()
                    canvas_viga.place_forget()
                    labelFrame_contenido.place_forget()
                    combobox.place_forget()
                    label_tipo_viga.place_forget()
                    label_mensaje_ayuda.place_forget()
                    label_contenido_1.place_forget()
                    label_mensaje_ayuda_1.place_forget()
                    boton_aplicar.place_forget()
                    label_prueba.place_forget()
                    label_formato.place_forget()
                    formato_decimal.place_forget()
                    slider_1.place_forget()
                    label_mensaje_formato.place_forget()
                    label_formato_unidades.place_forget()
                    label_unidades_1.place_forget()
                    label_unidades_2.place_forget()
                    label_unidades_3.place_forget()
                    label_unidades_4.place_forget()
                    combo1.place_forget()
                    combo2.place_forget()
                    combo3.place_forget()
                    combo4.place_forget()
                    checkbutton_5.place_forget()
                    labelFrame_Materiales.place_forget()
                    label_concreto.place_forget()
                    label_descripcion_concreto.place_forget()
                    label_acero.place_forget()
                    label_descripcion_acero.place_forget()
                    combo_concreto.place_forget()
                    entry_descripcion_concreto.place_forget()
                    combo_acero.place_forget()
                    entry_descripcion_acero.place_forget()
                    labelFrame_boton.place_forget()
                    label_configuracion.place_forget()
                    
                    
                    # Mostrar el contenido para 'Unidades / Fuerzas'
                if treeview.item(item)['text'] == "Concreto / Acero":
                    labelFrame_Materiales.place(x=50,y=60,width=460,height=260)
                    label_concreto.place(x=80,y=30)
                    label_descripcion_concreto.place(x=80,y=80)
                    label_acero.place(x=80,y=130)
                    label_descripcion_acero.place(x=80,y=180)
                    combo_concreto.place(x=200,y=30)
                    entry_descripcion_concreto.place(x=200,y=80,width=142)
                    combo_acero.place(x=200,y=130)
                    entry_descripcion_acero.place(x=200,y=180,width=142)
                    labelFrame_boton.place(x=50,y=30,width=460,height=30)
                    boton_concreto_acero = tk.Button(labelFrame_Materiales, image=icono_concreto_acero, compound="top",command=abrir_subventana)
                    boton_concreto_acero.place(x=420,y=1)
                    label_configuracion.place(x=1,y=5)
                    
                    
                    # Ocultar todos los widgets si se selecciona otra opción
                    label_nombre_modelo.place_forget()
                    label_descripcion_modelo.place_forget()
                    entry_nombre_modelo.place_forget()
                    text_detalles_modelo.place_forget()
                    label_nombre_usuario.place_forget()
                    entry_nombre_usuario.place_forget()
                    label_fecha_entrada.place_forget()
                    entry_fecha_entrada.place_forget()
                    labelFrame_archivo_abrir.place_forget()
                    label_ruta_archivo.place_forget()
                    entry_ruta_archivo.place_forget()
                    labelFrame_archivo_información.place_forget()
                    label_ruta_usuario.place_forget()
                    entry_ruta_usuario.place_forget()
                    labelFrame_opciones.place_forget()
                    checkbutton_1.place_forget()
                    labelFrame_complementos.place_forget()
                    checkbutton_2.place_forget()
                    checkbutton_3.place_forget()
                    checkbutton_4.place_forget()
                    labelFrame_estilo.place_forget()
                    canvas_viga.place_forget()
                    labelFrame_contenido.place_forget()
                    combobox.place_forget()
                    label_tipo_viga.place_forget()
                    label_mensaje_ayuda.place_forget()
                    label_contenido_1.place_forget()
                    label_mensaje_ayuda_1.place_forget()
                    boton_aplicar.place_forget()
                    label_prueba.place_forget()
                    label_formato.place_forget()
                    formato_decimal.place_forget()
                    slider_1.place_forget()
                    label_mensaje_formato.place_forget()
                    label_formato_unidades.place_forget()
                    label_unidades_1.place_forget()
                    label_unidades_2.place_forget()
                    label_unidades_3.place_forget()
                    label_unidades_4.place_forget()
                    combo1.place_forget()
                    combo2.place_forget()
                    combo3.place_forget()
                    combo4.place_forget()
                    checkbutton_5.place_forget()
                    labelFrame_Esfuerzos.place_forget()
                    label_longitud.place_forget()
                    label_fuerza.place_forget()
                    label_Momento.place_forget()
                    label_Tension.place_forget()
                    longitud_1.place_forget()
                    Fuerza_1.place_forget()
                    entry_momento.place_forget()
                    entry_tension.place_forget()
                    checkbutton_6.place_forget()
                    labelFrame_Nota.place_forget()
                    label_mensaje_nota.place_forget()
                    
                    
                    

        # Vincular el evento de selección para mostrar información
        treeview.bind('<<TreeviewSelect>>', mostrar_informacion)
        
        
        # Crear el frame para mostrar la información (lado derecho)
        frame_derecha = tk.Frame(Ventana_Nuevo, bd=2, relief="raise")
        frame_derecha.place(x=220, y=17, width=560, height=393)

        # Crear una etiqueta para mostrar la información
        label_info = tk.LabelFrame(frame_derecha, text="")
        label_info.place(x=12, y=12, width=535, height=366)

        # Agregar un Label y Entry para "Nuevo modelo" y widgets
        label_nombre_modelo = tk.Label(frame_derecha, text="Nombre del modelo:")
        label_descripcion_modelo= tk.Label(frame_derecha, text="Descripción:") 
        entry_nombre_modelo = tk.Entry(frame_derecha)
        text_detalles_modelo = tk.Text(frame_derecha)
        labelFrame_complementos = tk.LabelFrame(frame_derecha,text="Complementos adicionales")
        
        # Agregar un Label y Entru para "General" y widgets
        label_nombre_usuario =tk.Label(frame_derecha, text="Nombre de usuario:")
        entry_nombre_usuario =tk.Entry(frame_derecha)
        label_fecha_entrada = tk.Label(frame_derecha, text="Fecha:")
        entry_fecha_entrada = tk.Entry(frame_derecha)
        labelFrame_archivo_abrir = tk.LabelFrame(frame_derecha,text="Guardar \ Archivo")
        label_ruta_archivo = tk.Label(labelFrame_archivo_abrir, text="Ruta del archivo:")
        entry_ruta_archivo = tk.Entry(labelFrame_archivo_abrir)
        labelFrame_archivo_información = tk.LabelFrame(frame_derecha, text="Guardar \ Información \ Usuario")
        label_ruta_usuario = tk.Label(labelFrame_archivo_información,text="Ruta del usuario:")
        entry_ruta_usuario = tk.Entry(labelFrame_archivo_información)
        labelFrame_opciones = tk.LabelFrame(frame_derecha,text="Opciones de autoguardado")
        
        # Agregar un Label y Entru para "Estilo de Modelo" y widgets
        labelFrame_estilo = tk.LabelFrame(frame_derecha,text="Plantilla")
        canvas_viga = tk.Canvas(labelFrame_estilo)
        labelFrame_contenido = tk.LabelFrame(frame_derecha,text="Selección de modelo")
        label_tipo_viga = tk.Label(labelFrame_contenido,text="Tipo Viga:")
        label_mensaje_ayuda = tk.Label(labelFrame_contenido,text="",width=30, height=5,bg="white",bd=2,relief="groove",anchor="w", justify="left", wraplength=230)
        label_contenido_1 = tk.LabelFrame(frame_derecha,text="Visualización de modelo")
        label_mensaje_ayuda_1 = tk.Label(label_contenido_1,text="Para ver la visualización del modelo en la ventana principal, haz clic en el botón 'Aplicar'")
        label_prueba = tk.Label(label_contenido_1,text="")
        
        
        # Agregar un Label y Entru para "Unidades / Esfuerzos" y widgets
        label_formato =tk.LabelFrame(frame_derecha,text="")
        formato_decimal= tk.Label(label_formato,text="Valor numérico en formato decimal:")
        label_mensaje_formato = tk.Label(label_formato,text="")
        label_formato_unidades = tk.LabelFrame(frame_derecha,text="")
        label_unidades_1 = tk.Label(label_formato_unidades,text="Dimensiones de la viga:")
        label_unidades_2 = tk.Label(label_formato_unidades,text="Dimensiones de la sección:")
        label_unidades_3 = tk.Label(label_formato_unidades,text="Diamentro barras de refuerzo:")
        label_unidades_4 = tk.Label(label_formato_unidades,text="Área de sección de refuerzo:")
        
        # Agregar un Label y Entru para " Esfuerzos" y widgets
        labelFrame_Esfuerzos = tk.LabelFrame(frame_derecha,text="")
        label_longitud = tk.Label(labelFrame_Esfuerzos,text="Unidad de longitud:")
        label_fuerza = tk.Label(labelFrame_Esfuerzos,text="Unidad de Fuerza:")
        label_Momento = tk.Label(labelFrame_Esfuerzos,text="Unidad de Momento:")
        label_Tension = tk.Label(labelFrame_Esfuerzos,text="Unidad de Tensión:")
        entry_momento = tk.Entry(labelFrame_Esfuerzos)
        entry_tension =  tk.Entry(labelFrame_Esfuerzos)
        labelFrame_Nota = tk.LabelFrame(frame_derecha,text="",bd=0, relief="flat")
        label_mensaje_nota = tk.Label(labelFrame_Nota,text="")
        
        # Agregar un Label y Entru para "Concreto / Acero" y widgets
        labelFrame_Materiales = tk.LabelFrame(frame_derecha,text="Materiales")
        label_concreto = tk.Label(labelFrame_Materiales,text= "Concreto [f'c]:")
        label_descripcion_concreto = tk.Label(labelFrame_Materiales,text="Descripción:")
        label_acero = tk.Label(labelFrame_Materiales,text= "Acero [fy]:")
        label_descripcion_acero = tk.Label(labelFrame_Materiales,text="Descripción:")
        combo_concreto= ttk.Combobox(labelFrame_Materiales)
        entry_descripcion_concreto= tk.Entry(labelFrame_Materiales)
        combo_acero = ttk.Combobox(labelFrame_Materiales)
        entry_descripcion_acero= tk.Entry(labelFrame_Materiales)
        labelFrame_boton = tk.LabelFrame(frame_derecha,text="",bd=0, relief="flat")
        label_configuracion = tk.Label(labelFrame_boton,text="Nota: Haz clic en el ícono en la esquina superior derecha para cargar los materiales.")
        
        # Cargar datos si existen y asignar valores al Combobox
        datos_cargados = cargar_datos()
        opciones_concreto = [
        "f'c = 17.5 MPa",
        "f'c = 21 MPa",
        "f'c = 24.5 MPa",
        "f'c = 28 MPa",
        "f'c = 35 MPa",
        "f'c = 42 MPa",
        ]
        opciones_acero = [
        "fy = 240 MPa",
        "fy = 420 MPa",
        ]
        combo_concreto["values"] = opciones_concreto  
        combo_acero["values"] = opciones_acero
        
        if datos_cargados:
            entry_nombre_usuario.insert(0, datos_cargados.get("nombre_usuario", ""))
            entry_nombre_modelo.insert(0, datos_cargados.get("nombre_modelo", ""))
            text_detalles_modelo.insert("1.0", datos_cargados.get("detalles_modelo", ""))
            combo_concreto.set(datos_cargados.get("combo_concreto", opciones_concreto[0]))
            combo_acero.set(datos_cargados.get("combo_acero", opciones_acero[0]))
        
        else:
            Ventana_Nuevo.focus_set()
        
        
        # Botón "Aceptar" para guardar los datos
        boton_aceptar = ttk.Button(Ventana_Nuevo, text="Aceptar",command=guardar_datos)
        boton_aceptar.place(x=350,y=430,width=100)
        
        
        # Lista con las opciones de unidades Longitud/Fuerza
        
        Longitud= ["m"]
        Fuerza =  ["kN"]
        
        # Crear el ComboBox y agregar las opciones
        longitud_1 = ttk.Combobox(labelFrame_Esfuerzos, values=Longitud)
        longitud_1.set("Seleccionar")
        Fuerza_1 = ttk.Combobox(labelFrame_Esfuerzos, values=Fuerza)
        Fuerza_1.set("Seleccionar")
        
        
        # Función que actualiza los valores en los Entry cuando se seleccionan las unidades
        def actualizar_unidades(event):
        # Obtener los valores seleccionados en los ComboBox
            unidad_fuerza = Fuerza_1.get()
            unidad_longitud = longitud_1.get()
        
        # Comprobar si ambos ComboBox tienen opciones seleccionadas
            if unidad_fuerza != "Seleccionar" and unidad_longitud != "Seleccionar":
        # Actualizar el valor del momento y la tensión
                entry_momento.delete(0, tk.END)
                entry_tension.delete(0, tk.END)
        
                entry_momento.insert(0, f"{unidad_fuerza}{unidad_longitud}")  # Ejemplo: kNm
                entry_tension.insert(0, f"{unidad_fuerza}{unidad_longitud}²")  # Ejemplo: kNm²
        
        # Vincular la función al evento de cambio de selección en los ComboBox
        Fuerza_1.bind("<<ComboboxSelected>>", actualizar_unidades)
        longitud_1.bind("<<ComboboxSelected>>", actualizar_unidades)
        
        # Lista con las opciones de unidades
        unidades = ["metros", "centímetos", "milímetros"]
        
        # Crear el ComboBox y agregar las opciones
        combo1 = ttk.Combobox(label_formato_unidades, values=unidades)
        combo1.set("Seleccionar")  # Establecer el valor por defecto
        
        combo2 = ttk.Combobox(label_formato_unidades, values=unidades)
        combo2.set("Seleccionar")  # Establecer el valor por defecto
        
        combo3 = ttk.Combobox(label_formato_unidades, values=unidades)
        combo3.set("Seleccionar")  # Establecer el valor por defecto
        
        combo4= ttk.Combobox(label_formato_unidades, values=unidades)
        combo4.set("Seleccionar")  # Establecer el valor por defecto
        
        
        # Combobox dentro de labelFrame_contenido
        combobox = ttk.Combobox(labelFrame_contenido, values=["Viga apoyada","Viga empotrada "])
        combobox.set("Selecciona una opción")
        combobox.bind("<<ComboboxSelected>>", lambda event: on_combobox_select(event, canvas_viga,label_mensaje_ayuda,label_prueba))
        
        # Botón para visualizar modelo viga 
        boton_aplicar= ttk.Button(label_contenido_1,text="Aplicar",command=lambda: on_boton_aplicar_click(label_contenido_1, label_prueba))
        
        def update_label(val):
        # Convertir el valor a entero y calcular cuántos ceros agregar
            num_zeros = int(val)  # El valor del slider es un número entero que indica los ceros
            formatted_value = "0." + "0" * num_zeros  # Construir el número con 'num_zeros' ceros
            label_mensaje_formato.config(text=formatted_value)  # Actualizar la etiqueta con el valor formateado
        
        # Crear el mensaje con el valor del slider y la recomendación
            mensaje_slider = f"Seleccionaste el valor en formato decimal con una precisión de: {formatted_value}"
            label_mensaje_formato.config(text=mensaje_slider)  # Actualizar el mensaje en el label
        
        
        # Configurar el slider (de 0 a 4, con incremento de 1, orientado horizontalmente)
        slider_1 = tk.Scale(label_formato, from_=0, to=4, resolution=1, orient="horizontal", command=update_label)
        slider_1.set(0)  # Establecer valor inicial en 0
        
        #Crear widgets para "General"
        # Variable de control para el checkbutton
        var = tk.IntVar()
        var1 = tk.IntVar()
        var2 = tk.IntVar()
        var3 = tk.IntVar()
        var4 = tk.IntVar()
        var5 = tk.IntVar()
        
        # Función para cambiar el color del chulito cuando se marca o desmarca
        def cambiar_color(checkbutton,var):
            if var.get() == 1:
                checkbutton.config(selectcolor="blue")
            else:
                checkbutton.config(selectcolor="")
        
        
        # Función para cambiar el formato de los ComboBoxes cuando se activa el Checkbutton
        def aplicar_formato_predefinido():
            if var4.get() == 1:  # Si el Checkbutton está activado
                combo1.set("metros")  # Primer ComboBox -> "metros"
                combo2.set("metros")  # Segundo ComboBox -> "metros"
                combo3.set("milímetros")  # Tercer ComboBox -> "milímetros"
                combo4.set("milímetros")  # Cuarto ComboBox -> "milímetros"
            else:
        # Si el Checkbutton está desactivado, los ComboBoxes se reinician a "Seleccionar"
                combo1.set("Seleccionar")
                combo2.set("Seleccionar")
                combo3.set("Seleccionar")
                combo4.set("Seleccionar")
        
        # Función para manejar el Checkbutton y seleccionar valores por defecto
        def cambiar_a_valores_por_defecto():
            if var5.get():  # Si el Checkbutton está marcado
        # Establecer los valores predeterminados en los ComboBox
                Fuerza_1.set("kN")
                longitud_1.set("m")
        
        # Actualizar los campos de entrada
                entry_momento.delete(0, tk.END)
                entry_tension.delete(0, tk.END)
                entry_momento.insert(0, "kNm")  # Valor predeterminado para el momento
                entry_tension.insert(0, "kNm²")  # Valor predeterminado para la tensión
                
                # Mostrar un mensaje interactivo en el label
                label_mensaje_nota.config(text="¡Muy bien! Ahora continua con la configuración de los materiales.")
        
            else:
        # Si el Checkbutton está desmarcado, dejar las opciones en blanco o por defecto
                Fuerza_1.set("Seleccionar")
                longitud_1.set("Seleccionar")
                entry_momento.delete(0, tk.END)
                entry_tension.delete(0, tk.END)
                entry_momento.insert(0, "Momento")  # Valor predeterminado (opcional)
                entry_tension.insert(0, "Tensión")  # Valor predeterminado (opcional)
        
        # Crear el Checkbutton personalizado
        checkbutton_1 = tk.Checkbutton(
        labelFrame_opciones,
        text="Guardar información predeterminada",   
        variable=var,                                
        onvalue=1,                                    
        offvalue=0,                                   
        indicatoron=True,                             
        selectcolor="",                               
        command=lambda: cambiar_color(checkbutton_1, var)                   
        )
        
        # Crear el Checkbutton para "Generar documento Word"
        checkbutton_2 = tk.Checkbutton(
        labelFrame_complementos,
        text="Generar documento Word",
        variable=var1,
        onvalue=1,
        offvalue=0,
        indicatoron=True,
        selectcolor="",
        command=lambda: cambiar_color(checkbutton_2, var1)
        )
        
        # Crear el Checkbutton para "Generar archivo PDF"
        checkbutton_3 = tk.Checkbutton(
        labelFrame_complementos,
        text="Generar archivo PDF",
        variable=var2,
        onvalue=1,
        offvalue=0,
        indicatoron=True,
        selectcolor="",
        command=lambda: cambiar_color(checkbutton_3, var2)
        )
        
        
        # Crear el Checkbutton para "Exportar datos a Excel"
        checkbutton_4 = tk.Checkbutton(
        labelFrame_complementos,
        text="Exportar datos a Excel",
        variable=var3,
        onvalue=1,
        offvalue=0,
        indicatoron=True,
        selectcolor="",
        command=lambda: cambiar_color(checkbutton_4, var3)
        )
        # Crear el Checkbutton para seleccionar formato predefinido
        checkbutton_5 = tk.Checkbutton(
        label_formato_unidades, 
        text="Seleccionar formato predefinido",
        variable=var4,
        onvalue=1,
        offvalue=0,
        indicatoron=True,
        selectcolor="",
        command=lambda: [aplicar_formato_predefinido(), cambiar_color(checkbutton_5, var4)] 
        )        
        # Crear el Checkbutton para seleccionar formato predefinido
        checkbutton_6 = tk.Checkbutton(
        labelFrame_Esfuerzos, 
        text="Seleccionar configuración por defecto",
        variable=var5,
        onvalue=1,
        offvalue=0,
        indicatoron=True,
        selectcolor="",
        command=lambda: [cambiar_a_valores_por_defecto(), cambiar_color(checkbutton_6, var5)]
        )
        
        def actualizar_fecha():
        # Obtener la fecha actual en la zona horaria de Colombia
            zona_horaria_colombia = timezone('America/Bogota')
            fecha_actual = datetime.now(zona_horaria_colombia).strftime('%d-%m-%Y') 
        
        # Verificar si el widget sigue existiendo antes de actualizarlo
            if entry_fecha_entrada.winfo_exists():  # Verifica si el widget sigue existiendo
            # Limpiar el Entry y poner la nueva fecha
                entry_fecha_entrada.delete(0, tk.END)
                entry_fecha_entrada.insert(0, fecha_actual)
        
        # Llamar a esta función de nuevo después de 1000 ms (1 segundo) para actualizar la fecha
            ventana.after(1000, actualizar_fecha)
            
        # Llamar a la función para actualizar la fecha
        actualizar_fecha()
        
        # Función para obtener la ruta de la carpeta "Archivos_Pilot" en el escritorio
        def obtener_ruta_archivos_pilot():
        # Obtenemos el directorio de "Escritorio" según el sistema operativo
            sistema = platform.system()
        
            if sistema == "Windows":
        # En Windows, obtenemos el "Desktop" del usuario
                ruta_base = os.path.join(os.environ["USERPROFILE"], "Desktop")
            elif sistema == "Darwin":  # macOS
        # En macOS, obtenemos el "Desktop" del usuario
                ruta_base = os.path.join(os.path.expanduser("~"), "Desktop")
            elif sistema == "Linux":
        # En Linux, igualmente el "Desktop"
                ruta_base = os.path.join(os.path.expanduser("~"), "Desktop")
            else:
        # Si no es Windows, macOS ni Linux, retornamos una ruta genérica
                ruta_base = os.path.expanduser("~")
        
        # Ruta final donde guardaremos los archivos
            ruta_archivos_pilot = os.path.join(ruta_base, "Archivos_Pilot")
            
        # Si la carpeta "Archivos_Pilot" no existe, la creamos
            if not os.path.exists(ruta_archivos_pilot):
                os.makedirs(ruta_archivos_pilot)
        
            return ruta_archivos_pilot
        
        # Función para mostrar la ruta en el Entry
        def mostrar_ruta_archivos_pilot():
        # Obtener la ruta de "Archivos_Pilot" dependiendo del sistema
            ruta_archivos = obtener_ruta_archivos_pilot()
        
        # Mostrar la ruta en el Entry
            entry_ruta_archivo.delete(0, tk.END)  # Limpiar el Entry
            entry_ruta_archivo.insert(0, ruta_archivos)  # Insertar la ruta correcta
        
        # Llamamos a la función para mostrar la ruta al iniciar la aplicación
        mostrar_ruta_archivos_pilot()


# Ruta de la carpeta base_datos en tu entorno de programa
carpeta_base_datos = "base_datos"
archivo_datos_materiales = os.path.join(carpeta_base_datos, "datos_materiales.txt")  # Archivo donde se guardarán los datos

# Crear la carpeta base_datos si no existe
if not os.path.exists(carpeta_base_datos):
    os.makedirs(carpeta_base_datos)

ventana_materiales_abierta = False
# Variables globales para los Entry y ComboBox
entry_resistencia_concreto = None
entry_modulo_concreto = None
combo_resistencia_concreto = None
label_mensaje_materiales = None

# Función para guardar los datos de los materiales
def guardar_datos_materiales():
    """Guarda los datos de los widgets en un archivo de texto (ventana materiales)."""
    # Obtener los datos de los Entry y ComboBox
    resistencia_concreto = entry_resistencia_concreto.get().strip()
    modulo_concreto = entry_modulo_concreto.get().strip()
    #Obtener el texto del Label (mensaje)
    mensaje_materiales = label_mensaje_materiales.cget("text")  


    # Crear un diccionario con los datos que se van a guardar
    datos_materiales = {
        "resistencia_concreto": resistencia_concreto,
        "modulo_concreto": modulo_concreto,
        "mensaje_materiales": mensaje_materiales  
    }

    # Guardar los datos en el archivo de texto
    with open(archivo_datos_materiales, "w") as archivo:
        for clave, valor in datos_materiales.items():
            archivo.write(f"{clave}:{valor}\n")

    

# Función para cargar los datos desde el archivo de materiales
def cargar_datos_materiales():
    """Carga los datos desde el archivo de texto de materiales si existe."""
    datos_materiales = {}
    try:
        with open(archivo_datos_materiales, "r") as archivo:
            for linea in archivo:
                clave, valor = linea.strip().split(":", 1)
                datos_materiales[clave] = valor
    except FileNotFoundError:
        pass  # Si el archivo no existe, no hacemos nada

    # Cargar los datos en los Entry de la ventana de materiales y label
    if datos_materiales:
        entry_resistencia_concreto.insert(0, datos_materiales.get("resistencia_concreto", ""))
        entry_modulo_concreto.insert(0, datos_materiales.get("modulo_concreto", ""))
        # Cargar el mensaje en el Label
        label_mensaje_materiales.config(text=datos_materiales.get("mensaje_materiales", ""))

# Función para manejar la lógica de la ventana de materiales
def on_aceptar_materiales():
    """Función que se ejecuta cuando se hace clic en el botón 'Aceptar'"""
    # Guardar los datos de los Entry y ComboBox en el archivo
    guardar_datos_materiales()
    
    # Aquí puedes agregar más lógica si deseas, como cerrar la ventana o realizar otro proceso
    
    # Cerrar la ventana de materiales
    global ventana_materiales_abierta, ventana_materiales
    ventana_materiales_abierta = False  # Marcar que la ventana ya no está abierta
    ventana_materiales.destroy()  # Cerrar la ventana de materiales

# Función para abrir la ventana materiales

def abrir_ventana_materiales():
    global ventana_materiales_abierta,ventana_materiales
    global entry_resistencia_concreto, entry_modulo_concreto, combo_resistencia_concreto,label_mensaje_materiales,label_elasticidad,Ec
    global label_resistencia_psi
    
    # Verificar si la ventana ya está abierta
    if ventana_materiales_abierta:
        return  # Si ya está abierta, no hacer nada
    
    # Crear una nueva ventana (Toplevel)
    ventana_materiales = tk.Toplevel()
    ventana_materiales.title("Materiales")
    ventana_materiales.geometry("600x600")  # Ajusta el tamaño según sea necesario
    
    # Bloquear la opción de redimensionar la ventana
    ventana_materiales.resizable(False, False)
    
    # Mantener la ventana siempre encima
    ventana_materiales.attributes('-topmost', True)
    
    # Marcar que la ventana está abierta
    ventana_materiales_abierta = True
    
    # Lista de datos para el ComboBox
    opciones_resistencia = ["17.5 Mpa", "21 Mpa", "24.5 Mpa", "28 Mpa", "35 Mpa", "42 Mpa"]
    
    # Crear un LabelFrame para agrupar el contenido de Materiales
    labelframe_materiales= tk.LabelFrame(ventana_materiales,text="")
    labelframe_materiales.pack(padx=20, pady=20, fill="both", expand=True)
    labelframe_titulo = tk.LabelFrame(labelframe_materiales,text="Materiales")
    labelframe_titulo.place(x=30,y=30,width=500,height=200)
    label_resistencia_concreto=tk.Label(labelframe_titulo,text="Resistencia a la compresión del concreto [f'c]:")
    label_resistencia_concreto.place(x=10,y=20)
    label_resistencia_tipo = tk.Label(labelframe_titulo,text="Resistencia concreto tipo [C]:")
    label_resistencia_tipo.place(x=10,y=60)
    label_resistencia_acero= tk.Label(labelframe_titulo,text="Resistencia a la tensión del acero [fy]:")
    label_resistencia_acero.place(x=10,y=100)
    label_peso_concreto = tk.Label(labelframe_titulo,text="Peso específico del concreto [γ]:")
    label_peso_concreto.place(x=10,y=140)
    combo_resistencia_concreto= ttk.Combobox(labelframe_titulo, values=opciones_resistencia)
    combo_resistencia_concreto.place(x=300,y=20)
    entry_resistencia_concreto= tk.Entry(labelframe_titulo)
    entry_resistencia_concreto.place(x=300,y=60,width=143)
    entry_resistencia_acero= tk.Entry(labelframe_titulo)
    entry_resistencia_acero.place(x=300,y=100,width=143)
    entry_resistencia_acero.insert(0, "420 MPa")
    entry_peso_concreto= tk.Entry(labelframe_titulo)
    entry_peso_concreto.place(x=300,y=140,width=143)
    entry_peso_concreto.insert(0,"24.00 kN/m³")
    labelframe_propiedades = tk.LabelFrame(labelframe_materiales,text="Propiedades mecánicas")
    labelframe_propiedades.place(x=30,y=250,width=500,height=200)
    label_modulo_concreto = tk.Label(labelframe_propiedades,text="Módulo elasticidad del concreto [Ec]:")
    label_modulo_concreto.place(x=10,y=20)
    entry_modulo_concreto= tk.Entry(labelframe_propiedades)
    entry_modulo_concreto.place(x=300,y=20,width=143)
    label_modulo_acero = tk.Label(labelframe_propiedades,text="Módulo elasticidad del acero [Es]:")
    label_modulo_acero.place(x=10,y=60)
    entry_modulo_acero= tk.Entry(labelframe_propiedades)
    entry_modulo_acero.place(x=300,y=60,width=143)
    entry_modulo_acero.insert(0, "200000 MPa")  
    label_deformacion_concreto = tk.Label(labelframe_propiedades,text="Deformación unitaria concreto [Ɛc]: ")
    label_deformacion_concreto.place(x=10,y=100)
    entry_deformacion_concreto = tk.Entry(labelframe_propiedades)
    entry_deformacion_concreto.place(x=300,y=100,width=143)
    entry_deformacion_concreto.insert(0, "0.003")
    label_deformacion_acero = tk.Label(labelframe_propiedades,text="Deformación unitaria acero [Ɛs]: ")
    label_deformacion_acero.place(x=10,y=140)
    entry_deformacion_acero = tk.Entry(labelframe_propiedades)
    entry_deformacion_acero.place(x=300,y=140,width=143)
    entry_deformacion_acero.insert(0, "0.005")  
    labelframe_mensaje_materiales= tk.LabelFrame(labelframe_materiales,text="")
    labelframe_mensaje_materiales.place(x=30,y=460,width=500,height=50)
    label_mensaje_materiales = tk.Label(labelframe_mensaje_materiales,justify="left",anchor="w",wraplength=500)
    label_mensaje_materiales.place(x=10,y=5)
    boton_aceptar_materiales = ttk.Button(labelframe_materiales,text="Aceptar",command=on_aceptar_materiales)
    boton_aceptar_materiales.place(x=220,y=520,width=100)
    
    # Cargar datos al abrir la ventana
    cargar_datos_materiales()
    
    # Función para actualizar el Entry según la selección del ComboBox
    def actualizar_entry(event):
        seleccion1 = combo_resistencia_concreto.get()  # Obtener la opción seleccionada
        if seleccion1 == "17.5 Mpa":
            entry_resistencia_concreto.delete(0, tk.END)  # Limpiar el Entry
            entry_resistencia_concreto.insert(0, "Concreto 2500 Psi")
        elif seleccion1 == "21 Mpa":
            entry_resistencia_concreto.delete(0, tk.END)
            entry_resistencia_concreto.insert(0, "Concreto 3000 Psi")
        elif seleccion1 == "24.5 Mpa":
            entry_resistencia_concreto.delete(0, tk.END)
            entry_resistencia_concreto.insert(0, "Concreto 3500 Psi")
        elif seleccion1 == "28 Mpa":
            entry_resistencia_concreto.delete(0, tk.END)
            entry_resistencia_concreto.insert(0, "Concreto 4000 Psi")
        elif seleccion1 == "35 Mpa":
            entry_resistencia_concreto.delete(0, tk.END)
            entry_resistencia_concreto.insert(0, "Concreto 5000 Psi")
        elif seleccion1 == "42 Mpa":
            entry_resistencia_concreto.delete(0, tk.END)
            entry_resistencia_concreto.insert(0, "Concreto 6000 Psi")
            
        #cálculo del módulo de elasticidad del concreto (Ec)
        f_c = float(seleccion1.split(" ")[0])  
        Ec = 3900 * math.sqrt(f_c)  # Calcular el módulo de elasticidad
        # Actualizar el entry_modulo_concreto con el resultado del cálculo
        entry_modulo_concreto.delete(0, tk.END)
        entry_modulo_concreto.insert(0, f"{Ec:.2f} MPa")  
        
        # Actualizar el Label con el mensaje personalizado
        mensaje1 = f"Has seleccionado el material {seleccion1}. Ahora,el siguiente paso es definir las propiedades geométricas de la sección transversal."
        label_mensaje_materiales.config(text=" " + mensaje1)
        
        # Actualizar el label_elasticidad con el valor calculado
        label_elasticidad.config(text=f"{Ec:.2f} MPa")
        
        # Obtener el valor de entry_resistencia_concreto y actualizar el label_resistencia_psi
        resistencia_psi = entry_resistencia_concreto.get()  
        label_resistencia_psi.config(text=f"{resistencia_psi}")  
    
    # Asociar la función de actualización del Entry con el evento de selección del ComboBox
    combo_resistencia_concreto.bind("<<ComboboxSelected>>", actualizar_entry)
    
        
    # Función para manejar el cierre de la ventana
    def cerrar_ventana():
        global ventana_materiales_abierta
        ventana_materiales_abierta = False
        ventana_materiales.destroy()
    
    # Asociar el cierre de la ventana con la función `cerrar_ventana`
    ventana_materiales.protocol("WM_DELETE_WINDOW", cerrar_ventana)
    


# Variables globales para los Entry y Labels
entry_luz_seccion = None
entry_base_seccion = None
entry_altura_seccion = None
entry_recubrimiento_seccion = None
entry_d_seccion = None
entry_nombre_seccion = None
label_resumen_1 = None
label_resumen_2 = None
label_resumen_3 = None
label_resumen_4 = None
label_resumen_5 = None
label_resumen_6 = None

# Ruta de la carpeta base_datos en tu entorno de programa
carpeta_base_datos = "base_datos"
archivo_datos_seccion = os.path.join(carpeta_base_datos, "datos_seccion.txt")

# Crear la carpeta base_datos si no existe
if not os.path.exists(carpeta_base_datos):
    os.makedirs(carpeta_base_datos)

# Función para guardar los datos de la sección transversal
def guardar_datos_seccion():
    """Guarda los datos de los Entry y Labels en un archivo de texto (ventana secciones)."""
    # Obtener los datos de los Entry y Labels
    luz_seccion = entry_luz_seccion.get().strip()
    base_seccion = entry_base_seccion.get().strip()
    altura_seccion = entry_altura_seccion.get().strip()
    recubrimiento_seccion = entry_recubrimiento_seccion.get().strip()
    d_seccion = entry_d_seccion.get().strip()
    nombre_seccion = entry_nombre_seccion.get().strip()

# Obtener los textos de los Labels (resumen)
    resumen_1 = label_resumen_1.cget("text")
    resumen_2 = label_resumen_2.cget("text")
    resumen_3 = label_resumen_3.cget("text")
    resumen_4 = label_resumen_4.cget("text")
    resumen_5 = label_resumen_5.cget("text")
    resumen_6 = label_resumen_6.cget("text")

# Crear un diccionario con los datos que se van a guardar
    datos_seccion = {
        "luz_seccion": luz_seccion,
        "base_seccion": base_seccion,
        "altura_seccion": altura_seccion,
        "recubrimiento_seccion": recubrimiento_seccion,
        "d_seccion": d_seccion,
        "nombre_seccion": nombre_seccion,
        "resumen_1": resumen_1,
        "resumen_2": resumen_2,
        "resumen_3": resumen_3,
        "resumen_4": resumen_4,
        "resumen_5": resumen_5,
        "resumen_6": resumen_6,
    }

# Guardar los datos en el archivo de texto
    with open(archivo_datos_seccion, "w") as archivo:
        for clave, valor in datos_seccion.items():
            archivo.write(f"{clave}:{valor}\n")

    # Mostrar un mensaje de confirmación
    print("Datos guardados exitosamente en el archivo.")

# Función para cargar los datos desde el archivo de la sección
def cargar_datos_seccion():
    """Carga los datos desde el archivo de texto de la sección si existe."""
    datos_seccion = {}
    
    try:
        with open(archivo_datos_seccion, "r") as archivo:
            for linea in archivo:
                clave, valor = linea.strip().split(":", 1)
                datos_seccion[clave] = valor
    except FileNotFoundError:
        pass  # Si el archivo no existe, no hacemos nada

    # Actualizar los Entry y Labels con los datos cargados
    if datos_seccion:
        entry_luz_seccion.delete(0, tk.END)
        entry_luz_seccion.insert(0, datos_seccion.get("luz_seccion", ""))
        
        entry_base_seccion.delete(0, tk.END)
        entry_base_seccion.insert(0, datos_seccion.get("base_seccion", ""))
        
        entry_altura_seccion.delete(0, tk.END)
        entry_altura_seccion.insert(0, datos_seccion.get("altura_seccion", ""))
        
        entry_recubrimiento_seccion.delete(0, tk.END)
        entry_recubrimiento_seccion.insert(0, datos_seccion.get("recubrimiento_seccion", ""))
        
        entry_d_seccion.delete(0, tk.END)
        entry_d_seccion.insert(0, datos_seccion.get("d_seccion", ""))
        
        entry_nombre_seccion.delete(0, tk.END)
        entry_nombre_seccion.insert(0, datos_seccion.get("nombre_seccion", ""))

        # Cargar los valores en los Labels de resumen
        label_resumen_1.config(text=datos_seccion.get("resumen_1", ""))
        label_resumen_2.config(text=datos_seccion.get("resumen_2", ""))
        label_resumen_3.config(text=datos_seccion.get("resumen_3", ""))
        label_resumen_4.config(text=datos_seccion.get("resumen_4", ""))
        label_resumen_5.config(text=datos_seccion.get("resumen_5", ""))
        label_resumen_6.config(text=datos_seccion.get("resumen_6", ""))

# Variable global para controlar si la ventana ya está abierta
ventana_secundaria_abierta = False



canvas_falso = None  # Canvas donde dibujaremos el rectángulo en frame_ventana_falsa
frame_ventana_seccion = None  # El frame principal donde se encuentra frame_ventana_falsa
frame_ventana_falsa = None  # El frame donde se dibujará el rectángulo
entry_base_seccion = None  # Entry para base del rectángulo
entry_altura_seccion = None  # Entry para altura del rectángulo
combo_resistencia = None


# Constantes para grosor
GROSORES = {
    'outer_thickness': 1.5,  # Grosor del borde externo
}

# Función para dibujar la sección rectangular con base y altura
def draw_section(ax, base, altura):
    ax.clear()

    # Configuración de estilo
    ax.figure.patch.set_facecolor('white')
    ax.set_facecolor('white')
    for spine in ax.spines.values():
        spine.set_edgecolor('black')
    ax.xaxis.label.set_color('black')
    ax.yaxis.label.set_color('black')
    ax.title.set_color('black')
    ax.tick_params(axis='both', colors='black')

    x = 0
    y = 0
    width = base
    height = altura

    # Dibujo del rectángulo exterior (sección completa)
    outer_rect = patches.Rectangle((x, y), width, height, linewidth=GROSORES['outer_thickness'], edgecolor='black', facecolor='grey')
    ax.add_patch(outer_rect)
    
    # Obtener el valor seleccionado del combo_resistencia
    resistencia_value = combo_resistencia.get()  # Obtener el valor seleccionado en el combo
    
    # Asegurarse de que entry_luz_seccion esté definido y obtener su valor
    luz_value = entry_luz_seccion.get() 
    
    # Agregar la leyenda justo debajo de la etiqueta "Base"
    legend_line = Line2D([0], [0], color='grey', lw=4, label=f'Concreto {resistencia_value}')
    
    # Agregar la leyenda para la luz debajo de la anterior
    light_line = Line2D([0], [0], color='blue', lw=4, label=f'Luz {luz_value}m')
    
    # Agregar las leyendas y configurar su posición
    ax.legend(handles=[legend_line, light_line], 
                bbox_to_anchor=(0.5, -0.3), loc='upper center', 
                fontsize=8, frameon=True, edgecolor='black', 
                ncol=2)  # `ncol=2` coloca las leyendas en dos columnas
    
    # Coordenadas para centrar el título dentro del rectángulo
    center_x = base / 2
    center_y = altura / 2

    # Agregar el texto centrado dentro del rectángulo
    ax.text(center_x, center_y, f"VG {int(base)} X {int(altura)}", 
            color='black', fontsize=8, ha='center', va='center')

    # Configuración de los límites y etiquetas del gráfico
    ax.set_xlim(-10, width + 10)
    ax.set_ylim(-10, height + 10)
    ax.set_aspect('equal')
    
    # Reducir tamaño de los ticks
    ax.tick_params(axis='both', which='major', labelsize=6)

    # Ajuste automático de los márgenes
    plt.tight_layout(pad=0.5)

# Función para actualizar el gráfico con los valores ingresados
def update_plot():
    try:
        # Obtener los valores de los entries y multiplicarlos por 100
        base = float(entry_base_seccion.get().strip()) * 100  # Multiplicamos por 100
        altura = float(entry_altura_seccion.get().strip()) * 100  # Multiplicamos por 100

        # Crear la figura y el eje con un tamaño que se ajustará al contenedor
        fig, ax = plt.subplots(figsize=(3, 3))  # Tamaño base para la figura
        draw_section(ax, base, altura)
        
        # Actualizar las etiquetas del eje x e y con el nuevo formato
        ax.set_xlabel(f"Base ({int(base)}cm)", fontsize=8)
        ax.set_ylabel(f"Altura ({int(altura)}cm)", fontsize=8)
        
        # Eliminar los elementos anteriores del canvas
        for widget in frame_ventana_falsa.winfo_children():
            widget.destroy()
        
        # Crear el canvas
        canvas = FigureCanvasTkAgg(fig, master=frame_ventana_falsa)
        canvas.draw()
        
        # Obtener el widget del canvas
        canvas_widget = canvas.get_tk_widget()
        
        # Crear la etiqueta de mensaje (label) que se animará, solo si no existe
        if not hasattr(update_plot, "label_mensaje_falsa"):  # Comprobamos si la etiqueta ya existe
            update_plot.label_mensaje_falsa = tk.Label(label_titulo_falsa, text="¡Muy bien! Ahora, continúa con las opciones de asignar.", bd=0,relief="flat")
            update_plot.label_mensaje_falsa.place(x=1, y=1, width=380, height=20)
            
            # Iniciar la animación de la etiqueta
            animate_label_movement(update_plot.label_mensaje_falsa)
        
        # Ajustar el canvas para que ocupe todo el espacio disponible en el contenedor
        canvas_widget.place(relwidth=1, relheight=1)  # Ocupa el 100% del espacio del frame

    except ValueError as e:
        print(f"Error: {e}")



# Función para animar el movimiento de la etiqueta de mensaje
def animate_label_movement(label):
    def move_label():
        # Obtener la posición actual del texto
        current_x = label.winfo_x()
        new_x = current_x + 2  # Desplazar 2 píxeles hacia la derecha
        
        # Si el texto se sale de la pantalla, reiniciarlo desde el borde izquierdo
        if new_x > label_titulo_falsa.winfo_width():
            new_x = -label.winfo_width()
        
        label.place(x=new_x, y=5)  # Actualizar la posición de la etiqueta
        label.after(50, move_label)  # Llamar a la función cada 50 ms para animar
    
    move_label()  # Llamar la función para iniciar la animación


# Función para abrir la ventana seccion transversal

def abrir_ventana_seccion_transversal():
    global ventana_secundaria_abierta
    global frame_ventana_seccion,frame_ventana_falsa,label_titulo_falsa,label_mensaje_falsa
    global entry_luz_seccion, entry_base_seccion, entry_altura_seccion, entry_recubrimiento_seccion, entry_d_seccion, entry_nombre_seccion
    global label_resumen_1, label_resumen_2, label_resumen_3, label_resumen_4, label_resumen_5, label_resumen_6,combo_resistencia
    if ventana_secundaria_abierta:
        return
    
    # Crear la ventana secundaria
    ventana_secundaria = tk.Toplevel()
    ventana_secundaria.title("Propiedades geométricas de la sección")
    
    # Evitar que la ventana sea maximizada o redimensionada
    ventana_secundaria.resizable(False, False)
    
    # Mantener la ventana siempre encima
    ventana_secundaria.attributes('-topmost', True)
    
    # Definir el tamaño de la ventana
    ventana_secundaria.geometry("500x530")
    
    # Crear contenido dentro de la ventana secundaria
    label_frame_seccion = tk.LabelFrame(ventana_secundaria, text="")
    label_frame_seccion.place(x=20,y=20,width=460,height=460)
    
    label_frame_caracteristicas = tk.LabelFrame(label_frame_seccion,text="Características adicionales")
    label_frame_caracteristicas.place(x=30,y=30,width=400,height=80)
    
    label_tipo_viga= tk.Label(label_frame_caracteristicas,text="Elemento tipo:")
    label_tipo_viga.place(x=30,y=15)
    entry_tipo_viga= tk.Entry(label_frame_caracteristicas)
    entry_tipo_viga.place(x=120,y=15 ,width=70)
    entry_tipo_viga.insert(0, "Viga")  
    label_seccion_viga= tk.Label(label_frame_caracteristicas,text="Sección:")
    label_seccion_viga.place(x=200,y=15)
    entry_seccion_viga = tk.Entry(label_frame_caracteristicas)
    entry_seccion_viga.place(x=260,y=15,width=70)
    entry_seccion_viga.insert(0,"Rectangular")
    frame_seccion_viga= tk.Frame(label_frame_seccion,bd=2,relief="ridge")
    frame_seccion_viga.place(x=30,y=120,width=400,height=300)
    
    # Crear un objeto Style para personalizar el estilo del Notebook
    style = ttk.Style()
    
    # Cambiar el fondo de las pestañas y del notebook
    style.configure("TNotebook", background="lightgrey", relief="flat")  
    style.configure("TNotebook.Tab", background="lightgrey", foreground="black")
    
    # Cambiar el color del área de contenido dentro de la pestaña
    style.map("TNotebook.Tab", background=[("selected", "lightgrey")])  # Color de la pestaña seleccionada
    
    # Crear un Notebook para las pestañas
    notebook = ttk.Notebook(frame_seccion_viga,style="TNotebook")
    notebook.pack(fill="both", expand=True)
    
    # Crear la pestaña "Sección transversal"
    pestaña_seccion = tk.Frame(notebook)
    notebook.add(pestaña_seccion, text="Sección transversal")
    
    # Crear la pestaña "Resumén"
    pestaña_resumen = tk.Frame(notebook)
    notebook.add(pestaña_resumen, text="Resumen")
    
    # Crear un Frame dentro de la pestaña "Sección transversal"
    frame_pest_seccion = tk.Frame(pestaña_seccion, bd=2, relief="flat",bg="white")
    frame_pest_seccion.pack(fill="both", expand=True)
    
    variable_seccion = tk.StringVar()
    
    labelframe_dimensiones= tk.LabelFrame(frame_pest_seccion,text="Dimensiones [m]",bg="white")
    labelframe_dimensiones.place(x=30,y=10,width=330,height=190)
    label_luz_seccion = tk.Label(labelframe_dimensiones,text="L:",bg="white")
    label_luz_seccion.place(x=10,y=10)
    label_base_seccion = tk.Label(labelframe_dimensiones,text="b:",bg="white")
    label_base_seccion.place(x=10,y=40)
    label_altura_seccion = tk.Label(labelframe_dimensiones,text="h:",bg="white")
    label_altura_seccion.place(x=10,y=70)
    label_recubrimiento_seccion = tk.Label(labelframe_dimensiones,text="r:",bg="white")
    label_recubrimiento_seccion.place(x=10,y=100)
    label_d_seccion = tk.Label(labelframe_dimensiones,text="d:",bg="white")
    label_d_seccion.place(x=10,y=130)
    label_nombre_seccion = tk.Label(frame_pest_seccion, text="Viga:",bg="white")
    label_nombre_seccion.place(x=30,y=220)
    entry_nombre_seccion = tk.Entry(frame_pest_seccion,bd=2, relief="ridge",textvariable=variable_seccion)
    entry_nombre_seccion.place(x=80,y=220,width=80)
    label_fc_seccion = tk.Label(frame_pest_seccion,text="f'c:",bg="white")
    label_fc_seccion.place(x=200,y=220)
    
    # Tarea interna de la función (esto puede ser cualquier acción que modifique el contenido del Entry)
    variable_seccion.set("Algunos datos")  # Ejemplo de cómo poner datos en el Entry
    
    # Ahora el Label fuera de la función puede acceder a la variable_seccion
    label_seccion_cargas.config(textvariable=variable_seccion)
    
    # Crear un ComboBox con los valores de resistencia a la compresión
    valores_resistencia = [
    "17.5 Mpa", "21 Mpa", "24.5 Mpa", "28 Mpa", "35 Mpa", "42 Mpa"
    ]
    combo_resistencia = ttk.Combobox(frame_pest_seccion, values=valores_resistencia, state="readonly")
    combo_resistencia.place(x=240,y=220,width=80)
    
    frame_pest_resumen = tk.Frame(pestaña_resumen,bd=2,relief="flat",bg="white")
    frame_pest_resumen.pack(fill="both",expand=True)
    
    labelframe_resumen = tk.LabelFrame(frame_pest_resumen,bg="white")
    labelframe_resumen.place(x=10,y=10,width=370,height=250)
    label_resumen = tk.Label(labelframe_resumen, 
                        text="A continuación se presenta un resumen de las configuraciones utilizadas para definir la sección transversal de la viga.",
                        justify="left", 
                        anchor="w",
                        wraplength=350,
                        bg="white")
    label_resumen.place(x=10,y=10)
    
    label_resumen_nombre = tk.Label(labelframe_resumen,text="Nombre [VG]:",bg="white")
    label_resumen_nombre.place(x=10,y=60) 
    label_resumen_1 = tk.Label(labelframe_resumen,text="",bg="white")
    label_resumen_1.place(x=90,y=60)
    
    label_resumen_luz = tk.Label(labelframe_resumen,text="Longitud [L]:",bg="white")
    label_resumen_luz.place(x=10,y=90)
    label_resumen_2 = tk.Label(labelframe_resumen,text="",bg="white")
    label_resumen_2.place(x=85,y=90)
    
    label_resumen_base = tk.Label(labelframe_resumen,text="Base [b]:",bg="white")
    label_resumen_base.place(x=10,y=120)
    label_resumen_3 = tk.Label(labelframe_resumen,text="",bg="white")
    label_resumen_3.place(x=65,y=120)
    
    label_resumen_altura = tk.Label(labelframe_resumen,text="Altura [h]:",bg="white")
    label_resumen_altura.place(x=10,y=150)
    label_resumen_4 = tk.Label(labelframe_resumen,text="",bg="white")
    label_resumen_4.place(x=70,y=150)
    
    
    label_resumen_recubrimiento = tk.Label(labelframe_resumen,text="Recubrimiento [r]:",bg="white")
    label_resumen_recubrimiento.place(x=10,y=180)
    label_resumen_5 = tk.Label(labelframe_resumen,text="",bg="white")
    label_resumen_5.place(x=115,y=180)
    
    
    label_resumen_d = tk.Label(labelframe_resumen,text="Altura efectiva [d]:",bg="white")
    label_resumen_d.place(x=10,y=210)
    label_resumen_6 = tk.Label(labelframe_resumen,text="",bg="white")
    label_resumen_6.place(x=115,y=210)
    
    
    def actualizar_label(*args):
    # Obtener el valor del Entry
        valor_1 = entry_luz_seccion.get()
    # Actualizar el Label con el texto fijo + el valor ingresado
        label_resumen_2.config(text=f"La viga presenta una luz de {valor_1} metros.")
        
    
    def actualizar_label_base(*args):
    # Obtener el valor del Entry y actualizar el Label
        valor_2 = entry_base_seccion.get() 
        label_resumen_3.config(text=f"La viga presenta una base de {valor_2} metros.")
    
        
        
    # Función para actualizar d_seccion en tiempo real
    def actualizar_d_seccion(*args):
        try:
            altura = float(var_altura.get())  
        except ValueError:
            altura = 0  
        
        try:
            recubrimiento = float(var_recubrimiento.get())  
        except ValueError:
            recubrimiento = 0  
        
        # Realizar la resta
        d_seccion = altura - recubrimiento
        
        # Mostrar el resultado en el campo entry_d_seccion
        entry_d_seccion.delete(0, tk.END)  
        entry_d_seccion.insert(0, str(d_seccion))  
        
        # Actualizar el texto del label_resumen_5 con el valor de d_seccion
        label_resumen_5.config(text=f"El recubrimiento a emplear será de {recubrimiento * 100:.1f} cm")  
        # Actualizar el texto del label_resumen_6 con el valor de d_seccion desde entry_d_seccion
        label_resumen_6.config(text=f"La altura efectiva a utilizar es de {d_seccion:.2f} metros") 
        
    
    def actualizar_nombre_seccion(*args):
    # Recuperamos los valores de los Entry
        base_nombre = entry_base_seccion.get()
        altura_nombre = entry_altura_seccion.get()
    
        try:
    # Convertimos los valores a números flotantes y los multiplicamos por 100
            base_nombre = round(float(base_nombre) * 100, 2)  
            altura_nombre = round(float(altura_nombre) * 100, 2)  
        
    # Formateamos la cadena con los valores modificados
            nombre_seccion = f"VG {base_nombre} X {altura_nombre}"
        
    # Actualizamos el campo entry_nombre_seccion
            entry_nombre_seccion.delete(0, tk.END)  
            entry_nombre_seccion.insert(0, nombre_seccion)  
            
            # Actualizamos el texto del label_resumen_1
            label_resumen_1.config(text=f"Elemento viga,sección - {nombre_seccion}")
            # Actualizamos el texto del label_resumen_4 con la altura
            altura_metros = round(altura_nombre * 0.01, 2)  
            label_resumen_4.config(text=f"La viga presenta una altura de {altura_metros} metros") 
            
        except ValueError:
    # Si los valores no son numéricos, no hacemos nada
            pass
    
    # Función para dibujar el rectángulo en el canvas
    def dibujar_rectangulo():
        try:
            base = float(var_base.get())  
            altura = float(var_altura.get())  
        except ValueError:
            base = 0
            altura = 0
        
        # Definir un factor de escala para que los valores en metros se ajusten al canvas
        factor_escala_base = 120  
        factor_escala_altura = 142  
        
        # Escalar las dimensiones del rectángulo en píxeles
        base_pixel = base * factor_escala_base  
        altura_pixel = altura * factor_escala_altura  
        
        # Limpiar el canvas antes de dibujar
        canvas_seccion.delete("all")
        
        # Calcular el margen para centrar el rectángulo
        canvas_width = 120  # Ancho del Canvas
        canvas_height = 142  # Altura del Canvas
        x_offset = (canvas_width - base_pixel) / 2 - 5  
        y_offset = (canvas_height - altura_pixel) / 2  
        
        # Dibujar el rectángulo en el canvas
        canvas_seccion.create_rectangle(
            x_offset, y_offset, x_offset + base_pixel, y_offset + altura_pixel,
            outline="black", fill="medium blue", width=1
        )
        # Calcular el valor escalado de base y altura (multiplicados por 100)
        base_multiplicada = base * 100
        altura_multiplicada = altura * 100
        
        # Agregar el título centrado arriba del rectángulo
        texto_titulo = f"VG {base_multiplicada:.0f} X {altura_multiplicada:.0f}"  
        canvas_seccion.create_text(
        (canvas_width / 2)-6, y_offset - 20,  
        text=texto_titulo,  
        font=("Arial", 8, "bold"),  
        fill="black" 
        )   
        # Agregar las cotas a la base (en la parte inferior central del rectángulo)
        canvas_seccion.create_text(
        x_offset + base_pixel / 2, y_offset + altura_pixel + 10,  
        text=f"{base:.2f} m",  
        font=("Arial", 8,"bold"),  
        fill="black"  
        )
        
        # Agregar las cotas a la altura (en la parte izquierda central del rectángulo)
        canvas_seccion.create_text(
        x_offset -8, y_offset + altura_pixel / 2,  
        text=f"{altura:.2f} m", 
        font=("Arial", 8,"bold"),  
        fill="black",  
        angle=90  
        )
    
    
    # Crear los StringVar para monitorizar cambios en los Entry
    var_base = tk.StringVar()
    var_altura = tk.StringVar()
    var_recubrimiento = tk.StringVar()
    
    
    entry_luz_seccion = tk.Entry(labelframe_dimensiones,bd=2, relief="ridge")
    entry_luz_seccion.place(x=50,y=10,width=50)
    entry_base_seccion = tk.Entry(labelframe_dimensiones,bd=2, relief="ridge")
    entry_base_seccion.place(x=50,y=40,width=50)
    entry_base_seccion.config(textvariable=var_base)
    entry_altura_seccion = tk.Entry(labelframe_dimensiones,bd=2, relief="ridge")
    entry_altura_seccion.place(x=50,y=70,width=50)
    entry_altura_seccion.config(textvariable=var_altura)
    entry_recubrimiento_seccion = tk.Entry(labelframe_dimensiones,bd=2, relief="ridge")
    entry_recubrimiento_seccion.place(x=50,y=100,width=50)
    entry_recubrimiento_seccion.config(textvariable=var_recubrimiento)
    entry_d_seccion = tk.Entry(labelframe_dimensiones,bd=2,relief="ridge")
    entry_d_seccion.place(x=50,y=130,width=50)
    frame_dibujo_seccion = tk.Frame(labelframe_dimensiones,bd=4,relief="ridge")
    frame_dibujo_seccion.place(x=170,y=10,width=120,height=142)
    # Crear el Canvas dentro del frame_dibujo_seccion
    canvas_seccion = tk.Canvas(frame_dibujo_seccion, bg="lightgrey", width=120, height=142)
    canvas_seccion.pack(fill="both", expand=True)
    
    #Crear el boton aceptar para guardar datos
    boton_aceptar_seccion= ttk.Button(ventana_secundaria,text="Aceptar",command=guardar_datos_seccion)
    boton_aceptar_seccion.place(x=100,y=490,width=100)
    
    # Cargar los datos guardados al abrir la ventana
    cargar_datos_seccion()
    
    
    #Crar el boton aplicar para mostrar grafico dinamico
    boton_aplicar_seccion= ttk.Button(ventana_secundaria,text="Aplicar",command=update_plot)
    boton_aplicar_seccion.place(x=280,y=490,width=100)
    
    
    # Agregar el trace a las variables para actualizar en tiempo real
    var_base.trace("w", lambda *args: dibujar_rectangulo())
    var_altura.trace("w", lambda *args: dibujar_rectangulo())
    
    
    # Agregar el trace a las variables para actualizar en tiempo real
    var_altura.trace("w", actualizar_d_seccion)
    var_recubrimiento.trace("w", actualizar_d_seccion)
    
    # Asociar el cambio de valor de los Entry a la función de actualización
    entry_base_seccion.bind("<KeyRelease>", actualizar_nombre_seccion)
    entry_altura_seccion.bind("<KeyRelease>", actualizar_nombre_seccion)
    
    # Configurar un evento que se active cada vez que el valor del Entry cambie
    entry_luz_seccion.bind("<KeyRelease>", actualizar_label)  
    
    # Configurar un evento que se active cada vez que el valor del Entry cambie
    entry_base_seccion.bind("<KeyRelease>", actualizar_label_base)
    
    # Marcar la ventana como abierta
    ventana_secundaria_abierta = True
    
    
    # Configurar para que cuando se cierre la ventana, se pueda volver a abrir
    ventana_secundaria.protocol("WM_DELETE_WINDOW", lambda: cerrar_ventana(ventana_secundaria))
    
    def cerrar_ventana(ventana_secundaria):
        global ventana_secundaria_abierta
        ventana_secundaria.destroy()
        ventana_secundaria_abierta = False

# Variables globales
ventana_apoyos_abierta = False
ventana_apoyos = None
labelframe_apoyos = None  
combo_tipo_apoyo = None  
label_restriccion_apoyo = None  

# Función para cerrar la ventana de apoyos y actualizar la variable
def cerrar_ventana_apoyos():
    global ventana_apoyos_abierta, ventana_apoyos
    ventana_apoyos_abierta = False
    if ventana_apoyos:
        ventana_apoyos.destroy()  
        ventana_apoyos = None  

# Función para actualizar los RadioButtons en función del tipo de apoyo seleccionado
def actualizar_radio_buttons(event):
    global labelframe_apoyos, combo_tipo_apoyo  # Acceder a las variables globales
    
    # Limpiar los RadioButtons previos
    for widget in labelframe_apoyos.winfo_children():
        widget.destroy()
    
    tipo_apoyo = combo_tipo_apoyo.get()  # Obtener el valor seleccionado en el ComboBox
    
    # Actualizar el texto del label con el tipo de apoyo seleccionado
    label_restriccion_apoyo.config(text=f"{tipo_apoyo}")
    
    if tipo_apoyo == "Apoyo móvil":
        # Mostrar los RadioButtons para el apoyo móvil
        radio_desplazamiento_y = tk.Radiobutton(labelframe_apoyos, text="No permite desplazamiento vertical")
        radio_desplazamiento_y.grid(row=0, column=0, sticky="w", padx=10, pady=5)
        
        radio_rotacion = tk.Radiobutton(labelframe_apoyos, text="No permite rotación")
        radio_rotacion.grid(row=1, column=0, sticky="w", padx=10, pady=5)
        
        radio_resistencia_y = tk.Radiobutton(labelframe_apoyos, text="Sí permite movimiento horizontal")
        radio_resistencia_y.grid(row=2, column=0, sticky="w", padx=10, pady=5)
    
    elif tipo_apoyo == "Apoyo empotrado":
        # Mostrar los RadioButtons para el apoyo empotrado
        radio_no_desplazamiento = tk.Radiobutton(labelframe_apoyos, text="No permite desplazamiento en ninguna dirección")
        radio_no_desplazamiento.grid(row=0, column=0, sticky="w", padx=10, pady=5)
        
        radio_resistencia_vertical = tk.Radiobutton(labelframe_apoyos, text="Resistencia a fuerzas verticales")
        radio_resistencia_vertical.grid(row=1, column=0, sticky="w", padx=10, pady=5)
        
        radio_resistencia_horizontal = tk.Radiobutton(labelframe_apoyos, text="Resistencia a fuerzas horizontales")
        radio_resistencia_horizontal.grid(row=2, column=0, sticky="w", padx=10, pady=5)
        
        radio_resistencia_momentos = tk.Radiobutton(labelframe_apoyos, text="Resistencia a momentos")
        radio_resistencia_momentos.grid(row=3, column=0, sticky="w", padx=10, pady=5)


# Función para abrir la ventana de apoyos
def abrir_ventana_apoyos():
    global ventana_apoyos_abierta, ventana_apoyos, labelframe_apoyos, combo_tipo_apoyo,label_restriccion_apoyo
    
    # Si la ventana ya está abierta, no hacemos nada
    if ventana_apoyos_abierta:
        return
    
    # Crear la ventana secundaria
    ventana_apoyos = tk.Toplevel()
    ventana_apoyos.title("Definir apoyos")
    
    # Evitar que la ventana sea maximizada o redimensionada
    ventana_apoyos.resizable(False, False)
    
    # Mantener la ventana siempre encima
    ventana_apoyos.attributes('-topmost', True)
    
    # Definir el tamaño de la ventana
    ventana_apoyos.geometry("500x255")
    
    # Actualizar el estado de la ventana
    ventana_apoyos_abierta = True
    
    # Crear contenido en la venta_apoyos
    label_tipo_apoyo =tk.Label(ventana_apoyos,text="Tipo de apoyo:")
    label_tipo_apoyo.place(x=80,y=20)
    labelframe_apoyos = tk.LabelFrame(ventana_apoyos,text="Restricciones de apoyo")
    labelframe_apoyos.place(x=20,y=50,width=465,height=160)
    
    
    #Crear combobox para tipo de apoyo
    # Lista de opciones para el ComboBox
    tipos_de_apoyo = ["Apoyo móvil", "Apoyo empotrado"]
    combo_tipo_apoyo = ttk.Combobox(ventana_apoyos, values=tipos_de_apoyo, state="readonly")
    combo_tipo_apoyo.place(x=200,y=20)
    combo_tipo_apoyo.set("Seleccionar")
    
    # Asignar el manejador de cambio de selección en el ComboBox
    combo_tipo_apoyo.bind("<<ComboboxSelected>>", actualizar_radio_buttons)
    
    # Agregar botón "Aceptar" que cierra la ventana
    boton_aceptar_apoyo = ttk.Button(ventana_apoyos, text="Aceptar", command=cerrar_ventana_apoyos)
    boton_aceptar_apoyo.place(x=200, y=220, width=100)  
    
    # Asignar el manejador de cierre de la ventana
    ventana_apoyos.protocol("WM_DELETE_WINDOW", cerrar_ventana_apoyos)


label_restriccion_apoyo = None
entry_base_cargas = None
entry_altura_cargas = None
ventana_cargas_abierta = None
combo_seccion_analisis = None
entry_Wpp_cargas = None


def calcular_Wpp(*args):
    try:
        # Obteniendo los valores de las entradas y convirtiéndolos a flotantes
        base_wpp = float(entry_base_cargas.get())
        altura_wpp = float(entry_altura_cargas.get())
        
        # Calculando Wpp
        Wpp_1 = base_wpp * altura_wpp * 24.00
        
        # Mostrando el resultado en el entry_Wpp_cargas
        entry_Wpp_cargas.delete(0, tk.END)
        entry_Wpp_cargas.insert(0, f"{Wpp_1:.2f}")  
        # Actualizar el label con el mismo valor calculado
        label_cargas_Wpp.config(text=f"{Wpp_1:.2f} kN/m") 
    except ValueError:
        
        entry_Wpp_cargas.delete(0, tk.END)
        label_cargas_Wpp.config(text="Error en los valores")

def calcular_Wtotal(*args):
    try:
        # Obtener los valores de los Entry
        WD = float(entry_WD_cargas.get() or 0)  # Si está vacío, se toma como 0
        WL = float(entry_WL_cargas.get() or 0)  # Si está vacío, se toma como 0
        Wpp = float(entry_Wpp_cargas.get() or 0)  # Este ya es calculado internamente
        
        # Calcular Wtotal
        Wtotal = WD + WL + Wpp
        
        # Mostrar el resultado en el entry_Wtotal_cargas
        entry_Wtotal_cargas.delete(0, tk.END)
        entry_Wtotal_cargas.insert(0, f"{Wtotal:.2f}")  # Formato con dos decimales
        
        # Actualizar el label de cada valor (WD, WL, Wtotal)
        label_cargas_WD.config(text=f"{WD:.2f} kN/m")  
        label_cargas_WL.config(text=f"{WL:.2f} kN/m")  
        label_cargas_Wtotal.config(text=f"{Wtotal:.2f} kN/m")  
        
        # Calcular Wu después de Wtotal
        calcular_Wu()
    except ValueError:
        # Si hay un error en la conversión, limpiar el entry_Wtotal_cargas
        entry_Wtotal_cargas.delete(0, tk.END)
        label_cargas_WD.config(text="Error en los valores")  
        label_cargas_WL.config(text="Error en los valores")  
        label_cargas_Wtotal.config(text="Error en los valores") 

# Dentro de la función calcular_Wu, asegúrate de que Wu_var se actualice correctamente
def calcular_Wu(*args):
    try:
        # Obtener los valores de los Entry
        WD = float(entry_WD_cargas.get() or 0)  # Si está vacío, se toma como 0
        WL = float(entry_WL_cargas.get() or 0)  # Si está vacío, se toma como 0
        Wpp = float(entry_Wpp_cargas.get() or 0)  # Este ya es calculado internamente

        # Calcular Wu
        Wu_carga = 1.2 * (WD + Wpp) + 1.6 * WL

        # Mostrar el resultado en el entry_Wu_cargas
        entry_Wu_cargas.delete(0, tk.END)
        entry_Wu_cargas.insert(0, f"{Wu_carga:.2f}")  # Formato con dos decimales
        
        # Actualizar Wu_var con el nuevo valor calculado
        Wu_var.set(f"{Wu_carga:.2f}")  # Esto actualiza la variable vinculada

    except ValueError:
        # Si hay un error en la conversión, limpiar el entry_Wu_cargas
        entry_Wu_cargas.delete(0, tk.END)
        Wu_var.set("0")  # Opcional: Resetear Wu_var si hay un error

def actualizar_entries(event):
    # Obtener la opción seleccionada en el ComboBox
    seleccion_1 = combo_seccion_analisis.get()
    
    try:
        # Separar la cadena seleccionada
        partes = seleccion_1.replace("VG", "").replace("X", "").split()
        
        # Convertir los valores a flotantes y dividir entre 100
        base_valor = float(partes[0]) / 100
        altura_valor = float(partes[1]) / 100

        # Actualizar los valores en los Entry
        entry_base_cargas.delete(0, tk.END)
        entry_base_cargas.insert(0, f"{base_valor:.2f}") 
        
        entry_altura_cargas.delete(0, tk.END)
        entry_altura_cargas.insert(0, f"{altura_valor:.2f}")  
        
        # Recalcular Wpp
        calcular_Wpp()
    except (ValueError, IndexError):
        print("Error: El formato de la opción seleccionada no es correcto.")


def actualizar_combo_seccion(combo_seccion_analisis):
    # Obtener el valor de label_seccion_cargas
    valor_seccion = label_seccion_cargas.cget("text")
    
    # Si el valor no está vacío, actualizar el ComboBox con ese valor
    if valor_seccion:
        combo_seccion_analisis['values'] = ("Seleccionar", valor_seccion)
    else:
        # Si el valor está vacío, solo mostrar la opción "Seleccionar"
        combo_seccion_analisis['values'] = ("Seleccionar",)

def dibujar_viga_apoyada_1(canvas_viga_analisis,valor_carga,valor_Wu):
    # Obtener el tamaño del canvas
    ancho_canvas = canvas_viga_analisis.winfo_width()
    alto_canvas = canvas_viga_analisis.winfo_height()

    # Calcular la posición central para la viga
    x_inicio = ancho_canvas // 4
    x_fin = 3 * ancho_canvas // 4
    y_viga = alto_canvas // 2

    # Dibujar la viga (línea horizontal) centrada en el canvas
    canvas_viga_analisis.create_line(x_inicio, y_viga, x_fin, y_viga, width=3, fill="black")
    
    # Dibujar los triángulos debajo de la línea, con la punta hacia abajo
    # Triángulo izquierdo
    canvas_viga_analisis.create_polygon(x_inicio, y_viga, x_inicio - 10, y_viga + 20, x_inicio + 10, y_viga + 20, fill="blue", outline="black")
    
    # Triángulo derecho
    canvas_viga_analisis.create_polygon(x_fin, y_viga, x_fin - 10, y_viga + 20, x_fin + 10, y_viga + 20, fill="blue", outline="black")
    
    # Obtener el valor de carga desde el Entry
    valor_carga_texto = valor_carga if valor_carga else "0"
    
    # Dibujar la cota (dimensión de la viga) con flechas en ambos extremos
    canvas_viga_analisis.create_line(x_inicio, y_viga + 30, x_fin, y_viga + 30, width=1, fill="red")  # Línea de la cota (más fina)
    canvas_viga_analisis.create_text((x_inicio + x_fin) / 2, y_viga + 40, text=f"Longitud: {valor_carga_texto} m ", font=("Arial", 10, "bold"), fill="red")  # Longitud de la viga
    
    
    # Dibujar las flechas en ambos extremos de la línea de cota (más pequeñas)
    canvas_viga_analisis.create_polygon(x_inicio - 3, y_viga + 30, x_inicio + 3, y_viga + 25, x_inicio + 3, y_viga + 35, fill="red", outline="red")
    canvas_viga_analisis.create_polygon(x_fin + 3, y_viga + 30, x_fin - 3, y_viga + 25, x_fin - 3, y_viga + 35, fill="red", outline="red")

    # Dibujar la línea verde horizontal justo encima de las líneas de carga distribuida
    canvas_viga_analisis.create_line(x_inicio, y_viga - 20, x_fin, y_viga - 20, width=2, fill="green")  # Línea verde horizontal
    
    # Dibujar la carga distribuida a lo largo de la viga (líneas cortas con flechas hacia abajo)
    num_lineas = 20  # Número de segmentos para la carga distribuida
    carga_espaciado = (x_fin - x_inicio) / (num_lineas - 1)  # Espaciado entre las líneas de carga

    for i in range(num_lineas):
        x_pos = x_inicio + i * carga_espaciado
        # Dibujar línea de carga distribuida
        canvas_viga_analisis.create_line(x_pos, y_viga - 10, x_pos, y_viga - 20, width=2, fill="green")  # Línea de carga distribuida
        
        # Dibujar la flecha apuntando hacia abajo (ubicada justo debajo de la línea verde)
        canvas_viga_analisis.create_polygon(x_pos - 3, y_viga - 10, x_pos + 3, y_viga - 10, x_pos, y_viga, fill="green", outline="green")
    
    # Eliminar el texto anterior (si existe) para actualizar la carga distribuida
    canvas_viga_analisis.delete("carga_Wu_texto")  # Borrar el texto viejo
    
    # Agregar texto a la carga distribuida
    canvas_viga_analisis.create_text((x_inicio + x_fin) / 2, y_viga - 40, text=f"Carga Wu: {valor_Wu} kN/m", font=("Arial", 10, "bold"), fill="green")


def dibujar_viga_empotrada_1(canvas_viga_analisis,valor_carga,valor_Wu):
    # Obtener el tamaño del canvas
    ancho_canvas = canvas_viga_analisis.winfo_width()
    alto_canvas = canvas_viga_analisis.winfo_height()

    # Calcular la posición central para la viga
    x_inicio = ancho_canvas // 4
    x_fin = 3 * ancho_canvas // 4
    y_viga = alto_canvas // 2

    # Dibujar la viga (línea horizontal) centrada en el canvas
    canvas_viga_analisis.create_line(x_inicio, y_viga, x_fin, y_viga, width=3, fill="black")
    
    # Dibujar las líneas verticales en los extremos (empotradas)
    canvas_viga_analisis.create_line(x_inicio, y_viga - 20, x_inicio, y_viga + 20, width=3, fill="blue")
    canvas_viga_analisis.create_line(x_fin, y_viga - 20, x_fin, y_viga + 20, width=3, fill="blue")
    
    # Obtener el valor de carga desde el Entry
    valor_carga_texto = valor_carga if valor_carga else "0"
    
    # Dibujar la cota (dimensión de la viga) con flechas en ambos extremos
    canvas_viga_analisis.create_line(x_inicio, y_viga + 30, x_fin, y_viga + 30, width=1, fill="red")  # Línea de la cota (más fina)
    canvas_viga_analisis.create_text((x_inicio + x_fin) / 2, y_viga + 40, text=f"Longitud: {valor_carga_texto} m ", font=("Arial", 10, "bold"), fill="red")  # Longitud de la viga
    
    # Dibujar las flechas en ambos extremos de la línea de cota (más pequeñas)
    canvas_viga_analisis.create_polygon(x_inicio - 3, y_viga + 30, x_inicio + 3, y_viga + 25, x_inicio + 3, y_viga + 35, fill="red", outline="red")
    canvas_viga_analisis.create_polygon(x_fin + 3, y_viga + 30, x_fin - 3, y_viga + 25, x_fin - 3, y_viga + 35, fill="red", outline="red")

    # Dibujar la carga distribuida a lo largo de la viga (líneas cortas con flechas hacia abajo)
    num_lineas = 20  # Número de segmentos para la carga distribuida
    carga_espaciado = (x_fin - x_inicio) / (num_lineas - 1)  # Espaciado entre las líneas de carga

    for i in range(1, num_lineas - 1):  # Excluir la primera y la última línea
        x_pos = x_inicio + i * carga_espaciado
        # Dibujar línea de carga distribuida
        canvas_viga_analisis.create_line(x_pos, y_viga - 10, x_pos, y_viga - 20, width=2, fill="green")  # Línea de carga distribuida
        
        # Dibujar la flecha apuntando hacia abajo (ubicada justo debajo de la línea verde)
        canvas_viga_analisis.create_polygon(x_pos - 3, y_viga - 10, x_pos + 3, y_viga - 10, x_pos, y_viga, fill="green", outline="green")

    # Dibujar la línea verde horizontal justo encima de las líneas de carga distribuida
    canvas_viga_analisis.create_line(x_inicio + carga_espaciado, y_viga - 20, x_fin - carga_espaciado, y_viga - 20, width=2, fill="green")
    
    # Eliminar el texto anterior (si existe) para actualizar la carga distribuida
    canvas_viga_analisis.delete("carga_Wu_texto")  # Borrar el texto viejo
    
    # Agregar texto a la carga distribuida
    canvas_viga_analisis.create_text((x_inicio + x_fin) / 2, y_viga - 40, text=f"Carga Wu: {valor_Wu} kN/m", font=("Arial", 10, "bold"), fill="green")


def actualizar_diagrama_viga(event, combo_viga_cargas, canvas_viga_analisis, entry_luz_cargas, Wu_var, label_tipo_viga_cargas):
    if not canvas_viga_analisis.winfo_exists():
        print("El Canvas no existe.")
        return
    # Obtener el valor ingresado en el Entry
    valor_carga = entry_luz_cargas.get()
    
    # Obtener el valor calculado de la carga distribuida desde Wu_var (la variable vinculada al entry)
    valor_Wu = Wu_var.get()  # Este es el valor calculado de Wu
    
    # Verificar la opción seleccionada en el ComboBox
    seleccion_1 = combo_viga_cargas.get()
    
    # Actualizar el texto del label con el tipo de viga seleccionado
    label_tipo_viga_cargas.config(text=seleccion_1)  
    
    # Limpiar el canvas antes de dibujar un nuevo diagrama
    canvas_viga_analisis.delete("all")
    
    if seleccion_1 == "Viga apoyada":
        dibujar_viga_apoyada_1(canvas_viga_analisis, valor_carga,valor_Wu)
    elif seleccion_1 == "Viga empotrada":
        dibujar_viga_empotrada_1(canvas_viga_analisis, valor_carga,valor_Wu)

# Inicializar Wu_var globalmente para que no se cree nuevamente al abrir la ventana
Wu_var = tk.StringVar()



def aplicar_cargas():
    global label_tipo_viga_cargas, entry_Wu_cargas, entry_luz_cargas, entry_WD_cargas, entry_WL_cargas, label_titulo_viga, label_titulo_cargas, combo_seccion_analisis
    global label_texto_cargas,label_reaccion
    # Verificar que los elementos existan antes de usarlos
    if label_tipo_viga_cargas is None or entry_Wu_cargas is None or entry_luz_cargas is None or entry_WD_cargas is None or entry_WL_cargas is None:
        return

    # Obtener el tipo de viga desde el label
    tipo_viga = label_tipo_viga_cargas.cget("text")  # Obtener el texto del label
    if not tipo_viga:  # Si el texto está vacío, no hacer nada
        return
    
    # Obtener la sección seleccionada del combobox
    seccion_viga = combo_seccion_analisis.get()
    if not seccion_viga:  # Si no se selecciona una sección, no hacer nada
        return
    
    def animar_texto():
        
    # Obtiene el texto actual
        texto = label_texto_cargas.cget("text")

    # Obtiene el tamaño de la ventana y la posición actual del texto
        x_actual = label_texto_cargas.winfo_x()

    # Definir el límite del movimiento (puedes cambiar estos valores)
        limite_derecha = 380  
        limite_izquierda = -len(texto) * 7  
    
    # Mover el texto
        if x_actual < limite_derecha:
            label_texto_cargas.place(x=x_actual + 1, y=3)
            label_texto_cargas.after(50, animar_texto) 
        else:
    # Si llega al final, vuelve a la posición inicial
            label_texto_cargas.place(x=limite_izquierda, y=3)
            label_texto_cargas.after(50, animar_texto)
    
    # Iniciar la animación
    animar_texto()
    
    try:
        # Longitud de la viga en unidades
        longitud = 6 * 100  # Longitud fija de 6 metros (600 unidades)

        # Obtener Wu como flotante
        try:
            carga_distribuida = float(entry_Wu_cargas.get())
        except ValueError:
            carga_distribuida = 0  # Si no es válido, usar 0 como carga

        # Obtener el valor de la luz de la viga desde entry_luz_cargas
        try:
            luz_viga = float(entry_luz_cargas.get())
        except ValueError:
            luz_viga = 0  # Si no es válido, usar 0 como valor de luz
        
        # Obtener los valores de WD y WL
        try:
            WD = float(entry_WD_cargas.get())
        except ValueError:
            WD = 0  # Si no es válido, usar 0 como valor de WD
        
        try:
            WL = float(entry_WL_cargas.get())
        except ValueError:
            WL = 0  # Si no es válido, usar 0 como valor de WL
        
        
        # Inicializar momento_A y momento_B como 0 por defecto
        momento_A = 0
        momento_B = 0


        # Calcular las reacciones
        if tipo_viga == "Viga apoyada":
            # Reacciones en los apoyos para viga apoyada
            reaccion_apoyo = carga_distribuida * luz_viga / 2  # R = (Wu * L) / 2
            texto_reacciones = [f"Ray = {reaccion_apoyo:.2f} kN", f"Rby = {reaccion_apoyo:.2f} kN"]
            # Actualizar el label de reacciones con el valor de reaccion_apoyo
            label_reaccion.config(text=f"{reaccion_apoyo:.2f} kN")
            # Actualizar el título de la viga
            label_titulo_viga.config(text="Análisis de Viga apoyada")
        elif tipo_viga == "Viga empotrada":
            # Reacciones en los apoyos para viga empotrada
            reaccion_apoyo = carga_distribuida * luz_viga / 2  # Similar a viga apoyada para este ejemplo
            texto_reacciones = [f"Ray = {reaccion_apoyo:.2f} kN", f"Rby = {reaccion_apoyo:.2f} kN"]
            # Reacciones de momentos en los apoyos para viga empotrada
            momento_A = carga_distribuida * luz_viga**2 / 12  # MA = Wu * L^2 / 12
            momento_B = -carga_distribuida * luz_viga**2 / 12  # MB = -Wu * L^2 / 12
            texto_reacciones = [f"Ray = {reaccion_apoyo:.2f} kN", f"Rby = {reaccion_apoyo:.2f} kN"]
            texto_momentos = [f"MA = {momento_A:.2f} kN·m", f"MB = {momento_B:.2f} kN·m"]
            # Actualizar el label de reacciones con el valor de reaccion_apoyo
            label_reaccion.config(text=f"{reaccion_apoyo:.2f} kN")
            # Actualizar el título de la viga      
            label_titulo_viga.config(text="Análisis de Viga empotrada")
        else:
            texto_reacciones = ["Reacciones no calculadas"]
        
        # Aquí es donde actualizamos el texto de `label_texto_cargas`
        mensaje_analisis = f"!Muy bien! El análisis de la viga con sección {seccion_viga} es correcto."
        label_texto_cargas.config(text=mensaje_analisis)  # Actualizar el texto del label_texto_cargas

        # Crear figura y eje para el dibujo
        fig = Figure(figsize=(6, 4), dpi=100)
        ax = fig.add_subplot(111)

        # Configuración general
        desplazamiento_x = 10
        eje_y_central = 0
        altura_triangulo = 40
        altura_carga = 60

        # Dibujar la viga
        ax.plot([desplazamiento_x, longitud + desplazamiento_x],
                [eje_y_central, eje_y_central],
                color='black', linewidth=3, label="Viga")

        # Dibujar apoyos según el tipo de viga
        if tipo_viga == "Viga apoyada":
            # Apoyo inicial (rellenar triángulo con color azul y borde negro)
            ax.fill([desplazamiento_x - 20, desplazamiento_x, desplazamiento_x + 20],
                    [eje_y_central - altura_triangulo, eje_y_central, eje_y_central - altura_triangulo],
                    color='blue', edgecolor='black', linewidth=2)  # Contorno negro

            # Apoyo final (rellenar triángulo con color azul y borde negro)
            ax.fill([longitud + desplazamiento_x - 20, longitud + desplazamiento_x, longitud + desplazamiento_x + 20],
                    [eje_y_central - altura_triangulo, eje_y_central, eje_y_central - altura_triangulo],
                    color='blue', edgecolor='black', linewidth=2)  # Contorno negro

        if tipo_viga == "Viga empotrada":
            # Empotramiento inicial (línea vertical)
            ax.plot([desplazamiento_x, desplazamiento_x],
                    [eje_y_central - 50, eje_y_central + 50],
                    color='black', linewidth=3)
            # Empotramiento final (línea vertical)
            ax.plot([longitud + desplazamiento_x, longitud + desplazamiento_x],
                    [eje_y_central - 50, eje_y_central + 50],
                    color='black', linewidth=3)

        # Dibujar la carga distribuida si Wu > 0
        if carga_distribuida > 0:
            x_inicio = desplazamiento_x
            x_fin = longitud + desplazamiento_x
            num_flechas = 10
            espacio_flechas = (x_fin - x_inicio) / num_flechas

            # Dibujar fondo de la carga
            ax.fill_between([x_inicio, x_fin],
                            eje_y_central + altura_carga + 5,
                            eje_y_central,
                            color='lime', alpha=0.5)

            # Dibujar flechas de la carga
            for i in range(num_flechas + 1):
                x_pos = x_inicio + i * espacio_flechas
                ax.arrow(x_pos, eje_y_central + altura_carga, 0, -40,
                         head_width=10, head_length=15, fc='blue', ec='blue')

            # Dibujar línea superior de la carga
            ax.plot([x_inicio, x_fin],
                    [eje_y_central + altura_carga, eje_y_central + altura_carga],
                    color='blue', linewidth=2, label=f"Wu={carga_distribuida}")
            
            # Agregar el texto de la carga distribuida en el gráfico
            texto_carga = f"Wu = {carga_distribuida} kN/m"
            ax.text(longitud / 2 + desplazamiento_x, eje_y_central + altura_carga + 30,
                    texto_carga, ha='center', va='center', fontsize=8, color='blue')

        # Mostrar el texto de la cota debajo de la viga
        texto_cota = f"Luz = {luz_viga} m"
        ax.text(longitud / 2 + desplazamiento_x, eje_y_central - 40,
                texto_cota, ha='center', va='center', fontsize=8, color='black')
        
        # Crear marcadores personalizados para la leyenda
        handles_reacciones = [
            Line2D([0], [0], linestyle='None', color='none', label="Reacciones:"),  # Subtítulo como línea vacía
            Line2D([0], [0], marker='^', color='black', markerfacecolor='blue', linestyle='None', markersize=8),
            Line2D([0], [0], marker='^', color='black', markerfacecolor='blue', linestyle='None', markersize=8)
        ]
        handles_reacciones_M = [
            Line2D([0], [0], linestyle='None', color='none', label="Reacciones:"),  # Subtítulo como línea vacía
            Line2D([0], [0], marker='^', color='black', markerfacecolor='black', linestyle='None', markersize=8),
            Line2D([0], [0], marker='^', color='black', markerfacecolor='black', linestyle='None', markersize=8)
        ]
        handles_momentos = [
            Line2D([0], [0], linestyle='None', color='none', label="Momentos:"),  # Subtítulo como línea vacía
            Line2D([0], [0], marker='o', color='black', markerfacecolor='red', linestyle='None', markersize=8),
            Line2D([0], [0], marker='o', color='black', markerfacecolor='red', linestyle='None', markersize=8)
        ]
        
        # Crear leyendas para las cargas WD y WL
        handles_WD = [
            Line2D([0], [0], linestyle='None', color='none', label="Carga muerta:"),
            Line2D([0], [0], marker='s', color='black', markerfacecolor='lime', linestyle='None', markersize=8)
        ]
        handles_WL = [
            Line2D([0], [0], linestyle='None', color='none', label="Carga viva:"),
            Line2D([0], [0], marker='s', color='black', markerfacecolor='lime', linestyle='None', markersize=8)
        ]
        
        # Leyendas para la viga apoyada
        if tipo_viga == "Viga apoyada":
            ax.legend(
                handles=handles_reacciones,
                labels=["Reacciones:",  # Subtítulo
                    f"Ray = {reaccion_apoyo:.2f} kN",  # Reacción en A
                    f"Rby = {reaccion_apoyo:.2f} kN"],  # Reacción en B
                loc='upper left',
                bbox_to_anchor=(0.5, 1.8),
                fontsize=8,
                frameon=True,
                edgecolor='black',
                facecolor='lightgray'
            )
            fig.legend(
                handles=handles_WD + handles_WL,
                labels=["Carga muerta:",  # Subtítulo
                    f"WD = {WD:.2f} kN/m",  # WD
                    "Carga viva:",         # Subtítulo
                    f"WL = {WL:.2f} kN/m"],  # WL
                loc='upper left',
                bbox_to_anchor=(0.1, 0.98),  # Ajusta la posición
                fontsize=8,
                frameon=True,
                edgecolor='black',
                facecolor='lightgray'
            )
            
        # Leyendas para la viga empotrada
        elif tipo_viga == "Viga empotrada":
        # Leyenda para reacciones
            fig.legend(
                handles=handles_reacciones_M,
                labels=["Reacciones:",  # Subtítulo
                    f"Ray = {reaccion_apoyo:.2f} kN",  # Reacción en A
                    f"Rby = {reaccion_apoyo:.2f} kN"],  # Reacción en B
                loc='upper left',
                bbox_to_anchor=(0.55, 0.98),  # Ajusta la posición
                fontsize=8,
                frameon=True,
                edgecolor='black',
                facecolor='lightgray'
            )
        
        # Leyenda para momentos
            fig.legend(
                handles=handles_momentos,
                labels=["Momentos:",  # Subtítulo
                    f"MA = {momento_A:.2f} kNm",  # Momento en A
                    f"MB = {momento_B:.2f} kNm"],  # Momento en B
                loc='upper left',
                bbox_to_anchor=(0.1, 0.98),  # Ajusta la posición debajo de la leyenda de reacciones
                fontsize=8,
                frameon=True,
                edgecolor='black',
                facecolor='lightgray'
            )
            
        # Añadir leyenda de cargas WD y WL al gráfico
            fig.legend(
                handles=handles_WD,
                labels=["Carga muerta:",f"WD = {WD:.2f} kN/m"],
                loc='upper left',
                bbox_to_anchor=(0.55, 0.3),  # Ajustar la posición de la leyenda
                fontsize=8,
                frameon=True,
                edgecolor='black',
                facecolor='lightgray'
            )
            fig.legend(
                handles=handles_WL,
                labels=["Carga viva:",f"WL = {WL:.2f} kN/m"],
                loc='upper left',
                bbox_to_anchor=(0.1, 0.3),  # Ajustar la posición de la leyenda
                fontsize=8,
                frameon=True,
                edgecolor='black',
                facecolor='lightgray'
            )
        
        # Ajustar límites y limpiar canvas
        ax.set_xlim(desplazamiento_x - 50, longitud + desplazamiento_x + 50)
        ax.set_ylim(eje_y_central - 100, eje_y_central + 150)
        ax.set_aspect('equal', adjustable='box')
        ax.axis('off')
        
        # Limpiar canvas antes de mostrar nueva figura
        for widget in canvas_1.winfo_children():
            widget.destroy()
        
        # Mostrar figura en canvas
        canvas_viga_cargas = FigureCanvasTkAgg(fig, master=canvas_1)
        canvas_viga_cargas.draw()
        canvas_viga_cargas.get_tk_widget().place(x=1, y=1, width=380, height=280)

    except Exception as e:
        print(f"Error al dibujar la viga: {e}")

# Variables globales para los Label y StringVar
label_seccion_luz = None
label_seccion_Wu = None
var_luz_cargas = None
var_Wu_cargas = None

def abrir_ventana_cargas():
    global ventana_cargas_abierta ,combo_seccion_analisis, entry_base_cargas, entry_altura_cargas,entry_luz_cargas
    global entry_Wpp_cargas, entry_WD_cargas, entry_WL_cargas, entry_Wtotal_cargas, entry_Wu_cargas
    global Wu_var,label_tipo_viga_cargas,combo_viga_cargas,canvas_1,label_titulo_viga,label_titulo_cargas,label_texto_cargas
    global var_luz_cargas, var_Wu_cargas, label_seccion_luz, label_seccion_Wu,canvas_viga_analisis 
    # Verificar si ya hay una ventana abierta
    if ventana_cargas_abierta is not None and ventana_cargas_abierta.winfo_exists():
        # Si la ventana ya está abierta, no hacemos nada
        return
    
    # Crear una nueva ventana solo si no existe
    ventana_cargas_abierta = tk.Toplevel()  # Toplevel crea una ventana secundaria
    
    # Configurar la ventana
    ventana_cargas_abierta.title("Análisis de cargas")
    ventana_cargas_abierta.geometry("560x600")  # Tamaño de la ventana
    
    # Evitar que la ventana sea maximizada o redimensionada
    ventana_cargas_abierta.resizable(False, False)
    
    # Mantener la ventana siempre encima
    ventana_cargas_abierta.attributes('-topmost', True)
    
    
    # Crear contenido en la ventana cargas
    labelframe_cargas= tk.LabelFrame(ventana_cargas_abierta,text="")
    labelframe_cargas.place(x=30,y=30,width=500,height=500)
    label_apoyo_cargas = tk.Label(labelframe_cargas,text="Tipo de apoyo:")
    label_apoyo_cargas.place(x=20,y=20)
    entry_apoyo_cargas = tk.Entry(labelframe_cargas)
    entry_apoyo_cargas.place(x=120,y=20,width=100)
    # Obtener el valor del Label 'label_restriccion_apoyo' y mostrarlo en el Entry
    valor_restriccion = label_restriccion_apoyo.cget("text")  # Obtener el texto del Label
    entry_apoyo_cargas.insert(0, valor_restriccion)  # Insertamos el valor en el Entry
    label_viga_cargas = tk.Label(labelframe_cargas,text="Tipo de viga:")
    label_viga_cargas.place(x=270,y=20)
    # Crear el Combobox con las opciones
    combo_viga_cargas = ttk.Combobox(labelframe_cargas, values=["Viga apoyada", "Viga empotrada"])
    combo_viga_cargas.place(x=350, y=20, width=120)
    combo_viga_cargas.set("Seleccionar")  # Establecer el valor inicial
    
    labelframe_viga_cargas= tk.LabelFrame(labelframe_cargas,text="Diagrama viga")
    labelframe_viga_cargas.place(x=20,y=70,width=457,height=205)
    canvas_viga_analisis = tk.Canvas(labelframe_viga_cargas,bg="white",bd=2,relief="ridge")
    canvas_viga_analisis.pack(fill=tk.BOTH, expand=True, padx=0, pady=0)  # Incrustar el canvas con ajuste
    
    #Crear botones Aceptar, Calcular , Aplicar
    boton_aceptar_cargas= ttk.Button(ventana_cargas_abierta,text="Aceptar")
    boton_aceptar_cargas.place(x=110,y=550,width=100)
    
    boton_aplicar_cargas= ttk.Button(ventana_cargas_abierta,text="Aplicar", command=aplicar_cargas)
    boton_aplicar_cargas.place(x=330,y=550,width=100)
    
    
    # Crear las variables de tipo StringVar para vincular con los Entry
    var_luz_cargas = tk.StringVar()
    var_Wu_cargas = tk.StringVar()
    
    labelframe_analisis = tk.LabelFrame(labelframe_cargas,text="Análisis de cargas")
    labelframe_analisis.place(x=20,y=280,width=457,height=180)
    label_seccion_analisis =tk.Label(labelframe_analisis,text="Sección:")
    label_seccion_analisis.place(x=10,y=40)
    combo_seccion_analisis=ttk.Combobox(labelframe_analisis)
    combo_seccion_analisis.place(x=70,y=40,width=95)
    combo_seccion_analisis.set("Seleccionar")
    label_unicad_cargas1= tk.Label(labelframe_analisis,text="[VG]")
    label_unicad_cargas1.place(x=175,y=40)
    luz_cargas = tk.Label(labelframe_analisis,text="Luz:")
    luz_cargas.place(x=10,y=10)
    entry_luz_cargas =tk.Entry(labelframe_analisis,textvariable=var_luz_cargas)
    entry_luz_cargas.place(x=70,y=10,width=95)
    label_unicad_cargas2= tk.Label(labelframe_analisis,text="[m]")
    label_unicad_cargas2.place(x=175,y=10)
    base_cargas = tk.Label(labelframe_analisis,text="Base:")
    base_cargas.place(x=10,y=70)
    entry_base_cargas = tk.Entry(labelframe_analisis)
    entry_base_cargas.place(x=70,y=70,width=95)
    label_unicad_cargas3= tk.Label(labelframe_analisis,text="[m]")
    label_unicad_cargas3.place(x=175,y=70)
    altura_cargas = tk.Label(labelframe_analisis,text="Altura:")
    altura_cargas.place(x=10,y=100)
    entry_altura_cargas = tk.Entry(labelframe_analisis)
    entry_altura_cargas.place(x=70,y=100,width=95)
    label_unicad_cargas4= tk.Label(labelframe_analisis,text="[m]")
    label_unicad_cargas4.place(x=175,y=100)
    peso_concreto_cargas = tk.Label(labelframe_analisis,text="γConcreto:")
    peso_concreto_cargas.place(x=5,y=130)
    entry_concreto_cargas = tk.Entry(labelframe_analisis)
    entry_concreto_cargas.place(x=70,y=130,width=95)
    entry_concreto_cargas.insert(0, "24.00")
    label_unicad_cargas5= tk.Label(labelframe_analisis,text="[kN/m³]")
    label_unicad_cargas5.place(x=165,y=130)
    frame_cargas = tk.Frame(labelframe_analisis,bg="grey",bd=4,relief="ridge")
    frame_cargas.place(x=230,y=10,width=1,height=140)
    WD_cargas = tk.Label(labelframe_analisis,text="WD:")
    WD_cargas.place(x=250,y=10)
    entry_WD_cargas= tk.Entry(labelframe_analisis)
    entry_WD_cargas.place(x=290,y=10,width=95)
    label_unidad_WD = tk.Label(labelframe_analisis,text="[kN/m]")
    label_unidad_WD.place(x=390,y=10)
    WL_cargas = tk.Label(labelframe_analisis,text="WL:")
    WL_cargas.place(x=250,y=40)
    entry_WL_cargas= tk.Entry(labelframe_analisis)
    entry_WL_cargas.place(x=290,y=40,width=95)
    label_unidad_WL = tk.Label(labelframe_analisis,text="[kN/m]")
    label_unidad_WL.place(x=390,y=40)
    Wpp_cargas = tk.Label(labelframe_analisis,text="Wpp:")
    Wpp_cargas.place(x=250,y=70)
    entry_Wpp_cargas= tk.Entry(labelframe_analisis)
    entry_Wpp_cargas.place(x=290,y=70,width=95)
    label_unidad_Wpp = tk.Label(labelframe_analisis,text="[kN/m]")
    label_unidad_Wpp.place(x=390,y=70)
    Wtotal_cargas = tk.Label(labelframe_analisis,text="Wtotal:")
    Wtotal_cargas.place(x=245,y=100)
    entry_Wtotal_cargas= tk.Entry(labelframe_analisis)
    entry_Wtotal_cargas.place(x=290,y=100,width=95)
    label_unidad_Wtotal = tk.Label(labelframe_analisis,text="[kN/m]")
    label_unidad_Wtotal.place(x=390,y=100)
    Wu_cargas = tk.Label(labelframe_analisis,text="Wu:")
    Wu_cargas.place(x=250,y=130)
    entry_Wu_cargas= tk.Entry(labelframe_analisis,textvariable=var_Wu_cargas)
    entry_Wu_cargas.place(x=290,y=130,width=95)
    label_unidad_Wu = tk.Label(labelframe_analisis,text="[kN/m]")
    label_unidad_Wu.place(x=390,y=130)
    
    # Vincular eventos
    combo_viga_cargas.bind("<<ComboboxSelected>>", lambda event: actualizar_diagrama_viga(event, combo_viga_cargas, canvas_viga_analisis, entry_luz_cargas,Wu_var,label_tipo_viga_cargas))
    entry_luz_cargas.bind("<KeyRelease>", lambda event: actualizar_diagrama_viga(event, combo_viga_cargas, canvas_viga_analisis, entry_luz_cargas,Wu_var,label_tipo_viga_cargas))
    # Llamamos a la función para actualizar el ComboBox con el valor de label_seccion_cargas
    actualizar_combo_seccion(combo_seccion_analisis)
    
    # Asociar el evento de selección del ComboBox a la función actualizar_entries
    combo_seccion_analisis.bind("<<ComboboxSelected>>", actualizar_entries)
    # Asociar eventos para actualizar automáticamente Wtotal
    entry_WD_cargas.bind("<KeyRelease>", calcular_Wtotal)
    entry_WL_cargas.bind("<KeyRelease>", calcular_Wtotal)
    
    # Vincular el trace solo una vez cuando se cree la ventana
    Wu_var.trace_add("write", lambda name, index, mode: actualizar_diagrama_viga(None, combo_viga_cargas, canvas_viga_analisis, entry_luz_cargas, Wu_var,label_tipo_viga_cargas))
    
        
    # Función para actualizar los labels con los valores de los Entry
    def actualizar_labels(*args):
        label_seccion_luz.config(text=var_luz_cargas.get())  # Actualiza el label con el valor de luz de cargas
        label_seccion_Wu.config(text=var_Wu_cargas.get())  # Actualiza el label con el valor de Wu de cargas
    
    # Vincular las variables de los Entry con la función de actualización
    var_luz_cargas.trace("w", actualizar_labels)  # Cuando cambia la variable, actualiza el label correspondiente
    var_Wu_cargas.trace("w", actualizar_labels)    # Lo mismo para Wu de Cargas
    
    # Función para cerrar la ventana y liberar la referencia
    def cerrar_ventana():
        global ventana_cargas_abierta
        ventana_cargas_abierta.destroy()
        ventana_cargas_abierta = None


label_seccion_luz = tk.Label(ventana,text="",bg="red")
#label_seccion_luz.place(x=500,y=450,width=100)         #<---- Dato que hare salto de codigo luz de viga

label_seccion_Wu = tk.Label(ventana,text="",bg="red")  #<---- Dato que hare salto de codigo Wu 
#label_seccion_Wu.place(x=500,y=480,width=100)

label_tipo_viga_cargas = tk.Label(ventana,text="",bg="red")
#label_tipo_viga_cargas.place(x=500,y=520,width=100)        #<--- Dato que hare salto de codigo tipo viga apoyada o viga empotrada

label_restriccion_apoyo= tk.Label(ventana,text="",bg="red")
#label_restriccion_apoyo.place(x=500,y=400,width=100)   #<---- Dato que hare salto de codigo condicion de apoyos

label_seccion_cargas = tk.Label(ventana,text="",bg="red")
#label_seccion_cargas.place(x=500,y=420,width=100)       #<----- Dato que hare salto de codigo nombre de seccion transversal

frame_ventana_seccion = tk.Frame(ventana, bd=10, relief="ridge",bg="white")
frame_ventana_seccion.place(x=36, y=405, width=400, height=370)

frame_ventana_falsa = tk.Frame(frame_ventana_seccion,bd=2,relief="flat",bg="white")
frame_ventana_falsa.place(x=1,y=35,width=378,height=280)

label_titulo_seccion = tk.Label(frame_ventana_seccion  ,text="Diagrama sección transversal",bd=2,relief="raise")
label_titulo_seccion.place(x=1,y=1,width=380,height=35)

label_titulo_falsa = tk.Frame(frame_ventana_seccion,bd=2,relief="raise")
label_titulo_falsa.place(x=1,y=315,width=380,height=35)

frame_ventana_viga= tk.Frame(ventana, bd=10, relief="ridge",bg="white")
frame_ventana_viga.place(x=437, y=35, width=400, height=370)

label_titulo_viga = tk.Label(frame_ventana_viga,text="Análisis de Viga", bd=2, relief="raise")
label_titulo_viga.place(x=1,y=1,width=380,height=35)

label_titulo_cargas = tk.Frame(frame_ventana_viga,bd=2,relief="raise")
label_titulo_cargas.place(x=1,y=315,width=380,height=35)

label_texto_cargas = tk.Label(label_titulo_cargas, text="")
label_texto_cargas.pack(fill=tk.BOTH, expand=True)

canvas_1 = tk.Canvas(frame_ventana_viga, bd=2, relief="flat", bg="white")
canvas_1.place(x=1, y=36, width=380, height=280)

def actualizar_contenido_graficos(label_seccion_cargas, label_seccion_luz, label_seccion_Wu, label_tipo_viga_cargas, label_graficos_viga, label_graficos_luz, label_graficos_Wu, combo_graficos_Wu, label_graficos_tipo_viga):
    """
    Función para actualizar varios widgets en la ventana de gráficos, pasando como parámetros
    los widgets necesarios.
    """
    # Tomamos el texto de label_seccion_cargas de la ventana principal
    valor_cargas = label_seccion_cargas.cget("text")
    
    # Actualizamos el texto del label_graficos_viga con el valor de label_seccion_cargas
    label_graficos_viga.config(text=valor_cargas)
    
    # Actualizar el texto del label_graficos_luz con el valor de label_seccion_luz
    valor_luz = label_seccion_luz.cget("text")
    valor_luz_formateado = f"{valor_luz} m"  
    label_graficos_luz.config(text=valor_luz_formateado)
    
    # Agregar el valor de label_seccion_Wu como opción al combo 
    valor_Wu_graficos = label_seccion_Wu.cget("text")
    
    # Añadir el valor real del Wu al ComboBox, sin seleccionarlo por defecto
    combo_graficos_Wu['values'] = ["Seleccionar", valor_Wu_graficos]  
    combo_graficos_Wu.set("Seleccionar") 
    
    # Tomamos el valor de label_tipo_viga_cargas y actualizamos label_graficos_tipo_viga
    valor_tipo_viga = label_tipo_viga_cargas.cget("text")
    label_graficos_tipo_viga.config(text=valor_tipo_viga)

# Función para mostrar la ventana emergente
def mostrar_ventana_emergente():
    messagebox.showinfo("Pilot Structural", "¡Muy bien! Ahora puedes iniciar con las configuraciones de diseño a flexión.")

# Función para cerrar la ventana de gráficos
def cerrar_ventana_graficos():
    global ventana_graficos_abierta, ventana_graficos
    # Mostrar la ventana emergente antes de cerrar
    mostrar_ventana_emergente()
    
    ventana_graficos.destroy()  # Cerrar la ventana de gráficos
    ventana_graficos_abierta = False  # Permitir reabrir la ventana

# Definir las variables globales
ventana_graficos_abierta = False
ventana_graficos = None

# Variables globales para los labels y combobox
label_valor_M1 = None
label_valor_M2 = None
label_valor_M3 = None
Momento_Mu = None
label_valor_Mmax =None

# Función para abrir la ventana de gráficos
def abrir_ventana_graficos():
    global ventana_graficos_abierta, ventana_graficos, combo_graficos_Wu, label_graficos_luz, label_graficos_tipo_viga, label_frame_graficos_V_M
    global datos_exportar,boton_cancelar_graficos
    global fig
    global label_valor_M1, label_valor_M2, label_valor_M3,label_valor_Mmax
    # Verificar si la ventana ya está abierta
    if ventana_graficos_abierta:
        return  # Si ya está abierta, no hacer nada
    
    # Si no está abierta, crear la ventana secundaria
    ventana_graficos = tk.Toplevel()  
    ventana_graficos.title("Diagramas cortante y momento")  
    ventana_graficos.geometry("600x620")  
    
    # Configuración adicional: no redimensionable y siempre encima de otras ventanas
    ventana_graficos.resizable(False, False)  
    ventana_graficos.attributes('-topmost', True) 
    # Marcar la ventana como abierta
    ventana_graficos_abierta = True
    
    # Crear contenido en la ventana graficos
    
    label_frame_graficos = tk.LabelFrame(ventana_graficos, text="")
    label_frame_graficos.place(x=20,y=20,width=560,height=550)
    label_frame_carga = tk.LabelFrame(label_frame_graficos,text="Condiciones de carga [Wu]")
    label_frame_carga.place(x=10,y=10,width=200,height=100)
    label_graficos_Wu = tk.Label(label_frame_carga,text="Wu:")
    label_graficos_Wu.place(x=10,y=40)
    combo_graficos_Wu = ttk.Combobox(label_frame_carga)
    combo_graficos_Wu.place(x=40,y=40,width=130)
    combo_graficos_Wu.set("Seleccionar")
    label_graficos_info =tk.Label(label_frame_carga,text="Carga mayorada",bd=1,relief="sunken")
    label_graficos_info.place(x=10,y=10,width=160)
    label_frame_graficos_seccion =tk.LabelFrame(label_frame_graficos,text="Sección [VG]")
    label_frame_graficos_seccion.place(x=220,y=10,width=150,height=100)
    label_graficos_viga = tk.Label(label_frame_graficos_seccion,text="",bd=1,relief="sunken")
    label_graficos_viga.place(x=10,y=10,width=120)
    label_luz_viga = tk.Label(label_frame_graficos_seccion,text="Luz:")
    label_luz_viga.place(x=10,y=40)
    label_graficos_luz =tk.Label(label_frame_graficos_seccion,text="",bd=1,relief="sunken")
    label_graficos_luz.place(x=50,y=40,width=80)
    label_graficos_tipo_viga = tk.Label(label_frame_graficos,text="",bg="red")
    #label_graficos_tipo_viga.place(x=10,y=80,width=100)
    label_frame_graficos_slider = tk.LabelFrame(label_frame_graficos,text="Ajuste de valor")
    label_frame_graficos_slider.place(x=380,y=10,width=165,height=100)
    # Crear un slider
    slider_valor = tk.Scale(label_frame_graficos_slider, orient="horizontal",from_=0, to=10,resolution=0.1) 
    slider_valor.place(x=25,y=0)
    label_graficos_cortante = tk.Label(label_frame_graficos_slider,text="Cortante:")
    label_graficos_cortante.place(x=10,y=40)
    label_graficos_V = tk.Label(label_frame_graficos_slider,text="")
    label_graficos_V.place(x=70,y=40,width=75)
    label_graficos_momento = tk.Label(label_frame_graficos_slider,text="Momento:")
    label_graficos_momento.place(x=7,y=60)
    label_graficos_M = tk.Label(label_frame_graficos_slider,text="")
    label_graficos_M.place(x=70,y=60,width=75)
    
    #Crear labelframe valores max y min Cortante
    label_frame_Valores_V = tk.LabelFrame(label_frame_graficos,text="Valores max y min [V]")
    label_frame_Valores_V.place(x=380,y=120,width=165,height=100)
    label_valor_max = tk.Label(label_frame_Valores_V,text="V[+]:")
    label_valor_max.place(x=10,y=10)
    label_valor_min = tk.Label(label_frame_Valores_V,text="V[-]:")
    label_valor_min.place(x=10,y=45)
    label_max= tk.Label(label_frame_Valores_V,text="")
    label_max.place(x=50,y=10,width=75)
    label_min= tk.Label(label_frame_Valores_V,text="")
    label_min.place(x=50,y=45,width=75)
    
    #Crear labelframe valores max y min Momento viga empotrada
    label_frame_Valores_M = tk.LabelFrame(label_frame_graficos,text="Valores max y min [M]")
    label_frame_Valores_M.place(x=380,y=230,width=165,height=100)
    label_valor_min_M1 = tk.Label(label_frame_Valores_M ,text="M[-]:")
    label_valor_min_M1.place(x=10,y=5)
    label_valor_max_M2= tk.Label(label_frame_Valores_M ,text="M[+]:")
    label_valor_max_M2.place(x=10,y=30)
    label_valor_min_M3= tk.Label(label_frame_Valores_M ,text="M[-]:")
    label_valor_min_M3.place(x=10,y=55)
    label_valor_M1=tk.Label(label_frame_Valores_M,text="")
    label_valor_M1.place(x=50,y=5,width=75)
    label_valor_M2=tk.Label(label_frame_Valores_M,text="")
    label_valor_M2.place(x=50,y=30,width=75)
    label_valor_M3=tk.Label(label_frame_Valores_M,text="")
    label_valor_M3.place(x=50,y=55,width=75)
    
    #Crear labelFrame valor Mmax viga simplemente apoyada
    label_frame_Mmax= tk.LabelFrame(label_frame_graficos,text="")
    label_frame_Mmax.place(x=380,y=340,width=165,height=60)
    label_intervalo = tk.Label(label_frame_Mmax,text="")
    label_intervalo.place(x=50,y=5,width=85)
    label_Mmax = tk.Label(label_frame_Mmax,text="Mmax:")
    label_Mmax.place(x=5,y=30)
    label_valor_Mmax=tk.Label(label_frame_Mmax,text="")
    label_valor_Mmax.place(x=50,y=30,width=75)
    
    #Crear contenido Graficos V y M
    label_frame_graficos_V_M = tk.LabelFrame(label_frame_graficos,text="Diagrama Fuerza Cortante y Momento Flector [V,M]")
    label_frame_graficos_V_M.place(x=10,y=120,width=360,height=400)
    
    #Crear contendio y botones.
    label_frame_datos = tk.LabelFrame(label_frame_graficos,text="Exportar/Generar")
    label_frame_datos.place(x=380,y=410,width=165,height=110)
    
    boton_generar_pdf = ttk.Button(label_frame_datos,text="Generar")
    boton_generar_pdf.place(x=30,y=50,width=100)
    
    boton_exportar_datos = ttk.Button(label_frame_datos,text="Exportar",command=exportar_datos_a_excel)
    boton_exportar_datos.place(x=30,y=10,width=100)
    
    boton_aceptar_graficos = ttk.Button(ventana_graficos,text="Aceptar",command=copiar_imagen_graficos)
    boton_aceptar_graficos.place(x=150,y=580,width=100)
    
    boton_cancelar_graficos = ttk.Button(ventana_graficos,text="Cancelar",command=cerrar_ventana_graficos)
    boton_cancelar_graficos.place(x=330,y=580,width=100)
    
    # Asociar la acción de cerrar con el protocolo WM_DELETE_WINDOW
    ventana_graficos.protocol("WM_DELETE_WINDOW", cerrar_ventana_graficos)
    
    # Llamar a la función de actualización, pasando los labels como parámetros
    actualizar_contenido_graficos(
        label_seccion_cargas, label_seccion_luz, label_seccion_Wu, label_tipo_viga_cargas,
        label_graficos_viga, label_graficos_luz, label_graficos_Wu, combo_graficos_Wu,
        label_graficos_tipo_viga
    )
    
    boton_cancelar_graficos=None
    def mostrar_grafico(event):
        global datos_exportar,boton_cancelar_graficos
        global fig
        tipo_viga = label_graficos_tipo_viga.cget("text")
        Wu = combo_graficos_Wu.get()
        Luz = label_graficos_luz.cget("text")

        try:
            Wu = float(Wu)
            Luz = float(Luz.split()[0])
        except (ValueError, AttributeError):
            return
    
        # Reacciones en los apoyos
        Apoyo_A = Wu * Luz / 2
        Apoyo_B = Wu * Luz / 2
        
        # Actualizar los Labels con los valores estáticos
        label_max.config(text=f"{Apoyo_A:.2f} kN")
        label_min.config(text=f"{Apoyo_B:.2f} kN")
        
        # Crear listas para cortante
        posiciones_cortante = [0, Luz]
        cortante = [Apoyo_A, -Apoyo_B]  # Línea diagonal
    
        # Crear puntos intermedios para la curva parabólica
        x_momento = np.linspace(0, Luz, 100)  # 100 puntos para suavizar la curva
        momento = []
        
        if tipo_viga == "Viga apoyada":
        # Cortante: Línea diagonal desde Apoyo_A hacia -Apoyo_B
            cortante = [Apoyo_A, 0, -Apoyo_B]
            posiciones_cortante = [0, Luz / 2, Luz]
            
        # Momento flector: Curva parabólica
            momento = Wu * x_momento * (Luz - x_momento) / 2  
            
        # Actualizar labels específicos para viga apoyada
            label_valor_Mmax.config(text=f"{max(momento):.2f} kNm")
            label_intervalo.config(text=f"[0.0 ≤ X ≤ {Luz:.2f}]")
            
            label_valor_M1.config(text="N/A")
            label_valor_M2.config(text="N/A")
            label_valor_M3.config(text="N/A")
            
        # Actualizar el combobox con los valores de Mmax
            actualizar_combobox("Viga apoyada")
            
        elif tipo_viga == "Viga empotrada":
        # Cortante: Línea diagonal desde Apoyo_A hacia -Apoyo_B
            cortante = [Apoyo_A, 0, -Apoyo_B]
            posiciones_cortante = [0, Luz / 2, Luz]
            
        # Momento flector: Curva parabólica con momentos en los extremos
            MA =  Wu * (Luz ** 2) / 12  # Momento en apoyo izquierdo
            MB = -Wu * (Luz ** 2) / 12   # Momento en apoyo derecho
            
        # Fórmula general del momento en viga empotrada
            momento = -(MB + Apoyo_B * x_momento - (Wu * x_momento ** 2) / 2)
            
            label_valor_M1.config(text=f"{MA:.2f} kNm")
            label_valor_M2.config(text=f"{max(momento)/2:.2f} kNm")
            label_valor_M3.config(text=f"{MB:.2f} kNm")
            
            label_valor_Mmax.config(text="   N/A")
            label_intervalo.config(text="N/A")
            
            # Actualizar el combobox con los valores de M1, M2, M3
            actualizar_combobox("Viga empotrada")
            
        # Guardar datos en una lista global para exportar
        datos_exportar = {
            "Longitud": x_momento,
            "Cortante": [cortante[0] if x <= Luz / 2 else cortante[2] for x in x_momento],
            "Momento": momento
        }
        
        # Actualizar label_Mmax_1 con el valor de M1
        label_Mmax_1.config(text=f"{MA:.2f} kNm")  
        
        # Actualizar label_Mmax_2 con el valor de M2
        label_Mmax_2.config(text=f"{max(momento)/2:.2f} kNm")  
        
        
    # Crear el gráfico en el LabelFrame
        fig, axs = plt.subplots(2, 1, figsize=(5, 6), dpi=100, sharex=True)
        fig.subplots_adjust(hspace=0.3)

    # Diagrama de Fuerza Cortante
        axs[0].fill_between(posiciones_cortante, 0, cortante, where=np.array(cortante) >= 0, 
                        interpolate=True, color="Darkblue", alpha=1)
        axs[0].fill_between(posiciones_cortante, 0, cortante, where=np.array(cortante) < 0, 
                        interpolate=True, color="red", alpha=1)
        axs[0].plot(posiciones_cortante, cortante, label="Fuerza Cortante", color="blue", linestyle="-")
        axs[0].axhline(0, color="black", linewidth=0.8, linestyle="-")
        axs[0].set_title("Diagrama de Fuerza Cortante", fontsize=10)
        axs[0].set_xlabel("Longitud (m)", fontsize=9,)
        axs[0].set_ylabel("Cortante (kN)", fontsize=9)
        axs[0].tick_params(axis="both", labelsize=9)
        
        # Personalización de la leyenda del Cortante
        axs[0].legend(loc='upper right',fontsize=9, edgecolor='black', facecolor='white',bbox_to_anchor=(0.95, 0.95), framealpha=0.5)
        
        axs[0].set_facecolor('lightgray')
        axs[0].set_xticks([])  
        axs[0].set_yticks([])  

    # Diagrama de Momento Flector 
        axs[1].fill_between(x_momento, 0, momento, where=momento  >= 0, 
                        interpolate=True, color="Darkblue", alpha=1)
        axs[1].fill_between(x_momento, 0,  momento, where=momento  < 0, 
                        interpolate=True, color="red", alpha=1)
        axs[1].plot(x_momento,  momento, label="Momento Flector", color="black", linestyle="-")
        axs[1].axhline(0, color="black", linewidth=0.8, linestyle="-")  # Línea horizontal en 0
        axs[1].set_title("Diagrama de Momento Flector", fontsize=10)
        axs[1].set_xlabel("Longitud (m)", fontsize=9)
        axs[1].set_ylabel("Momento (kNm)", fontsize=9)
        axs[1].tick_params(axis="both", labelsize=9)
        
        # Personalización de la leyenda del Momento Flector
        axs[1].legend(loc='center', fontsize=9, bbox_to_anchor=(0.5, 0.8), edgecolor='black', facecolor='white', framealpha=0.5)
        
        
        axs[1].set_facecolor('lightgray') 
        axs[1].set_xticks([])  
        axs[1].set_yticks([])  
        
    # Fijar los límites del eje Y para mantener el 0 fijo en la intersección
        momento_min = min( momento)
        momento_max = max( momento)
        axs[1].set_ylim(momento_min - abs(momento_min * 0.1), momento_max + abs(momento_max * 0.1))
        
        
        
    # Limpiar contenido previo y mostrar el gráfico en el LabelFrame
        for widget in label_frame_graficos_V_M.winfo_children():
            widget.destroy()
        
        canvas = FigureCanvasTkAgg(fig, master=label_frame_graficos_V_M)
        canvas.draw()
        canvas.get_tk_widget().pack(fill="both", expand=True)
        
        # Configurar el rango del slider basado en la longitud de la viga
        slider_valor.config(from_=0, to=Luz, resolution=0.1)
        slider_valor.set(0)
        
        # Función para actualizar los marcadores y contenido widgets
        def actualizar_marcadores(valor):
            posicion = float(valor)
            
            # Eliminar marcadores previos
            for line in axs[0].lines[1:]:
                line.remove()
            for line in axs[1].lines[1:]:
                line.remove()
            
            # Interpolación para obtener los valores de cortante y momento en la posición actual
            cortante_y = np.interp(posicion, posiciones_cortante, cortante)
            momento_y = np.interp(posicion, x_momento,  momento)

            cortante_y = np.interp(posicion, posiciones_cortante, cortante)
            axs[0].plot(posicion, cortante_y, marker="o", color="black", linestyle=' ', label=f"[V]: {cortante_y:.2f} kN")

            momento_y = np.interp(posicion, x_momento,  momento)
            axs[1].plot(posicion, momento_y, marker="o", color="black",linestyle=' ', label=f"[M]: {-momento_y:.2f} kNm",)
            
            # Actualizar el texto del eje X con la longitud dinámica basada en la posición del slider
            axs[0].set_xlabel(f"Longitud ({posicion:.2f} m)", fontsize=9)
            axs[1].set_xlabel(f"Longitud ({posicion:.2f} m)", fontsize=9)
            
            # Personalizar leyendas: borde negro y fondo blanco transparente
            axs[0].legend(loc='upper right', fontsize=7,bbox_to_anchor=(0.95, 0.95), edgecolor='black', facecolor='white', framealpha=0.5)
            axs[1].legend(loc='center', fontsize=7, bbox_to_anchor=(0.5, 0.8), edgecolor='black', facecolor='white', framealpha=0.5)
            
            # Actualizar los Labels con los valores dinámicos
            label_graficos_V.config(text=f"{cortante_y:.2f} kN")
            label_graficos_M.config(text=f"{-momento_y:.2f} kNm")
            
            
            canvas.draw()
            
        slider_valor.config(command=actualizar_marcadores)
            
        
    # Asociar evento después de crear los widgets
    combo_graficos_Wu.bind("<<ComboboxSelected>>", mostrar_grafico)

def copiar_imagen_graficos():
    global fig  # Asegúrate de que fig esté definido en el contexto
    
    # Paso 1: Guardar el gráfico como una imagen en la carpeta especificada
    image_path = "Reportes/imagenes_pilot/grafico.png"
    fig.savefig(image_path, format='png', dpi=300, transparent=True)  


#Crear widgets para hacer saltos de codigo 
# combobox para momentos ultimos de viga 
Momento_Mu= ttk.Combobox(ventana)
#Momento_Mu.place(x=500,y=600)

# combobox para barras de refuerzo de viga
Barras_refuerzo= ttk.Combobox(ventana)
#Barras_refuerzo.place(x=500,y=630)

# combobox para el #barras tracción
Barras_traccion= ttk.Combobox(ventana)
#Barras_traccion.place(x=500,y=660)

# combobox para el #barras compresión
Barras_compresion= ttk.Combobox(ventana)
#Barras_compresion.place(x=500,y=690)


# Función para actualizar el Combobox con los valores de los labels
def actualizar_combobox(tipo_viga):
    if tipo_viga == "Viga apoyada":
        # Solo actualizar el combobox con el valor de Mmax en caso de viga apoyada
        valores_Mu = [label_valor_Mmax.cget("text")]
    elif tipo_viga == "Viga empotrada":
        # Obtener los valores de M1, M2
        valor_M1 = label_valor_M1.cget("text")
        valor_M2 = label_valor_M2.cget("text")
        
        # Obtener el valor de M3, eliminar solo el signo negativo y mantener el texto "kNm"
        valor_M3 = label_valor_M3.cget("text")
        if valor_M3.startswith('-'):
            valor_M3 = valor_M3[1:]  # Eliminar el primer carácter (el signo negativo)
        
        # Actualizar los valores para viga empotrada
        valores_Mu = [valor_M1, valor_M2, valor_M3]
    
    # Actualizar las opciones del combobox
    Momento_Mu['values'] = valores_Mu
    if valores_Mu:
        Momento_Mu.set(valores_Mu[0])  # Establecer el valor por defecto en el primer elemento


def exportar_datos_a_excel():
    global datos_exportar
    global fig
    if not datos_exportar:
        print("No hay datos para exportar.")
        return

    # Convertir los datos en un DataFrame
    df = pd.DataFrame(datos_exportar)

    # Definir el directorio y archivo de salida
    directorio = "Archivos_Excel"
    if not os.path.exists(directorio):
        os.makedirs(directorio)
    archivo_salida = os.path.join(directorio, "datos_graficos.xlsx")

    # Guardar el DataFrame en un archivo Excel
    df.to_excel(archivo_salida, index=False)
    print(f"Datos exportados correctamente a {archivo_salida}")

    # Abrir el archivo Excel en el programa predeterminado
    if os.name == 'nt':  # Si es Windows
        os.startfile(archivo_salida)
    elif os.name == 'posix':  # Si es MacOS o Linux
        os.system(f'open "{archivo_salida}"')  # Para MacOS
        # os.system(f'xdg-open "{archivo_salida}"')  # Para Linux

# Definir las variables globales necesarias
cortante = []  # Lista de valores de cortante
posiciones_cortante = []  # Lista de posiciones para el cortante
momento = []  # Lista de valores de momento
x_momento = []  # Lista de posiciones para el momento
Luz = None  # Longitud de la viga
label_frame_graficos_V_M = None  # Definir esto según sea necesario
slider_valor = None  # Definir esto según sea necesario
label_graficos_V = None  # Definir esto según sea necesario
label_graficos_M = None  # Definir esto según sea necesario
# Variable global para la figura
fig = None



# Función para actualizar los valores de Momento_Mu
def actualizar_momento_mu():
    # Cambiar los valores de Momento_Mu (esto debe venir de algún evento)
    nuevos_valores = Momento_Mu['values']  # Tomamos los mismos valores de Momento_Mu

    # Si la ventana flexión está abierta, actualizamos el ComboBox de esa ventana
    if ventana_flexion and ventana_flexion.winfo_exists():
    # Aquí sincronizamos la actualización de los valores de combo_flexion_Mu
        combo_flexion_Mu['values'] = nuevos_valores  # Actualizamos los valores de combo_flexion_Mu
        if nuevos_valores:
            combo_flexion_Mu.set(nuevos_valores[0])  # Establecemos el primer valor como valor por defecto


def cerrar_ventana_flexion():
    ventana_flexion.destroy()  # Cierra la ventana de flexión

# Variable global para almacenar la referencia de la ventana flexión
ventana_flexion = None

# Variables globales para los Entry
entry_flexion_VG = None
entry_flexion_base = None
entry_flexion_altura = None
entry_flexion_recubrimiento = None
entry_flexion_profundidad = None

# Función para abrir la ventana flexión
def abrir_ventana_flexion():
    global ventana_flexion, entry_flexion_VG, entry_flexion_base, entry_flexion_altura,entry_flexion_recubrimiento, entry_flexion_profundidad
    global combo_flexion_fc, combo_flexion_fy, entry_flexion_β1,entry_flexion_cuantia_min, entry_flexion_cuantia_max
    global combo_flexion_Mu,combo_flexion_Rn, combo_flexion_𝞀req, combo_flexion_Asreq
    global datos_agregados
    datos_agregados = False
    
    # Si la ventana flexión ya está abierta, no abrir otra
    if ventana_flexion is None or not ventana_flexion.winfo_exists():
        # Crear una nueva ventana secundaria usando Toplevel
        ventana_flexion = tk.Toplevel()

        # Configurar la ventana
        ventana_flexion.title("Diseño a flexión")  
        ventana_flexion.geometry("850x580")  

        # Hacer que la ventana no sea redimensionable
        ventana_flexion.resizable(False, False)

        # Mantener la ventana siempre en primer plano
        ventana_flexion.attributes('-topmost', True)
        
        #Crear contenido ventana flexion
        labelframe_flexion = tk.LabelFrame(ventana_flexion,text="")
        labelframe_flexion.place(x=20,y=20,width=810,height=510)
        labelframe_flexion_Mu = tk.LabelFrame(labelframe_flexion,text="Momento ultimo/Sección transversal")
        labelframe_flexion_Mu.place(x=20,y=10,width=350,height=100)
        label_flexion_Mu = tk.Label(labelframe_flexion_Mu,text="Momento actuante [Mu]:")
        label_flexion_Mu.place(x=20,y=15)
        combo_flexion_Mu = ttk.Combobox(labelframe_flexion_Mu)
        combo_flexion_Mu.place(x=180,y=15)
        combo_flexion_Mu['values'] = Momento_Mu['values']  
        combo_flexion_Mu.set(Momento_Mu.get())
        label_flexion_VG = tk.Label(labelframe_flexion_Mu,text="Sección elemento [VG]:")
        label_flexion_VG.place(x=20,y=45)
        entry_flexion_VG = tk.Entry(labelframe_flexion_Mu)
        entry_flexion_VG.place(x=180,y=45,width=143)
        entry_flexion_VG.insert(0, label_seccion_cargas.cget("text"))
        entry_flexion_VG.bind("<KeyRelease>", actualizar_dimensiones)
        
        
        # Crear StringVars para los Entry
        base_var = tk.StringVar()
        recubrimiento_var = tk.StringVar()
        
        labelframe_flexion_dimensiones = tk.LabelFrame(labelframe_flexion ,text="Dimensiones de la viga [VG]")
        labelframe_flexion_dimensiones.place(x=20,y=130,width=350,height=110)
        label_flexion_base=tk.Label(labelframe_flexion_dimensiones,text="Base  [b]:")
        label_flexion_base.place(x=20,y=15)
        entry_flexion_base= tk.Entry(labelframe_flexion_dimensiones, textvariable=base_var)
        entry_flexion_base.place(x=110,y=15,width=143)
        label_flexion_unidad_b= tk.Label(labelframe_flexion_dimensiones,text="[m]")
        label_flexion_unidad_b.place(x=280,y=15)
        label_flexion_altura = tk.Label(labelframe_flexion_dimensiones,text="Altura  [h]:")
        label_flexion_altura.place(x=20,y=45)
        entry_flexion_altura= tk.Entry(labelframe_flexion_dimensiones)
        entry_flexion_altura.place(x=110,y=45,width=143)
        label_flexion_unidad_h= tk.Label(labelframe_flexion_dimensiones,text="[m]")
        label_flexion_unidad_h.place(x=280,y=45)
        labelframe_flexion_r_d = tk.LabelFrame(labelframe_flexion,text="Recubrimiento/Altura efectiva")
        labelframe_flexion_r_d.place(x=20,y=260,width=350,height=110)
        label_flexion_recubrimiento = tk.Label(labelframe_flexion_r_d,text="Recubrimiento [r]:")
        label_flexion_recubrimiento.place(x=5,y=15)
        entry_flexion_recubrimiento= tk.Entry(labelframe_flexion_r_d,textvariable=recubrimiento_var)
        entry_flexion_recubrimiento.place(x=110,y=15,width=143)
        entry_flexion_recubrimiento.bind("<KeyRelease>", actualizar_profundidad)  
        label_flexion_unidad_r= tk.Label(labelframe_flexion_r_d,text="[m]")
        label_flexion_unidad_r.place(x=280,y=15)
        label_flexion_profundidad = tk.Label(labelframe_flexion_r_d,text="Profundidad [d]:")
        label_flexion_profundidad.place(x=5,y=45)
        entry_flexion_profundidad= tk.Entry(labelframe_flexion_r_d)
        entry_flexion_profundidad.place(x=110,y=45,width=143)
        label_flexion_unidad_d= tk.Label(labelframe_flexion_r_d,text="[m]")
        label_flexion_unidad_d.place(x=280,y=45)
        labelframe_flexion_info= tk.LabelFrame(labelframe_flexion,text="Información adicional")
        labelframe_flexion_info.place(x=20,y=380,width=350,height=100)
        label_flexion_NSR10 = tk.Label(labelframe_flexion_info,text="Norma de diseño:")
        label_flexion_NSR10.place(x=5,y=15)
        L_flexion_NSR10 = tk.Label(labelframe_flexion_info,text="NSR-10")
        L_flexion_NSR10.place(x=110, y=15, width=143)
        label_flexion_estribo= tk.Label(labelframe_flexion_info,text="Estribo de diseño:")
        label_flexion_estribo.place(x=5,y=45)
        
        labelframe_flexion_materiales= tk.LabelFrame(labelframe_flexion,text="Resistencia de materiales [σ]")
        labelframe_flexion_materiales.place(x=380,y=10,width=408,height=100)
        label_flexion_fc= tk.Label(labelframe_flexion_materiales,text="Concreto [f'c]:")
        label_flexion_fc.place(x=5,y=15)
        combo_flexion_fc= ttk.Combobox(labelframe_flexion_materiales)
        combo_flexion_fc.place(x=95,y=15)
        combo_flexion_fc['values'] = ["Seleccionar", "17.5 MPa", "21 MPa", "24.5 MPa", "28 MPa", "35 MPa", "42 MPa"]
        combo_flexion_fc.current(0)  
        combo_flexion_fc.bind("<<ComboboxSelected>>", lambda event: actualizar_β1(event, combo_flexion_fc, combo_flexion_fy, entry_flexion_β1, 
                                entry_flexion_cuantia_min, entry_flexion_cuantia_max,combo_flexion_Rn,combo_flexion_𝞀req,
                                combo_flexion_Asreq,entry_flexion_base,entry_flexion_profundidad,Barras_refuerzo,label_fc,
                                label_cuantia_minima,label_cuantia_maxima,label_beta1,label_cuantia_requerida,label_acero_requerido,
                                label_As2,label_req_C2)) 
        
        
        
        
        label_flexion_fy= tk.Label(labelframe_flexion_materiales,text="Acero [fy]:")
        label_flexion_fy.place(x=5,y=45)
        combo_flexion_fy= ttk.Combobox(labelframe_flexion_materiales)
        combo_flexion_fy.place(x=95,y=45)
        combo_flexion_fy['values'] = ["Seleccionar", "420 MPa"]
        combo_flexion_fy.current(1)  
        label_flexion_β1 = tk.Label(labelframe_flexion_materiales,text="Factor [β1]:")
        label_flexion_β1.place(x=280,y=15)
        entry_flexion_β1=tk.Entry(labelframe_flexion_materiales)
        entry_flexion_β1.place(x=273,y=45,width=80)
        
        labelframe_flexion_cuantia = tk.LabelFrame(labelframe_flexion,text="Cuantia diseño [𝞀]")
        labelframe_flexion_cuantia.place(x=380,y=130,width=180,height=110)
        label_flexion_cuantia_min = tk.Label(labelframe_flexion_cuantia,text="𝞀min:")
        label_flexion_cuantia_min.place(x=10,y=10)
        entry_flexion_cuantia_min = tk.Entry(labelframe_flexion_cuantia)
        entry_flexion_cuantia_min.place(x=70,y=10,width=90)
        label_flexion_cuantia_max = tk.Label(labelframe_flexion_cuantia,text="𝞀max:")
        label_flexion_cuantia_max.place(x=10,y=50)
        entry_flexion_cuantia_max = tk.Entry(labelframe_flexion_cuantia)
        entry_flexion_cuantia_max.place(x=70,y=50,width=90)
        
        labelframe_flexion_calculos = tk.LabelFrame(labelframe_flexion,text="Cálculos previos")
        labelframe_flexion_calculos.place(x=570,y=130,width=218,height=110) 
        label_flexion_Rn = tk.Label(labelframe_flexion_calculos,text="Rn:")
        label_flexion_Rn.place(x=30,y=10)
        combo_flexion_Rn = ttk.Combobox(labelframe_flexion_calculos)
        combo_flexion_Rn.place(x=80,y=10,width=90)
        label_flexion_𝞀req = tk.Label(labelframe_flexion_calculos,text="𝞀req:")
        label_flexion_𝞀req.place(x=30,y=35)
        combo_flexion_𝞀req = ttk.Combobox(labelframe_flexion_calculos)
        combo_flexion_𝞀req.place(x=80,y=35,width=90)
        label_flexion_Asreq = tk.Label(labelframe_flexion_calculos,text="Asreq:")
        label_flexion_Asreq.place(x=30,y=60)
        combo_flexion_Asreq = ttk.Combobox(labelframe_flexion_calculos)
        combo_flexion_Asreq.place(x=80,y=60,width=90)
        
        # Cuando cambie la base o el recubrimiento, actualizamos los entrys externos
        def actualizar_entrys_externos(*args):
            # Actualizar el entry externo para base
            entry_prueba_base.delete(0, tk.END)
            entry_prueba_base.insert(0, base_var.get())
            
            # Actualizar el entry externo para recubrimiento, multiplicar por 1000 y añadir "mm"
            try:
                recubrimiento_value = float(recubrimiento_var.get()) * 1000  # Convertir a mm
                entry_prueba_recubrimiento.delete(0, tk.END)
                entry_prueba_recubrimiento.insert(0, f"{recubrimiento_value} mm")
            except ValueError:
                entry_prueba_recubrimiento.delete(0, tk.END)
                entry_prueba_recubrimiento.insert(0, "Error")
        
        # Vincular el trace a las variables para actualizar automáticamente
        base_var.trace("w", actualizar_entrys_externos)
        recubrimiento_var.trace("w", actualizar_entrys_externos)
        
        
        boton_aceptar_flexion = ttk.Button(ventana_flexion,text="Aceptar",command=cerrar_ventana_flexion)
        boton_aceptar_flexion.place(x=380,y=540,width=100)
        
        # Configurar un estilo personalizado para el Notebook
        style = ttk.Style()
        style.configure("CustomNotebook.TNotebook", background="lightgray", tabmargins=[0, 0, 0, 0])
        style.configure("CustomNotebook.TNotebook.Tab", background="white", foreground="black", padding=[10, 2])
        style.map("CustomNotebook.TNotebook.Tab", background=[("selected", "lightgray")])
        
        frame_flexion_tabla = tk.Frame(labelframe_flexion,bd=2,relief="groove")
        frame_flexion_tabla.place(x=380,y=268,width=409,height=212)
        
        # Crear el notebook_tabla con el estilo personalizado
        notebook_tabla = ttk.Notebook(frame_flexion_tabla, style="CustomNotebook.TNotebook")
        
        # Crear la pestaña "Tabla"
        tab1 = ttk.Frame(notebook_tabla)
        notebook_tabla.add(tab1, text="Resultados")
        
        # Crear el Treeview (tabla de datos) dentro de la pestaña
        columns = ("Mu [kNm]", "Rn [kN/m²]", "Cuantia\nDiseño", "As") 
        treeview = ttk.Treeview(tab1, columns=columns, show="headings") 
        
        
        # Configurar las columnas del Treeview
        treeview.heading("Mu [kNm]", text="Mu [kNm]")
        treeview.heading("Rn [kN/m²]", text="Rn [kN/m²]")
        treeview.heading("Cuantia\nDiseño", text="Cuantia")
        treeview.heading("As", text="As [mm²]")
        
        # Configurar el ancho de cada columna individualmente
        treeview.column("Mu [kNm]", width=80,anchor="center")  
        treeview.column("Rn [kN/m²]", width=80,anchor="center")  
        treeview.column("Cuantia\nDiseño", width=80,anchor="center")  
        treeview.column("As", width=80,anchor="center")  
        
        
        treeview.place(x=10, y=35, width=380, height=90)
        
        
        # Variables para almacenar los valores seleccionados
        valores_mu = []
        valores_rn = []
        valores_cuantia = []
        valores_as = []
        
        # Función para insertar datos en el Treeview al presionar el botón
        def insertar_todos_los_datos():
            global valores_mu, valores_rn, valores_cuantia, valores_as
            # Obtener valores seleccionados de los combobox
            valores_mu = [valor.split()[0] for valor in combo_flexion_Mu['values']]
            valores_rn = combo_flexion_Rn['values']
            valores_cuantia = combo_flexion_𝞀req['values']
            valores_as = combo_flexion_Asreq['values']
            
            # Limpiar las filas del Treeview antes de agregar nuevos datos
            for item in treeview.get_children():
                treeview.delete(item)
            
            #Crear las filas combinando los valores
            for i in range(len(valores_mu)):
                treeview.insert("", "end", values=(valores_mu[i], valores_rn[i], valores_cuantia[i], valores_as[i]))
                
            
        boton_insertar= ttk.Button(tab1,text="Agregar datos",command=insertar_todos_los_datos)
        boton_insertar.place(x=80,y=140)
        
        
        # Función para verificar los datos
        def verificar_datos():
        # Obtener los valores de valores_mu y valores_cuantia (estos son los valores de los combobox)
            valores_mu = [valor.split()[0] for valor in combo_flexion_Mu['values']]
            valores_cuantia = combo_flexion_𝞀req['values']
            
            # Verificar que se han ingresado 1 o 3 valores de gamma y valores_mu
            if len(valores_cuantia) not in [1, 3] or len(valores_mu) not in [1, 3]:
                print("Error: Se deben ingresar 1 o 3 valores tanto para Mu como para gamma.")
                return
            
            # Obtener los valores necesarios para el cálculo de ϕMn
            phi = 0.90  # Constante para ϕ
            # Extraer solo el valor numérico de fy 
            fy_flexion = combo_flexion_fy.get().split()[0]  
            fy_flexion= float(fy_flexion)  # Convertir a float
            
            # Extraer solo el valor numérico de f'c 
            fc_flexion = combo_flexion_fc.get().split()[0]  
            fc_flexion = float(fc_flexion)         # Convertir a float
            
            gamma_values = [float(value) for value in valores_cuantia] 
            beta = float(entry_flexion_β1.get())  # Valor de β
            b_flexion = float(entry_flexion_base.get())  # Valor de b
            d_flexion = float(entry_flexion_profundidad.get())  # Valor de d
            
            
            # Calcular ϕMn para cada valor de gamma
            resultados_ϕMn = []
            for gamma in gamma_values:
                try:
                    # Fórmula corregida para ϕMn:
                    numerador = gamma * fy_flexion
                    fraccion = (numerador) / (2 * beta * fc_flexion)  # La fracción dentro del corchete
                    ϕMn = phi * numerador * 1000 * (1 - fraccion) * b_flexion * d_flexion**2
                    resultados_ϕMn.append(ϕMn)
                except ZeroDivisionError:
                    resultados_ϕMn.append(0) 
            
            # Si solo hay 1 valor de gamma, mostrarlo en la primera fila y "N/A" en las otras filas
            if len(gamma_values) == 1:
                resultados_ϕMn = [resultados_ϕMn[0], "N/A", "N/A"]
                valores_mu = [valores_mu[0], "N/A", "N/A"]
                valores_cuantia = [valores_cuantia[0], "N/A", "N/A"]
            
            elif len(gamma_values) == 3:
                resultados_ϕMn = resultados_ϕMn[:3]  # Solo tomar los tres primeros resultados si hay tres valores de gamma
                valores_mu = valores_mu[:3]
                valores_cuantia = valores_cuantia[:3]
            
            # Verificar que el número de filas en el treeview coincida con la cantidad de datos
            cumple_diseño = None
            cumple_resultados = []  # Para almacenar si cumple o no cumple en cada fila
            
            # Verificar que el número de filas en el treeview coincida con la cantidad de datos
            treeview_rows = len(treeview_flexion.get_children())
            
            # Asegurarse de que el número de filas coincida con los valores a insertar
            for i, item_id in enumerate(treeview_flexion.get_children()):
            # Si el índice i es menor que la longitud de los valores_mu, se actualiza la fila
                if i < len(valores_mu):
                    current_values = treeview_flexion.item(item_id)['values']
                    
            # Verificar si valores_mu[i] no es "N/A" antes de intentar convertirlo a float
                    if valores_mu[i] != "N/A" and float(valores_mu[i]) <= resultados_ϕMn[i]:
                        cumple = "Cumple"
                    else:
                        cumple = "No cumple"
                    
            # Actualizamos las columnas correspondientes
                    new_values = (current_values[0],  # "Mmax_Mmin" 
                            valores_mu[i],        # "Mu_kNm"
                            valores_cuantia[i],   # "Cuantia"
                            resultados_ϕMn[i],    # "ϕMn"
                            cumple                # "Mu ≤ ɸMn"
                            )
                    treeview_flexion.item(item_id, values=new_values)
                    
            # Almacenamos los resultados de "cumple" o "no cumple" para cada fila
                    cumple_resultados.append(cumple)
            
            # Actualizar el mensaje en los labels:
                    if len(resultados_ϕMn) > 0:
            # Actualizar los valores de ϕMn en los labels
                        label_ɸMn1.config(text=f"{resultados_ϕMn[0]:.4f} kNm")  # Primer valor
                    if len(resultados_ϕMn) > 1:
                        label_ɸMn2.config(text=f"{resultados_ϕMn[1]:.4f} kNm")  # Segundo valor
            
            # Actualizar el label de conclusión ( Si Cumple o No Cumple)
                    if len(cumple_resultados) > 0:
                        if cumple_resultados[0] == "Cumple":
                            label_concluision_ɸMn.config(text="Si Cumple")
                        else:
                            label_concluision_ɸMn.config(text="No Cumple")
            
            # Actualizar label_concluision_ɸMn2 con el segundo dato de cumple_resultados
                    if len(cumple_resultados) > 1:
                        if cumple_resultados[1] == "Cumple":
                            label_concluision_ɸMn2.config(text="Si Cumple")
                        else:
                            label_concluision_ɸMn2.config(text="No cumple")
            
            # Determinar el mensaje a mostrar en label_check
                    if cumple == "Cumple":
                        cumple_diseño = "Cumple"
                    else:
                        cumple_diseño = "No cumple"
                    
            # Limpiar las filas sobrantes si hay menos de 3 valores de gamma
                elif i >= len(valores_mu):
                    current_values = treeview_flexion.item(item_id)['values']
                    new_values = (current_values[0],  # "Mmax_Mmin"
                        "N/A",               # "Mu_kNm"
                        "N/A",               # "Cuantia"
                        "N/A",               # "ϕMn"
                        "N/A"                # "Mu ≤ ɸMn"
                        )
                    treeview_flexion.item(item_id, values=new_values)
                    
            # Verificar los resultados para actualizar el mensaje del label_check
            if len(gamma_values) == 1:
            # Para 1 valor de gamma, solo verificar el primer resultado
                if cumple_resultados[0] == "Cumple":
                    cumple_diseño = "Cumple"
                else:
                    cumple_diseño = "No cumple"
                    
            elif len(gamma_values) == 3:
            # Para 3 valores de gamma, verificar si todos cumplen
                if all(cumple == "Cumple" for cumple in cumple_resultados):
                    cumple_diseño = "Cumple"
                else:
                    cumple_diseño = "No cumple"
            # Actualizar el mensaje en label_check basado en el resultado
            if cumple_diseño == "Cumple":
                # Obtener los valores de combo_flexion_fc y entry_flexion_recubrimiento
                fc_value = combo_flexion_fc.get()  # Valor de f'c
                recubrimiento_value = entry_flexion_recubrimiento.get()  # Valor de recubrimiento
                label_check.config(
                        text= f"El diseño cumple con los criterios de resistencia. "
                        f"Está bien dimensionado para soportar los momentos flexionantes "
                        f"sin superar la capacidad estructural, considerando un f'c de {fc_value} "
                        f"y un adecuado recubrimiento de {recubrimiento_value}m que garantiza la seguridad de la estructura.",
                        bg="lightgreen")  # Cambia el color de fondo a verde
                
            elif cumple_diseño == "No cumple":
                label_check.config(
                text="El diseño NO cumple. Podrían ocurrir problemas como deformaciones, "
                    "grietas o fallas por flexión. Se recomienda reconsiderar los materiales "
                    "(f'c) o rediseñar la sección transversal para aumentar la capacidad de momento.",
                    bg="lightcoral")  # Cambia el color de fondo a rojo
                
            
        boton_verificar= ttk.Button(tab1,text="Verificar datos",command=verificar_datos)
        boton_verificar.place(x=210,y=140)
        
        # Función para evitar el redimensionamiento de las columnas
        def no_resize(event):
        # Restaurar el tamaño original de las columnas
            for col in treeview["columns"]:
                treeview.column(col, width=94)
        
        # Vincular el evento para evitar la acción de cambiar el tamaño de las columnas
        treeview.bind("<ButtonRelease-1>", no_resize)
        
        # Mostrar el notebook_tabla dentro del frame
        notebook_tabla.pack(expand=True, fill="both")
        
        entry_flexion_recubrimiento.bind("<FocusOut>", lambda event: calcular_Rn_al_modificar_recubrimiento(
        event, combo_flexion_Mu, entry_flexion_base, entry_flexion_profundidad, entry_flexion_recubrimiento, combo_flexion_Rn,
        label_Resistencia_Rn,label_Rn2))
        
        
        # Crear radiobutton No.3 No.4 con comandos para actualizar el valor
        radiobutton_flexion_No3 = tk.Radiobutton(labelframe_flexion_info, text="No.3", 
                                                    variable=estado_estribo,
                                                    value="9.5", 
                                                    command=lambda: actualizar_label_estribo(9.5))
        radiobutton_flexion_No3.place(x=150, y=45)

        radiobutton_flexion_No4 = tk.Radiobutton(labelframe_flexion_info, text="No.4", 
                                                    variable=estado_estribo,
                                                    value="12.7", 
                                                    command=lambda: actualizar_label_estribo(12.7))
        radiobutton_flexion_No4.place(x=250, y=45)

entry_prueba_base= tk.Entry(ventana)
#entry_prueba_base.place(x=500,y=700)

entry_prueba_recubrimiento = tk.Entry(ventana)
#entry_prueba_recubrimiento.place(x=500,y=730)

def calcular_Rn_al_modificar_recubrimiento(event=None, combo_flexion_Mu=None, entry_flexion_base=None, entry_flexion_profundidad=None, entry_flexion_recubrimiento=None, combo_flexion_Rn=None,
                                           label_Resistencia_Rn=None,label_Rn2=None):
    try:
        # Leer el valor de b desde el Entry (base)
        b = float(entry_flexion_base.get())
        
        # Leer el valor de d desde el Entry (profundidad)
        d = float(entry_flexion_profundidad.get())
        
        # Leer el valor del recubrimiento 
        recubrimiento = float(entry_flexion_recubrimiento.get())
        
        # Validar que d sea positivo
        if d <= 0:
            raise ValueError("La profundidad (d) debe ser positiva.")
        
        # Leer los valores de Mu desde el combobox (como lista de texto)
        mu_values = combo_flexion_Mu['values']
        mu_numeric_values = []
        
        for mu in mu_values:
            try:
                # Extraer el valor numérico, ignorando "kNm"
                mu_numeric_values.append(float(mu.split()[0]))
            except ValueError:
                pass  # Ignorar valores no válidos
        
        # Constante de diseño
        phi = 0.90
        
        # Calcular Rn para cada Mu
        rn_values = []
        for mu in mu_numeric_values:
            try:
                rn = mu / (phi * b * (d ** 2))  
                rn_values.append(f"{rn:.4f}")  
            except ZeroDivisionError:
                rn_values.append("Error")  
        
        # Actualizar el combo_flexion_Rn con los resultados
        combo_flexion_Rn['values'] = rn_values
        
        # Si hay resultados, seleccionar el primero por defecto
        if rn_values:
            combo_flexion_Rn.set(rn_values[0])
        else:
            combo_flexion_Rn.set("")  
        
        # Actualizar el label_Resistencia_Rn con el valor calculado (primer valor de la lista)
        if rn_values:
            label_Resistencia_Rn.config(text=f"{rn_values[0]}")  
        else:
            label_Resistencia_Rn.config(text="Rn: Error")  
        
        # Actualizar el label_Rn2 con el segundo valor de la lista (si existe)
        if len(rn_values) > 1:
            label_Rn2.config(text=f"{rn_values[1]}")  
        else:
            label_Rn2.config(text="Rn2: No disponible") 

    except ValueError as e:
        # Manejar entradas no válidas
        combo_flexion_Rn['values'] = []
        combo_flexion_Rn.set("")
        label_Resistencia_Rn.config(text="Rn: Error")  
        label_Rn2.config(text="Rn2: Error")
        print(f"Error: {e}")

def actualizar_β1(
    event, 
    combo_flexion_fc, 
    combo_flexion_fy, 
    entry_flexion_β1, 
    entry_flexion_cuantia_min, 
    entry_flexion_cuantia_max, 
    combo_flexion_Rn, 
    combo_flexion_𝞀req, 
    combo_flexion_Asreq,  
    entry_flexion_base,   
    entry_flexion_profundidad,
    Barras_refuerzo,  
    label_fc,
    label_cuantia_minima,  
    label_cuantia_maxima,
    label_beta1,
    label_cuantia_requerida,  
    label_acero_requerido,
    label_As2,  
    label_req_C2  
):
    
    # Obtener los valores de f'c y fy desde los combos
    fc_value = combo_flexion_fc.get()
    fy_value = combo_flexion_fy.get()
    
    # Actualizar el label_fc con el valor de f'c seleccionado
    label_fc.config(text=f"{fc_value}")  
    
    # Convertir los valores a solo los números (ignorando "MPa")
    try:
        fc_numeric = float(fc_value.split()[0])  # Extraer el número antes de "MPa"
    except ValueError:
        fc_numeric = 0.0

    try:
        fy_numeric = float(fy_value.split()[0])  # Extraer el número antes de "MPa"
    except ValueError:
        fy_numeric = 0.0

    # Asignar el valor de β1 basado en f'c
    if fc_numeric == 17.5 or fc_numeric == 21 or fc_numeric == 24.5 or fc_numeric == 28:
        β1 = 0.85
    elif fc_numeric == 35:
        β1 = 0.80
    elif fc_numeric == 42:
        β1 = 0.75
    else:
        β1 = None

    if β1 is not None:
        entry_flexion_β1.delete(0, tk.END)
        entry_flexion_β1.insert(0, f"{β1:.2f}")
        # Actualizar el valor de β1 en el label_beta1
        label_beta1.config(text=f"{β1:.2f}")
    else:
        entry_flexion_β1.delete(0, tk.END)
        label_beta1.config(text="No Definido")

    # Calcular cuantía mínima: 𝞀min = (0.25 * sqrt(f'c)) / fy
    if fc_numeric > 0 and fy_numeric > 0:
        cuantia_min = max((0.25 * math.sqrt(fc_numeric)) / fy_numeric, 0.0033)
        entry_flexion_cuantia_min.delete(0, tk.END)
        entry_flexion_cuantia_min.insert(0, f"{cuantia_min:.4f}")
        # Actualizar el valor de cuantía mínima en el label_cuantia_minima
        label_cuantia_minima.config(text=f"{cuantia_min:.4f}")
    else:
        entry_flexion_cuantia_min.delete(0, tk.END)
        label_cuantia_minima.config(text="No Definida")

    # Calcular cuantía máxima: 𝞀max = 0.85 * β1 * (f'c / fy) * 0.63
    if β1 is not None and fc_numeric > 0 and fy_numeric > 0:
        cuantia_max = 0.85 * β1 * (fc_numeric / fy_numeric) * 0.63
        entry_flexion_cuantia_max.delete(0, tk.END)
        entry_flexion_cuantia_max.insert(0, f"{cuantia_max:.4f}")
        # Actualizar el valor de cuantía máxima en el label_cuantia_maxima
        label_cuantia_maxima.config(text=f"{cuantia_max:.4f}")
    else:
        entry_flexion_cuantia_max.delete(0, tk.END)
        label_cuantia_maxima.config(text="No Definida")

    # Obtener los valores de Rn desde el combo
    rn_values = combo_flexion_Rn['values']

    # Calcular cuantía requerida: 𝞀requerida = 0.85*f'c/fy * (1 - sqrt(1 - 2*Rn*0.001 / (0.85*f'c)))
    cuantia_req_values = []
    for rn_value in rn_values:
        try:
            rn_numeric = float(rn_value)
            if fc_numeric > 0 and fy_numeric > 0:
                cuantia_req = 0.85 * fc_numeric / fy_numeric * (
                    1 - math.sqrt(1 - 2 * rn_numeric * 0.001 / (0.85 * fc_numeric))
                )
                cuantia_req_values.append(f"{cuantia_req:.4f}")
        except (ValueError, ZeroDivisionError):
            cuantia_req_values.append("Error")

    # Actualizar el combo_flexion_𝞀req con los resultados
    combo_flexion_𝞀req['values'] = cuantia_req_values

    # Seleccionar el primer valor si hay resultados
    if cuantia_req_values:
        combo_flexion_𝞀req.set(cuantia_req_values[0])
    else:
        combo_flexion_𝞀req.set("")

    # Cálculo del acero requerido As = 𝞀req × base_As × d_As
    try:
        base_As = float(entry_flexion_base.get())
        d_As = float(entry_flexion_profundidad.get())
    except ValueError:
        base_As, d_As = 0.0, 0.0

    acero_req_values = []
    for cuantia_req_str in cuantia_req_values:
        try:
            cuantia_req = float(cuantia_req_str)
            As = cuantia_req * (base_As * 1000) * (d_As * 1000)
            acero_req_values.append(f"{As:.3f}")
        except ValueError:
            acero_req_values.append("Error")

    # Actualizar el combo_flexion_Asreq con los resultados
    combo_flexion_Asreq['values'] = acero_req_values

    # Seleccionar el primer valor si hay resultados
    if acero_req_values:
        combo_flexion_Asreq.set(acero_req_values[0])
    else:
        combo_flexion_Asreq.set("")
        
    # ACTUALIZAR 'Barras_refuerzo' CON LOS RESULTADOS DE 'combo_flexion_Asreq'
    Barras_refuerzo['values'] = acero_req_values
    if acero_req_values:
        Barras_refuerzo.set(acero_req_values[0])  # Seleccionar el primer valor si hay resultados
    else:
        Barras_refuerzo.set("")
    
    # Actualizar el valor de acero requerido en el label_acero_requerido (completar con el valor de combo_flexion_Asreq)
    if acero_req_values:
        label_acero_requerido.config(text=f"{acero_req_values[0]}")
    else:
        label_acero_requerido.config(text="No Definido")

    # Actualizar el valor de cuantía requerida en el label_cuantia_requerida (completar con el valor de combo_flexion_𝞀req)
    if cuantia_req_values:
        label_cuantia_requerida.config(text=f"{cuantia_req_values[0]}")
    else:
        label_cuantia_requerida.config(text="No Definida")
    
    # ACTUALIZAR label_As2 CON EL SEGUNDO VALOR DE 'acero_req_values' 
    if len(acero_req_values) > 1:
        label_As2.config(text=f"{acero_req_values[1]}")
    else:
        label_As2.config(text="No Definido")

    # ACTUALIZAR label_req_C2 CON EL SEGUNDO VALOR DE 'cuantia_req_values' 
    if len(cuantia_req_values) > 1:
        label_req_C2.config(text=f"{cuantia_req_values[1]}")
    else:
        label_req_C2.config(text="No Definido")


# Función para actualizar las dimensiones
def actualizar_dimensiones(event):
    global entry_flexion_base, entry_flexion_altura, entry_flexion_VG, entry_flexion_recubrimiento, entry_flexion_profundidad,label_h
    global label_recubrimiento,label_altura_efectiva
    
    
    vg_text = entry_flexion_VG.get()

    if "X" in vg_text:
        try:
            
            dimensiones_1 = vg_text.split("X")
            base_1 = float(dimensiones_1[0].strip().split()[1])  
            altura_1 = float(dimensiones_1[1].strip())           
            
            # Multiplicar por 0.01 para convertir a metros
            base_resultado = base_1 * 0.01
            altura_resultado = altura_1 * 0.01
            
            
            base_resultado = round(base_resultado, 2)
            altura_resultado = round(altura_resultado, 2)
            
            
            entry_flexion_base.delete(0, tk.END)
            entry_flexion_base.insert(0, str(base_resultado))
            
            entry_flexion_altura.delete(0, tk.END)
            entry_flexion_altura.insert(0, str(altura_resultado))
            
            
            label_h.config(text=f"{altura_resultado:.2f} m")
            
            recubrimiento_1 = float(entry_flexion_recubrimiento.get()) if entry_flexion_recubrimiento.get() else 0.0
            
            
            recubrimiento_cm = recubrimiento_1 * 100
            label_recubrimiento.config(text=f"{recubrimiento_cm:.2f} cm")
            
            
            altura_d = (altura_1 - recubrimiento_cm) * 0.01
            
            
            altura_d = round(altura_d, 2)
            
            
            entry_flexion_profundidad.delete(0, tk.END)
            entry_flexion_profundidad.insert(0, str(altura_d))
            
            
            label_altura_efectiva.config(text=f"{altura_d:.2f} m")
            
        except ValueError:
            
            pass


# Función para cerrar la ventana y permitir abrirla nuevamente
def cerrar_ventana_barras():
    global ventana_refuerzo_abierta
    ventana_refuerzo_abierta = False
    ventana_refuerzo.destroy()

# Diccionario con la información de las barras de refuerzo
barras_info_refuerzo = {
    "Barra No.2": {"diametro_pulg": "1/4", "diametro_mm": 6.4, "area_mm2": 32, "perimetro_mm": 20.0, "masa_kg_m": 0.250},
    "Barra No.3": {"diametro_pulg": "3/8", "diametro_mm": 9.5, "area_mm2": 71, "perimetro_mm": 30.0, "masa_kg_m": 0.560},
    "Barra No.4": {"diametro_pulg": "1/2", "diametro_mm": 12.7, "area_mm2": 129, "perimetro_mm": 40.0, "masa_kg_m": 0.994},
    "Barra No.5": {"diametro_pulg": "5/8", "diametro_mm": 15.9, "area_mm2": 199, "perimetro_mm": 50.0, "masa_kg_m": 1.552},
    "Barra No.6": {"diametro_pulg": "3/4", "diametro_mm": 19.1, "area_mm2": 284, "perimetro_mm": 60.0, "masa_kg_m": 2.235},
    "Barra No.7": {"diametro_pulg": "7/8", "diametro_mm": 22.2, "area_mm2": 387, "perimetro_mm": 70.0, "masa_kg_m": 3.042},
    "Barra No.8": {"diametro_pulg": "1", "diametro_mm": 25.4, "area_mm2": 510, "perimetro_mm": 80.0, "masa_kg_m": 3.973},
    "Barra No.9": {"diametro_pulg": "1-1/8", "diametro_mm": 28.7, "area_mm2": 645, "perimetro_mm": 90.0, "masa_kg_m": 5.060},
    "Barra No.10": {"diametro_pulg": "1-1/4", "diametro_mm": 32.3, "area_mm2": 819, "perimetro_mm": 101.3, "masa_kg_m": 6.404},
    "Barra No.11": {"diametro_pulg": "1-3/8", "diametro_mm": 35.8, "area_mm2": 1006, "perimetro_mm": 112.5, "masa_kg_m": 7.907},
    "Barra No.14": {"diametro_pulg": "1-3/4", "diametro_mm": 43.0, "area_mm2": 1452, "perimetro_mm": 135.1, "masa_kg_m": 11.38},
    "Barra No.18": {"diametro_pulg": "2-1/4", "diametro_mm": 57.3, "area_mm2": 2581, "perimetro_mm": 180.1, "masa_kg_m": 20.24}
}

# Variables globales
ventana_refuerzo_abierta = False
ventana_refuerzo = None
combo_barra = None


# Declarar etiquetas globales para la información de la barra
label_info_barra = None
entry_Ab = None

def actualizar_info_barra():
    global combo_barra, label_info_barra, entry_Ab
    global entry_A , entry_B
    global label_barra, label_info_b, label_area_barra, label_Øbarras

    barra_seleccionada = combo_barra.get()

    
    if barra_seleccionada != "Seleccione una barra":
        
        info_barra = barras_info_refuerzo[barra_seleccionada]
        
        
        info_texto = (
            f"Barra No.{barra_seleccionada[9:]}:\n\n"
            f"Diámetro: {info_barra['diametro_pulg']} pulgadas ({info_barra['diametro_mm']} mm)\n"
            f"Área: {info_barra['area_mm2']} mm²\n"
            f"Perímetro: {info_barra['perimetro_mm']} mm\n"
            f"Masa: {info_barra['masa_kg_m']} kg/m"
        )
        
        
        label_info_barra.config(text=info_texto)
        
        area_barra = info_barra['area_mm2']  
        
        # Actualizar el label con el número de barra
        label_barra.config(text=f"No.{barra_seleccionada[9:]}")
        
        # Actualizar el label con la información de la barra 
        label_info_b.config(text=info_texto)
        
        # Actualizar el área de la barra en el label_area_barra
        label_area_barra.config(text=f"{area_barra} mm²")
        
        # Actualizar el diámetro en el label_Øbarras
        diametro_mm = info_barra['diametro_mm']
        label_Øbarras.config(text=f"{diametro_mm} mm")
        
        if entry_Ab is not None:
            entry_Ab.delete(0, tk.END)  
            entry_Ab.insert(0, str(area_barra))  
        
        # Llamar a la función para actualizar los cálculos del número de barras
        calcular_no_barras_refuerzo()
        # Llamar a la función para actualizar entry_A
        if entry_A is not None:  # Asegúrate de que entry_A esté inicializado
            calcular_base_requerida(entry_A)  # Pasar entry_A a la función
        else:
            print("Error: entry_A no está inicializado correctamente.")


def calcular_no_barras_refuerzo():
    global entry_Ab, combo_As, combo_No_barras, combo_C, combo_barra,entry_D, combo_n, combo_dp,entry_A, entry_B, combo_b
    global Barras_traccion,label_barra_flexion, label_barra_flexion1,label_A_1,label_C_1,label_D_1,label_n_1,label_dp_1
    global label_base_req, label_base_req1,label_No_barras_flexion
    # Obtener la lista actualizada de valores de combo_As
    As_items = combo_As['values']

    try:
        As_values = [float(item) for item in As_items if item.strip()]
    except ValueError:
        As_values = []

    try:
        Ab = float(entry_Ab.get())
    except ValueError:
        Ab = 0

    if Ab == 0 or not As_values:
        combo_No_barras['values'] = []
        combo_No_barras.set("")
        combo_C['values'] = []
        combo_C.set("")
        entry_D.delete(0, tk.END)
        entry_D.insert(0, "N/A")
        combo_n['values'] = []
        combo_n.set("")
        combo_dp['values'] = []
        combo_dp.set("")
        combo_b['values'] = []
        combo_b.set("")
        Barras_traccion['values'] = []  
        Barras_traccion.set("")  
        label_barra_flexion.config(text="")  
        label_barra_flexion1.config(text="")  
        label_A_1.config(text="")  
        label_C_1.config(text="")  
        label_D_1.config(text="")  
        label_n_1.config(text="")  
        label_dp_1.config(text="")  
        label_base_req.config(text="")  
        label_base_req1.config(text="")
        label_No_barras_flexion.config(text="")
        return

    barra_seleccionada = combo_barra.get()
    barra_num = barra_seleccionada.split("No.")[-1].strip() if "No." in barra_seleccionada else "N/A"
    
    # Actualizar el combobox combo_No_barras y Barras_traccion
    if combo_No_barras.get():  # Si hay algo seleccionado en combo_No_barras
        # Asignar los mismos valores de combo_No_barras a Barras_traccion
        Barras_traccion['values'] = combo_No_barras['values']
        Barras_traccion.set(combo_No_barras.get())  # Seleccionar el mismo valor en Barras_traccion
    else:
        Barras_traccion['values'] = []  # Limpiar valores si no hay selección
    
    # Actualizar los labels con los primeros dos valores de la lista de combo_No_barras
    no_barras_values = combo_No_barras['values']
    
    if no_barras_values:
        # Asignar el primer valor de la lista a label_barra_flexion
        label_barra_flexion.config(text=f"As[-]:{no_barras_values[0]}")
        label_No_barras_flexion.config(text=f"{no_barras_values[0]}")  # Actualización aquí
        
        # Asignar el segundo valor de la lista a label_barra_flexion1 (si existe)
        if len(no_barras_values) > 1:
            label_barra_flexion1.config(text=f"As[+]:{no_barras_values[1]}")
        else:
            label_barra_flexion1.config(text="")  # Si no hay segundo valor, dejarlo vacío
        
        
    def redondear(val):
        if abs(val - 0) < 0.2 or abs(val - 1.0) < 0.2:
            return 2
        elif 0.1 < val < 1.0:
            return 2
        elif val % 1 > 0:
            return math.ceil(val)
        return val
    
    def calcular_separacion_minima(numero_barra):
        """
        Calcula la separación mínima según las condiciones:
        - Para barras #2 a #8: 25 mm.
        - Para barras mayores a #8: diámetro de la barra.
        """
        try:
            diametro_mm = obtener_diametro_mm(numero_barra)
            if 2 <= numero_barra <= 8:
                return 25  # Separación mínima fija
            elif numero_barra > 8:
                return diametro_mm  # Igual al diámetro de la barra
            else:
                return 0  # Valor predeterminado en caso de error
        except Exception as e:
            print(f"Error calculando separación mínima: {e}")
            return 0
        
        
    No_barras_refuerzo_values = [redondear(As / Ab) for As in As_values]
    # Asegurar que el valor entero se muestre correctamente
    resultado_formateado = [f"{int(value)}#{barra_num}" if isinstance(value, float) and value.is_integer() else f"{value}#{barra_num}" for value, barra_num in zip(No_barras_refuerzo_values, [barra_num] * len(No_barras_refuerzo_values))]
    
    combo_No_barras['values'] = resultado_formateado
    if resultado_formateado:
        combo_No_barras.set(resultado_formateado[0])
        # Agregar "mm" al formato de los valores en combo_C
        combo_C['values'] = [f"{calcular_radio_doblado(int(entry.split('#')[-1]))} mm" for entry in resultado_formateado]
        combo_C.set(combo_C['values'][0])
        
        # Calcular la separación mínima para la primera barra y mostrarla en entry_D
        try:
            separacion_minima = calcular_separacion_minima(int(barra_num))
            entry_D.delete(0, tk.END)
            entry_D.insert(0, f"{separacion_minima} mm")
        except ValueError:
            entry_D.delete(0, tk.END)
            entry_D.insert(0, "N/A")
        
        # Extraer el primer número de cada entrada en combo_No_barras y actualizar combo_n
        numeros_primer_digito = [entry.split('#')[0] for entry in resultado_formateado]
        combo_n['values'] = numeros_primer_digito
        if numeros_primer_digito:
            combo_n.set(numeros_primer_digito[0])
        
        # Calcular y actualizar los diámetros de las barras longitudinales en combo_dp
        diametros_barras = [
            f"{obtener_diametro_mm(int(entry.split('#')[-1]))} mm" for entry in resultado_formateado
        ]
        combo_dp['values'] = diametros_barras
        if diametros_barras:
            combo_dp.set(diametros_barras[0])
            
    try:
    # Validar y obtener A
        entry_a_val = entry_A.get().replace(" mm", "").strip()
        A = float(entry_a_val) if entry_a_val else 0

    # Validar y obtener B
        entry_b_val = entry_B.get().replace(" mm", "").strip()
        B = float(entry_b_val) if entry_b_val else 0

    # Validar y obtener C
        combo_c_val = combo_C.get().replace(" mm", "").strip()
        C = float(combo_c_val) if combo_c_val else 0

    # Validar y obtener D
        entry_d_val = entry_D.get().replace(" mm", "").strip()
        D = float(entry_d_val) if entry_d_val else 0

    # Obtener dp del primer valor del combo_dp
        dp_val_clean = combo_dp.get().replace(" mm", "").strip()
        dp = float(dp_val_clean) if dp_val_clean else 0
        
    # Actualizar los labels con los nuevos valores
        label_A_1.config(text=f"{A} mm")
        label_C_1.config(text=f"{C} mm")
        label_D_1.config(text=f"{D} mm")
        label_n_1.config(text=f"{numeros_primer_digito[0] if numeros_primer_digito else 'N/A'}")
        label_dp_1.config(text=f"{dp} mm")

    # Lista para almacenar resultados de base requerida (uno por cada n)
        base_requerida_vals = []

    # Iterar sobre los valores en combo_n
        for combo_n_val in combo_n['values']:
            try:
            # Obtener el valor actual de n
                n = int(combo_n_val.strip()) if combo_n_val.strip().isdigit() else 1

            # Calcular la base requerida
                base_requerida = 2 * (A + B + C) + (n - 1) * (D + dp)
                base_requerida_m = base_requerida / 1000  # Convertir a metros

            # Agregar el resultado formateado a la lista
                base_requerida_vals.append(f"{base_requerida_m:.2f} m")
            except ValueError as n_error:
                pass

    # Actualizar el combo_b con la lista calculada
        if base_requerida_vals:
            combo_b['values'] = base_requerida_vals
            combo_b.set(base_requerida_vals[0])
        else:
            combo_b['values'] = ["N/A"]
            combo_b.set("N/A")
        
    # Actualizar los labels de base requerida
        if base_requerida_vals:
            label_base_req.config(text=f"{base_requerida_vals[0]}")
            if len(base_requerida_vals) > 1:
                label_base_req1.config(text=f"{base_requerida_vals[1]}")
            else:
                label_base_req1.config(text="")  # Si no hay segundo valor, dejarlo vacío
        else:
            label_base_req.config(text="N/A")
            label_base_req1.config(text="N/A")
    except ValueError as e:
        combo_b['values'] = ["N/A"]
        combo_b.set("N/A")
        label_base_req.config(text="N/A")
        label_base_req1.config(text="N/A")


def calcular_radio_doblado(numero_barra):
    try:
        # Asignar un valor por defecto
        radio = 0  

        # Obtener el diámetro de la barra
        diametro_mm = obtener_diametro_mm(numero_barra)

        # Validación de que se encontró el diámetro
        if diametro_mm == 0:
            raise ValueError("No se encontró información para el número de barra proporcionado")

        # Aplicar las condiciones para el cálculo
        if 2 <= numero_barra <= 5:
            # Para barras de #2 a #5: el radio es dos veces el diámetro
            radio = 2 * diametro_mm
        elif 6 <= numero_barra <= 8:
            # Para barras de #6 a #8: el radio es tres veces el diámetro
            radio = 3 * diametro_mm
        elif numero_barra > 8:
            # Para barras mayores a #8: el radio es igual al diámetro
            radio = diametro_mm
        else:
            # Caso seguro por si el número de barra es inválido
            radio = 0
    except Exception as e:
        print(f"Error calculando radio: {e}")
        radio = 0  # Asegurar un valor seguro en caso de error

    return round(radio, 2)  # Redondear el resultado a dos decimales

def obtener_diametro_mm(num_barra):
    """
    Devuelve el diámetro en mm basado en el número de barra.
    """
    clave = f"Barra No.{num_barra}"
    if clave in barras_info_refuerzo:
        return barras_info_refuerzo[clave]["diametro_mm"]
    else:
        print(f"No se encontró información para: {clave}")
    return 0


def insertar_todos_los_datos_treeview():
    # Obtener los valores seleccionados de los combobox (solo los números)
    valores_mu_refuerzo = [valor.split()[0] for valor in Momento_Mu['values']]  # Obtener solo los números (eliminamos "kNm")
    valores_combo_as = combo_As['values']  # Obtener todos los valores disponibles en combo_As
    valores_combo_no_barras = combo_No_barras['values']  # Obtener todos los valores disponibles en combo_No_barras
    valores_combo_b = combo_b['values']  # Obtener todos los valores disponibles en combo_b

    # Limpiar las filas del Treeview antes de agregar nuevos datos
    for item in treeview_refuerzo.get_children():
        treeview_refuerzo.delete(item)

    # Asegurarse de que el número de filas en todas las listas coincida o completar con vacío si no es así
    max_len = max(len(valores_mu_refuerzo), len(valores_combo_as), len(valores_combo_no_barras), len(valores_combo_b))  # Tomamos el máximo de las listas para evitar errores
    
    # Insertar los datos en el Treeview
    for i in range(max_len):
        # Si no hay suficientes valores en combo_As, usar un valor vacío
        combo_as_value = valores_combo_as[i] if i < len(valores_combo_as) else ""
        
        # Si no hay suficientes valores en combo_No_barras, usar un valor vacío
        combo_no_barras_value = valores_combo_no_barras[i] if i < len(valores_combo_no_barras) else ""
        
        # Si no hay suficientes valores en valores_mu_refuerzo, usar un valor vacío
        mu_refuerzo_value = valores_mu_refuerzo[i] if i < len(valores_mu_refuerzo) else ""
        
        # Si no hay suficientes valores en combo_b, usar un valor vacío
        combo_b_value = valores_combo_b[i] if i < len(valores_combo_b) else ""

        # Insertar los valores en el Treeview (columna 1 para Momento_Mu, columna 2 para combo_As, columna 3 para combo_No_barras y columna 4 para combo_b)
        treeview_refuerzo.insert("", "end", values=(mu_refuerzo_value, combo_as_value, combo_no_barras_value, combo_b_value))
        
        
        try:
            base_diseño = float(entry_prueba_base.get())  
            
        except ValueError:
            base_diseño = 0  
            

        
        if combo_b_value.strip() == "":  
            base_requerida = 0  
            
        else:
            
            base_requerida_str = re.sub(r"[^\d.]", "", combo_b_value)  
            try:
                base_requerida = float(base_requerida_str)  
                
            except ValueError:
                base_requerida = 0  
                
        
        # Comparación de las bases y actualización de los labels con los iconos
        if base_requerida < base_diseño:
            label_check_As.config(
                text=f"La base requerida es menor al del diseño {base_diseño} m, entonces cumple. ",
                
            )
            label_check_info.config(
                text="Ya asignaste los aceros para cada Mu, ahora continúa con los de compresión."
            )
            label_icon.config(image=icon_check_on)
        else:
            label_check_As.config(
                text=f"La base requerida es mayor al del diseño de {base_diseño} m. Por lo tanto, no cumple.",
            )
            label_icon.config(image=icon_check_off)




def abrir_ventana_barras_refuerzo():
    global ventana_refuerzo_abierta, ventana_refuerzo, combo_barra
    global label_info_barra, Barras_refuerzo, entry_Ab, combo_As, combo_No_barras, entry_A
    global entry_B , combo_C , entry_D , combo_n, combo_dp, combo_b,label_No_barras_flexion
    

    # Verificar si la ventana ya está abierta
    if not ventana_refuerzo_abierta:
        # Marcar que la ventana está abierta
        ventana_refuerzo_abierta = True

        # Crear la nueva ventana
        ventana_refuerzo = tk.Toplevel()
        ventana_refuerzo.title("Barras de refuerzo")
        ventana_refuerzo.geometry("750x480")
        ventana_refuerzo.resizable(False, False)  
        ventana_refuerzo.attributes('-topmost', True)
        
        # Crear el LabelFrame principal
        labelframe_refuerzo = tk.LabelFrame(ventana_refuerzo, text="Barras de refuerzo")
        labelframe_refuerzo.place(x=20, y=20, width=360, height=400)

        # Etiqueta para pedir la selección de la barra
        label_refuerzo = tk.Label(labelframe_refuerzo, text="Seleccione la designación de la barra:")
        label_refuerzo.place(x=70, y=10)
        
        # Crear el combobox con las barras
        valores_barras = [
            "Barra No.2", "Barra No.3", "Barra No.4", "Barra No.5", "Barra No.6",
            "Barra No.7", "Barra No.8", "Barra No.9", "Barra No.10", "Barra No.11",
            "Barra No.14", "Barra No.18"
        ]
        
        combo_barra = ttk.Combobox(labelframe_refuerzo, values=["Seleccione una barra"] + valores_barras)
        combo_barra.place(x=100, y=40)
        combo_barra.set("Seleccione una barra")
        
        # Crear el LabelFrame para mostrar la información de la barra seleccionada
        labelframe_barras = tk.LabelFrame(labelframe_refuerzo, text="Información de la barra")
        labelframe_barras.place(x=50, y=70, width=250, height=170)
        
        # Crear una etiqueta para mostrar toda la información formateada de la barra
        label_info_barra = tk.Label(labelframe_barras, text="", anchor="w", justify="left")
        label_info_barra.pack(fill="both", padx=5, pady=15)
        
        label_calculo_barras = tk.Label(labelframe_refuerzo,text="Cálculo número de barras longitudinal: ")
        label_calculo_barras.place(x=70,y=250)
        
        label_As_barras = tk.Label(labelframe_refuerzo,text="As: ")
        label_As_barras.place(x=80,y=280)
        
        label_Ab_barras = tk.Label(labelframe_refuerzo,text="Ab: ")
        label_Ab_barras.place(x=80,y=310)
        
        label_No_barras = tk.Label(labelframe_refuerzo,text="#barras: ")
        label_No_barras.place(x=70,y=340)
        
        # Crear combobox As, Ab , # barras
        combo_As = ttk.Combobox(labelframe_refuerzo)
        combo_As.place(x=125,y=280,width=120)
        combo_As.set("Seleccionar")
        
        entry_Ab = tk.Entry(labelframe_refuerzo)
        entry_Ab.place(x=125,y=310,width=120)
        
        combo_No_barras = ttk. Combobox(labelframe_refuerzo)
        combo_No_barras.place(x=125,y=340,width=120)
        
        label_No_barras_flexion = tk.Label(labelframe_refuerzo,text="",bd=2,relief="sunken")
        label_No_barras_flexion.place(x=250,y=340,width=100)
        
        labelframe_requisito = tk.LabelFrame(ventana_refuerzo,text="Requisito mínimo ACI")
        labelframe_requisito.place(x=390,y=20,width=340,height=400)
        
        label_requisito = tk.Label(labelframe_requisito,text="Revisar b=(ancho, base sección transversal)")
        label_requisito.place(x=50,y=10)
        
        label_formula = tk.Label(labelframe_requisito,text="b= 2[A+B+C]+[n-1][D+dp]",bd=2,relief="sunken")
        label_formula.place(x=90,y=35)
        
        labelframe_formula = tk.LabelFrame(labelframe_requisito,text="")
        labelframe_formula.place(x=20,y=70,width=295, height=170)
        
        label_A = tk.Label(labelframe_requisito,text="A:")
        label_A.place(x=10,y=260)
        entry_A = tk.Entry(labelframe_requisito)
        entry_A.place(x=40,y=260,width=80)
        
        label_B = tk.Label(labelframe_requisito,text="B:")
        label_B.place(x=10,y=290)
        entry_B = tk.Entry(labelframe_requisito)
        entry_B.place(x=40,y=290,width=80)
        
        label_C = tk.Label(labelframe_requisito,text="C:")
        label_C.place(x=10,y=320)
        combo_C = ttk.Combobox(labelframe_requisito)
        combo_C.place(x=40,y=320,width=80)
        
        label_D = tk.Label(labelframe_requisito,text="D:")
        label_D.place(x=190,y=260)
        entry_D = tk.Entry(labelframe_requisito)
        entry_D.place(x=220,y=260,width=80)
        
        label_n = tk.Label(labelframe_requisito,text="n:")
        label_n.place(x=190,y=290)
        combo_n = ttk.Combobox(labelframe_requisito)
        combo_n.place(x=220,y=290,width=80)
        
        label_dp = tk.Label(labelframe_requisito,text="dp:")
        label_dp.place(x=190,y=320)
        combo_dp = ttk.Combobox(labelframe_requisito)
        combo_dp.place(x=220,y=320,width=80)
        
        combo_b = ttk.Combobox(labelframe_requisito)
        #combo_b.place(x=120,y=370,width=80)
        
        
        # Crear el Canvas dentro de labelframe_formula
        Canvas_refuerzo = tk.Canvas(labelframe_formula,width=287, height=147)
        Canvas_refuerzo.place(x=0, y=0)  
        
        # Crear las barras de desplazamiento
        scrollbar_vertical = tk.Scrollbar(labelframe_formula, orient="vertical", command=Canvas_refuerzo.yview)
        scrollbar_vertical.place(x=273, y=0, height=147)
        
        scrollbar_horizontal = tk.Scrollbar(labelframe_formula, orient="horizontal", command=Canvas_refuerzo.xview)
        scrollbar_horizontal.place(x=0, y=147, width=290)
        
        # Vincular las scrollbars al Canvas
        Canvas_refuerzo.config(yscrollcommand=scrollbar_vertical.set, xscrollcommand=scrollbar_horizontal.set)
        
        # Crear la información que se mostrará en el Canvas
        text_refuerzo = """𝐛 = 𝟐[𝐀 + 𝐁 + 𝐂] + [𝐧 − 𝟏][𝐃 + 𝐝𝐩]
        • A = 40mm mínimo para estribos (ACI 20.5.1)
        • B = diámetro del estribo: 9.5mm para No. 3 // 12.7mm para No. 4
        • C = radio de doblado (ACI Tabla 25.3.2),
        2db (para No. 3 a 5) o 3db (para No. 6 a 8)
        • D = espaciamiento mínimo (ACI 25.2.1): 25mm, db.
        - Nota 1: D=25mm para barras No.8 y menores / D=db para barras No.9 y mayores)
        - Nota 2: Cuando hay diferentes diámetros, D = 1/2db de la barra mayor + 1/2db de la barra menor.
        • n = # de barras por refuerzo longitudinal
        • dp = Diámetro de las barras de refuerzo longitudinal"""
        
        # Crear un contenedor de texto en el Canvas y obtener el tamaño del texto
        text_id = Canvas_refuerzo.create_text(5, 5, anchor="nw", text=text_refuerzo, fill="black")
        # Función para actualizar el área de desplazamiento del Canvas
        def update_scrollregion(event=None):
            bbox = Canvas_refuerzo.bbox("all")  # Obtener el área ocupada por el contenido del Canvas
            if bbox:
        # Añadir un margen adicional de 100 píxeles a las coordenadas del área
                Canvas_refuerzo.config(scrollregion=(0, 0, bbox[2] + 100, bbox[3] + 30))
        
        # Actualizar el área de desplazamiento después de crear el texto
        Canvas_refuerzo.bind("<Configure>", update_scrollregion)
        
        
        Canvas_refuerzo.config(scrollregion=Canvas_refuerzo.bbox("all"))
        
        
        agregar_lista = ttk.Button(ventana_refuerzo,text="Agregar datos",command=insertar_todos_los_datos_treeview)
        agregar_lista.place(x=230,y=435,width=100)
        
        aceptar_refuerzo= ttk.Button(ventana_refuerzo,text="Aceptar",command=cerrar_ventana_barras)
        aceptar_refuerzo.place(x=400,y=435,width=100)
        
        
        if Barras_refuerzo is not None:
            combo_As['values'] = Barras_refuerzo['values']
        
        
        combo_barra.bind("<<ComboboxSelected>>", lambda event: actualizar_info_barra())
        
        
        ventana_refuerzo.protocol("WM_DELETE_WINDOW", cerrar_ventana_barras)


# Función para calcular la base requerida
def calcular_base_requerida(entry_A):
    if entry_A is None:
        print("Error: entry_A no está definido")
        return  

    
    valor_prueba_recubrimiento = entry_prueba_recubrimiento.get()

    
    match = re.match(r"([\d\.]+)", valor_prueba_recubrimiento)
    if match:
        valor_numerico = float(match.group(1))
    else:
        valor_numerico = 0

    
    entry_A.delete(0, tk.END)
    entry_A.insert(0, valor_prueba_recubrimiento)
    
    
    valor_label_estribo = label_prueba_estribo.cget("text")
    
    
    if entry_B is not None:
        entry_B.delete(0, tk.END)  
        entry_B.insert(0, valor_label_estribo)  




# Variables globales
ventana_mcr = None
ventana_mcr_abierta = False
entry_base_viga = None
entry_altura_viga = None
entry_recubrimiento_viga = None
entry_d_viga = None
canvas_seccion_1 = None
combobox3 = None
canvas_seccion_2 = None
entry_As_prima = None
entry_Ab_area = None
entry_num_barra = None
spinbox_barras = None
label_mensaje3 = None

def actualizar_cotas(event=None):
    global entry_base_viga, entry_altura_viga,texto_ancho_id, texto_altura_id,canvas_seccion_1,combobox3
    
    # Obtener los valores de las entradas
    try:
        ancho_base = float(entry_base_viga.get())
        altura_peralte = float(entry_altura_viga.get())
    except ValueError:
    # Si la entrada no es válida, limpiar el canvas
        canvas_seccion_1.delete("all")
        return  # Salir si hay un error
    
    # Limpiar el canvas antes de dibujar
    canvas_seccion_1.delete("all")
    
    # Redibujar la figura
    if combobox3.get() == "Sección rectangular":
        dibujar_rectangulo(ancho_base, altura_peralte)
    elif combobox3.get() == "Sección cuadrada":
        dibujar_cuadrado(ancho_base)

def dibujar_rectangulo(ancho_base, altura_peralte):
    global figura_id, texto_ancho_id, texto_altura_id,canvas_seccion_1
    
    # Escalar dimensiones
    ancho_base_px = ancho_base * 180
    altura_peralte_px = altura_peralte * 180
    
    # Calcular coordenadas para centrar el rectángulo
    x1 = (130 - ancho_base_px) / 2
    y1 = (150 - altura_peralte_px) / 2
    x2 = x1 + ancho_base_px
    y2 = y1 + altura_peralte_px
    
    # Dibujar el rectángulo y guardar su ID
    figura_id = canvas_seccion_1.create_rectangle(x1, y1, x2, y2, fill='gray', outline='black')
    
    # Cotas del ancho (parte inferior) de canvas_seccion
    line_y = y2 + 8
    canvas_seccion_1.create_line(x1, line_y, x2, line_y, fill='black')
    canvas_seccion_1.create_line(x1, line_y, x1 + 5, line_y - 5, fill='black')
    canvas_seccion_1.create_line(x1, line_y, x1 + 5, line_y + 5, fill='black')
    canvas_seccion_1.create_line(x2, line_y, x2 - 5, line_y - 5, fill='black')
    canvas_seccion_1.create_line(x2, line_y, x2 - 5, line_y + 5, fill='black')
    texto_ancho_id = canvas_seccion_1.create_text((x1 + x2) / 2, line_y + 5, text=f"{ancho_base} m", anchor='n')
    
    # Cotas de la altura (parte lateral) de canvas_seccion
    line_x = x2 + 8
    canvas_seccion_1.create_line(line_x, y1, line_x, y2, fill='black')
    canvas_seccion_1.create_line(line_x, y1, line_x - 5, y1 + 5, fill='black')
    canvas_seccion_1.create_line(line_x, y1, line_x + 5, y1 + 5, fill='black')
    canvas_seccion_1.create_line(line_x, y2, line_x - 5, y2 - 5, fill='black')
    canvas_seccion_1.create_line(line_x, y2, line_x + 5, y2 - 5, fill='black')
    texto_altura_id = canvas_seccion_1.create_text(line_x + 10, (y1 + y2) / 2 + 15, text=f"{altura_peralte} m", anchor='w', angle=90)

def dibujar_cuadrado(tamano):
    global figura_id, texto_ancho_id, texto_altura_id,canvas_seccion_1
    
    # Escalar dimensión
    tamano_px = tamano * 180
    
    # Calcular coordenadas para centrar el cuadrado
    x1 = (130 - tamano_px) / 2
    y1 = (150 - tamano_px) / 2
    x2 = x1 + tamano_px
    y2 = y1 + tamano_px
    
    # Dibujar el cuadrado y guardar su ID
    figura_id = canvas_seccion_1.create_rectangle(x1, y1, x2, y2, fill='gray', outline='black')
    
    # Cotas del ancho (parte inferior)  de canvas_seccion
    line_y = y2 + 8
    canvas_seccion_1.create_line(x1, line_y, x2, line_y, fill='black')
    canvas_seccion_1.create_line(x1, line_y, x1 + 5, line_y - 5, fill='black')
    canvas_seccion_1.create_line(x1, line_y, x1 + 5, line_y + 5, fill='black')
    canvas_seccion_1.create_line(x2, line_y, x2 - 5, line_y - 5, fill='black')
    canvas_seccion_1.create_line(x2, line_y, x2 - 5, line_y + 5, fill='black')
    texto_ancho_id = canvas_seccion_1.create_text((x1 + x2) / 2, line_y + 5, text=f"{tamano} m", anchor='n')
    
    # Cotas de la altura (parte lateral) de canvas_seccion
    line_x = x2 + 8
    canvas_seccion_1.create_line(line_x, y1, line_x, y2, fill='black')
    canvas_seccion_1.create_line(line_x, y1, line_x - 5, y1 + 5, fill='black')
    canvas_seccion_1.create_line(line_x, y1, line_x + 5, y1 + 5, fill='black')
    canvas_seccion_1.create_line(line_x, y2, line_x - 5, y2 - 5, fill='black')
    canvas_seccion_1.create_line(line_x, y2, line_x + 5, y2 - 5, fill='black')
    texto_altura_id = canvas_seccion_1.create_text(line_x + 10, (y1 + y2) / 2 + 20, text=f"{tamano} m", anchor='w', angle=90)


# Función para calcular d automáticamente
def calcular_d(event=None):
    global entry_recubrimiento_viga, entry_altura_viga, entry_d_viga,label_profundidad_prueba
    try:
        # Obtener los valores de las entradas
        altura_viga = float(entry_altura_viga.get())
        recubrimiento_viga = float(entry_recubrimiento_viga.get())
        
        # Calcular la altura efectiva
        efectiva_d = altura_viga - recubrimiento_viga
        
        # Actualizar el Entry de d
        entry_d_viga.delete(0, tk.END)  
        entry_d_viga.insert(0, f"{efectiva_d:.2f}")  
        
        # Actualizar el texto del label
        label_profundidad_prueba.config(text=f"{efectiva_d:.2f}")
        
    except ValueError:
        entry_d_viga.delete(0, tk.END)  
        label_profundidad_prueba.config(text="Valor inválido")

# Función para calcular Mcr
def calcular_Mcr():
    global label_mensaje1, entry_base_viga, entry_altura_viga, combobox1, entry_Mcr,label_Mcr_1,label_Mcr_check
    try:
        # Obtener el valor de f'c desde el combobox, quitar "MPa" y convertirlo a float
        f_c_str = combobox1.get().replace(" MPa", "")  # Remover " MPa"
        f_c = float(f_c_str)

        # Obtener el valor de la base y la altura desde los entries y convertirlos a float
        base_Mcr = float(entry_base_viga.get())
        altura_Mcr = float(entry_altura_viga.get())

        # Calcular Mcr usando las variables base_Mcr y altura_Mcr
        Mcr = 0.62 * sqrt(f_c) * base_Mcr * (altura_Mcr ** 2) * 1000 / 6

        # Mostrar el resultado en el entry de Mcr
        entry_Mcr.delete(0, tk.END)
        entry_Mcr.insert(0, f"{Mcr:.2f}")  # Insertar el resultado formateado a dos decimales
        
        # Actualizar el mensaje en el label
        label_mensaje1.config(text=(
            f"Momento de agrietamiento: {Mcr:.2f} kNm\n"
            "Indica el límite donde el concreto comienza a agrietarse."), fg="black")
        
        # Actualizar el dato en label_Mcr_1
        label_Mcr_1.config(text=f"{Mcr:.2f} kNm.")
        
        # Actualizar el texto en label_Mcr_check con el mismo mensaje de label_mensaje1
        label_Mcr_check.config(
            text=(f"Momento de agrietamiento: {Mcr:.2f} kNm.\n"
            "Indica el límite donde el concreto comienza a agrietarse."),
            fg="black"
        )
        
    except ValueError:
        entry_Mcr.delete(0, tk.END)
        entry_Mcr.insert(0, "Error: Verifique los valores")
        error_msg = "Error: Verifique los valores"
        label_mensaje1.config(text="Error: Verifique los valores", fg="red")
        # Actualizar los labels en caso de error
        label_Mcr_1.config(text="Error en los datos de entrada", fg="red")
        label_Mcr_check.config(text=error_msg, fg="red")
    except Exception as e:
        entry_Mcr.delete(0, tk.END)
        entry_Mcr.insert(0, f"Error: {str(e)}")
        label_mensaje1.config(text=f"Error: {str(e)}", fg="red")
        # Actualizar los labels en caso de error
        label_Mcr_1.config(text=f"Error: {str(e)}", fg="red")
        label_Mcr_check.config(text=error_msg, fg="red")


# Función para calcular la cuantía requerida (ρ)
def Calcular_Cuantia_Req(event=None):
    try:
        # Obtener los valores seleccionados de los Combobox y el Entry
        # Extraer el número de f'_c desde el Combobox1 
        f_c_1 = float(combobox1.get().split()[0])  
        f_y_1 = float(combobox2.get().split()[0])  
        Rn_2 = float(entry_Rn.get()) / 1000  
        
        # Constante 0.85
        constante_c = 0.85
        
        # Calcular ρ usando la fórmula proporcionada
        raiz_1 = 1 - (2 * Rn_2) / (constante_c * f_c_1)
        
        if raiz_1 < 0:
        # Si el valor bajo la raíz cuadrada es negativo, mostramos el error
            entry_ρ.config(state="normal")  
            entry_ρ.delete(0, tk.END)  
            entry_ρ.insert(0, "Error en cálculo")  
            entry_ρ.config(state="readonly")  
            # Actualizar label_ρreq_mcr con mensaje de error
            label_ρreq_mcr.config(text="Error en cálculo")
            # Limpiar label_Rn_mcr_check
            label_Rn_mcr_check.config(text="")
        else:
        # Si todo es válido, calculamos la cuantía (ρ)
            rho_4 = (constante_c * f_c_1 / f_y_1) * (1 - math.sqrt(raiz_1))
            
            # Mostrar el resultado de ρ en el Entry (de solo lectura)
            entry_ρ.config(state="normal")  
            entry_ρ.delete(0, tk.END)  
            entry_ρ.insert(0, str(round(rho_4, 6)))  
            entry_ρ.config(state="readonly") 
            
            # Actualizar label_ρreq_mcr con el valor de ρ calculado
            label_ρreq_mcr.config(text=f"{round(rho_4, 6)}")
            
        # Comparar con la cuantía mínima
            cuantia_minima = 0.0033
            if rho_4 < cuantia_minima:
                # Si ρ es menor que la cuantía mínima, mostrar el mensaje
                mensaje_mcr = (f"La cuantía requerida es {rho_4:.5f}. "
                            f"Es menor que la cuantía mínima de {cuantia_minima:.5f}. "
                            "Se debe usar la cuantía mínima.")
                label_mensaje2.config(text=mensaje_mcr)
                # Actualizar label_Rn_mcr_check con el mismo mensaje de label_mensaje2
                label_Rn_mcr_check.config(text=mensaje_mcr, bg="white")
            else:
                # Si ρ es mayor o igual a la cuantía mínima, mostrar un mensaje diferente
                mensaje_mcr = (f"La cuantía requerida es {rho_4:.5f}. "
                            "Es adecuada para el diseño.")
                label_mensaje2.config(text=mensaje_mcr)
                # Actualizar label_Rn_mcr_check con el mismo mensaje de label_mensaje2
                label_Rn_mcr_check.config(text=mensaje_mcr, bg="white")

    except ValueError:
        # Si ocurre un error en la conversión de los datos o cualquier otro problema
        entry_ρ.config(state="normal")  
        entry_ρ.delete(0, tk.END)  
        entry_ρ.insert(0, "Error en datos")  
        entry_ρ.config(state="readonly")  
        
        # Limpiar los otros labels
        label_ρreq_mcr.config(text="Error en los datos", bg="red")
        label_Rn_mcr_check.config(text="", bg="white")
        label_mensaje2.config(text="")
        label_mensaje2.config(text="")  


def Calcular_Resistencia_Rn():
    try:
    # Obtener los valores de los campos de entrada con los nuevos nombres de las variables
        Mcr_momento_1 = float(entry_Mcr.get())  # Obtener el valor de Mcr
        b_base_1 = float(entry_base_viga.get())  # Obtener el valor de b
        d_altura_efectiva_1 = float(entry_d_viga.get())  # Obtener el valor de d
        
    # Constante Phi_0.90_1
        Phi_1 = 0.90
        
    # Calcular Rn usando la fórmula Rn = Mcr / (Φ * b * d^2)
        Rn_1 = Mcr_momento_1 / (Phi_1 * b_base_1 * d_altura_efectiva_1 ** 2)
        
    # Mostrar el resultado en entry_Rn
        entry_Rn.delete(0, tk.END)  # Limpiar el entry antes de poner el nuevo valor
        entry_Rn.insert(0, str(round(Rn_1, 2)))  # Insertar el valor de Rn (redondeado a 2 decimales)
        
    # Actualizar el texto del label_b_prueba con el valor de entry_base_viga
        label_b_prueba.config(text=f"{b_base_1}")  # Actualizar el texto del label
        
    # Actualizar el valor de label_Rn_mcr con el mismo valor calculado
        label_Rn_mcr.config(text=f"{round(Rn_1, 2)} kN/m²")  # Mostrar el valor de Rn en el label
        
    except ValueError:
    # Si no se pueden convertir los valores a float, mostrar un mensaje de error
        entry_Rn.delete(0, tk.END)
        entry_Rn.insert(0, "Error en los datos")
        # Actualizar label_Rn_mcr con el mensaje de error
        label_Rn_mcr.config(text="Error en los datos")

def on_checkbutton_Rn_select():
    Calcular_Resistencia_Rn()  
    Calcular_Cuantia_Req()


# Diccionario con la información de las barras de refuerzo
barras_info_refuerzo_1= {
"Barra No.2": {"diametro_pulg": "1/4", "diametro_mm": 6.4, "area_mm2": 32, "perimetro_mm": 20.0, "masa_kg_m": 0.250},
"Barra No.3": {"diametro_pulg": "3/8", "diametro_mm": 9.5, "area_mm2": 71, "perimetro_mm": 30.0, "masa_kg_m": 0.560},
"Barra No.4": {"diametro_pulg": "1/2", "diametro_mm": 12.7, "area_mm2": 129, "perimetro_mm": 40.0, "masa_kg_m": 0.994},
"Barra No.5": {"diametro_pulg": "5/8", "diametro_mm": 15.9, "area_mm2": 199, "perimetro_mm": 50.0, "masa_kg_m": 1.552},
"Barra No.6": {"diametro_pulg": "3/4", "diametro_mm": 19.1, "area_mm2": 284, "perimetro_mm": 60.0, "masa_kg_m": 2.235},
"Barra No.7": {"diametro_pulg": "7/8", "diametro_mm": 22.2, "area_mm2": 387, "perimetro_mm": 70.0, "masa_kg_m": 3.042},
"Barra No.8": {"diametro_pulg": "1", "diametro_mm": 25.4, "area_mm2": 510, "perimetro_mm": 80.0, "masa_kg_m": 3.973},
"Barra No.9": {"diametro_pulg": "1-1/8", "diametro_mm": 28.7, "area_mm2": 645, "perimetro_mm": 90.0, "masa_kg_m": 5.060},
"Barra No.10": {"diametro_pulg": "1-1/4", "diametro_mm": 32.3, "area_mm2": 819, "perimetro_mm": 101.3, "masa_kg_m": 6.404},
"Barra No.11": {"diametro_pulg": "1-3/8", "diametro_mm": 35.8, "area_mm2": 1006, "perimetro_mm": 112.5, "masa_kg_m": 7.907},
"Barra No.14": {"diametro_pulg": "1-3/4", "diametro_mm": 43.0, "area_mm2": 1452, "perimetro_mm": 135.1, "masa_kg_m": 11.38},
"Barra No.18": {"diametro_pulg": "2-1/4", "diametro_mm": 57.3, "area_mm2": 2581, "perimetro_mm": 180.1, "masa_kg_m": 20.24}
}


# Función combinada para actualizar información y realizar cálculos
def actualizar_y_calcular(event=None):
    actualizar_label_informacion()
    calculos_previos()
    actualizar_dibujar()

# Función para obtener información de una barra específica
def obtener_informacion_barra(seleccion_2):
    barra_info = barras_info_refuerzo_1.get(seleccion_2)
    if barra_info:
        return (
            f"{seleccion_2}:\n"
            f"Diámetro: {barra_info['diametro_pulg']} pulgadas ({barra_info['diametro_mm']} mm)\n"
            f"Área: {barra_info['area_mm2']} mm²\n"
            f"Perímetro: {barra_info['perimetro_mm']} mm\n"
            f"Masa: {barra_info['masa_kg_m']} kg/m"
        )
    else:
        return "Designación de barra no encontrada."



# Función para mostrar información de la barra seleccionada
def actualizar_label_informacion(event=None):
    seleccion_2 = spinbox_barras.get()
    informacion = obtener_informacion_barra(seleccion_2)
    label_mensaje3.config(text=informacion)



# Función para realizar cálculos
def calculos_previos(event=None):
    try:
        b_base = float(entry_base_viga.get())
        d_peralte = float(entry_d_viga.get())
    except ValueError:
        return

    seleccion_2 = spinbox_barras.get()
    barra_info = barras_info_refuerzo_1.get(seleccion_2)
    if barra_info is None:
        return

    As_compresión_1 = 0.0033 * b_base * 1000 * d_peralte * 1000
    entry_As_prima.delete(0, tk.END)
    entry_As_prima.insert(0, f"{As_compresión_1:.2f}")
    
    # Actualizar el label correspondiente para As'
    label_area_req_mcr.config(text=f"{As_compresión_1:.2f} mm²")

    area_barra = barra_info["area_mm2"]
    entry_Ab_area.delete(0, tk.END)
    entry_Ab_area.insert(0, f"{area_barra}")
    
    # Actualizar el label correspondiente para el área de barra
    label_area_barra_mcr.config(text=f"{area_barra} mm²")

    try:
        As_prima = float(entry_As_prima.get())
        Ab_area = float(entry_Ab_area.get())
        numero_de_barras = As_prima / Ab_area

        numero_de_barras_redondeado = (
            math.floor(numero_de_barras)
            if numero_de_barras - math.floor(numero_de_barras) < 0.90
            else math.ceil(numero_de_barras)
        )

        if numero_de_barras_redondeado < 2:
            numero_de_barras_redondeado = 2

        barra_numero_1 = re.search(r"\d+", seleccion_2).group()
        entry_num_barra.delete(0, tk.END)
        entry_num_barra.insert(0, f"{numero_de_barras_redondeado}#{barra_numero_1}")
        
        # Actualizar el label correspondiente para el número de barras
        label_num_barra_mcr.config(text=f"{numero_de_barras_redondeado}#{barra_numero_1}")
        
        # Actualizar el Combobox con el mismo valor
        Barras_compresion.set(f"{numero_de_barras_redondeado}#{barra_numero_1}")
        
        # Ahora, actualizar el label_info_barras_mcr con la información completa de la barra
        barra_info_texto = obtener_informacion_barra(seleccion_2)  
        label_info_barras_mcr.config(text=barra_info_texto)
        
    except ValueError:
        pass


# Función para dibujar la figura en el Canvas
def actualizar_dibujar(event=None):
    # Obtener los valores de base y altura de los entrys
    try:
        base_2 = float(entry_base_viga.get())
        altura_2 = float(entry_altura_viga.get())
    except ValueError:
        return  # Si no se ingresan valores válidos, no hacer nada
    
    # Obtener el número de círculos desde el entry entry_num_barra
    num_circulos_texto = entry_num_barra.get()
    try:
        num_circulos = int(num_circulos_texto.split('#')[0])  
    except ValueError:
        num_circulos = 0  
    
    # Factor de escala para el tamaño de la figura
    escala = 200
    offset_interno = 10  
    radio_circulo = 3  

    # Limpiar el canvas antes de redibujar
    canvas_seccion_2.delete("all")
    
    # Calcular el tamaño escalado de la figura
    base_escalada = base_2 * escala
    altura_escalada = altura_2 * escala
    
    # Calcular las coordenadas para centrar la figura
    canvas_width_1 = canvas_seccion_2.winfo_width()
    canvas_height_1 = canvas_seccion_2.winfo_height()
    
    # Coordenadas para centrar la figura en el Canvas
    x_offset = (canvas_width_1 - base_escalada) / 2
    y_offset = (canvas_height_1 - altura_escalada) / 2
    
    # Crear el texto a mostrar arriba de la figura externa
    base_viga_cm = int(base_2 * 100)  
    altura_viga_cm = int(altura_2 * 100)  
    texto_viga = f"VG {base_viga_cm} X {altura_viga_cm}"
    
    # Calcular tamaño de fuente proporcional a la figura externa
    tamano_fuente = int(base_escalada / 7)  
    
    # Dibujar el texto sobre la figura externa en el Canvas
    canvas_seccion_2.create_text(
        x_offset + base_escalada / 2,  
        y_offset - tamano_fuente - 5,  
        text=texto_viga,
        font=("Arial", tamano_fuente,"bold"),
        fill="black"
    )
    
    # Dibujar la figura externa (original) en el canvas
    canvas_seccion_2.create_rectangle(
        x_offset, y_offset, 
        x_offset + base_escalada, y_offset + altura_escalada, 
        outline="black", fill="lightgrey", width=2
    )
    
    # Dibujar la figura interna con el offset aplicado
    base_interna = base_escalada - 2 * offset_interno
    altura_interna = altura_escalada - 2 * offset_interno
    
    canvas_seccion_2.create_rectangle(
        x_offset + offset_interno, y_offset + offset_interno,
        x_offset + base_escalada - offset_interno, y_offset + altura_escalada - offset_interno,
        outline="red", width=2
    )
    
    # Dibujar círculos dentro de la figura interna en la parte superior
    if num_circulos > 0:
        # Espaciado entre los círculos
        espacio_lateral = (base_interna - (num_circulos - 1) * (2 * radio_circulo + 10) - 2 * radio_circulo) / 2
        
        for i in range(num_circulos):
            # Coordenadas x para cada círculo
            if i == 0:  
                x_circulo = x_offset + offset_interno + radio_circulo  
            elif i == num_circulos - 1:  
                x_circulo = x_offset + base_escalada - offset_interno - radio_circulo  
            else:
                x_circulo = x_offset + offset_interno + espacio_lateral + i * (2 * radio_circulo + 10) + radio_circulo

            # Coordenada y (ubicada cerca de la parte superior de la figura interna)
            y_circulo = y_offset + offset_interno + radio_circulo  
            
            # Dibujar el círculo en el canvas
            canvas_seccion_2.create_oval(
                x_circulo - radio_circulo, y_circulo - radio_circulo,
                x_circulo + radio_circulo, y_circulo + radio_circulo,
                outline="black", fill="black", width=2
            )
    
    # Dibujar las cotas (etiquetas de ancho y altura)
    
    # Cota de ancho (base)
    canvas_seccion_2.create_line(
        x_offset-10, y_offset + altura_escalada + 10, 
        x_offset + base_escalada + 10, y_offset + altura_escalada + 10, 
        arrow=tk.BOTH, width=2
    )
    canvas_seccion_2.create_text(
        (x_offset + x_offset + base_escalada) / 2, 
        y_offset + altura_escalada + 20, 
        text=f"{base_2} m", font=("Arial", 10, "bold")
    )
    
    # Ajuste dinámico para la cota de altura basado en el tamaño de la base
    ajuste_lateral_cota = base_escalada * 1.15 
    
    # Cota de altura
    canvas_seccion_2.create_line(
        x_offset + ajuste_lateral_cota, y_offset - 10, 
        x_offset + ajuste_lateral_cota, y_offset + altura_escalada + 10, 
        arrow=tk.BOTH, width=2
    )
    canvas_seccion_2.create_text(
        x_offset + ajuste_lateral_cota + 10, 
        (y_offset + y_offset + altura_escalada) / 2, 
        text=f"{altura_2} m", font=("Arial", 10,"bold"), angle=90
    )

# Función para actualizar el texto en el Canvas
def actualizar_texto_canvas():

    canvas_seccion_2.delete("texto_canvas")

    if check_var.get():
        texto = entry_num_barra.get()

        texto_formateado = f"As': {texto}"
        canvas_seccion_2.create_text(85, 85, text=texto_formateado, tags="texto_canvas", font=("Arial", 7,"bold"), fill="black")


def on_entry_change_1(*args):
    if check_var.get():  
        actualizar_texto_canvas()


# Función para insertar datos en el Treeview
def insertar_datos_treeview_3():
    # Obtener los valores de los cuadros de texto
    viga_1 = entry_seccion_viga_VG.get()
    mcr = entry_Mcr.get()
    ρmin_1 = entry_ρmin.get()
    as_prima = entry_As_prima.get()
    num_barra_1 = entry_num_barra.get()
    
    # Insertar datos en la primera fila del Treeview
    treeview_Mcr.delete(*treeview_Mcr.get_children())  # Limpiar el Treeview
    treeview_Mcr.insert("", "end", values=(viga_1, mcr, ρmin_1, as_prima, num_barra_1))
    
    # Actualizar el texto del Label
    mensaje_Mcr = (
        f"La viga con sección {viga_1} requiere un área de acero de {as_prima} mm² "
        f"en la zona de compresión equivalente a {num_barra_1}."
    )  
    
    mensaje_desarrollo = (
        'Muy bien, ahora, continúa con las configuraciones de longitud de desarrollo.'
    )  

    label_check_Mcr.config(text=mensaje_Mcr)  
    label_icon_Mcr.config(image=icon_check_on)  
    label_check_desarrollo.config(text=mensaje_desarrollo)  


def cerrar_ventana_Mcr():
    global ventana_mcr, ventana_mcr_abierta
    ventana_mcr_abierta = False  
    ventana_mcr.destroy()  
    ventana_mcr = None  

#Función para abrir ventana Momento agrietamiento 
def abrir_ventana_Mcr():
    global ventana_mcr, ventana_mcr_abierta,entry_base_viga, entry_altura_viga, canvas_seccion_1,combobox3
    global entry_recubrimiento_viga,entry_d_viga,label_mensaje1,entry_Mcr,combobox1,boton_Mcr
    global entry_Rn, entry_ρ, label_mensaje1, label_mensaje2,combobox2,check_var
    global canvas_seccion_2,entry_As_prima,entry_Ab_area,spinbox_barras,label_mensaje3,entry_num_barra,barras_info_refuerzo_1,valores_barras_Spin
    global entry_seccion_viga_VG,entry_ρmin
    # Si la ventana ya está abierta, no crear otra
    if ventana_mcr_abierta:
        return
    
    
    ventana_mcr = tk.Toplevel()
    ventana_mcr_abierta = True  
    ventana_mcr.title("Cálculo momento de agrietamiento")
    ventana_mcr.geometry("800x465")  
    ventana_mcr.resizable(False, False)  
    ventana_mcr.attributes('-topmost', True) 
    
    # Agregar contenido a la ventana Mcr
    etiqueta_calculos = tk.LabelFrame(ventana_mcr, text="Datos de la viga")
    etiqueta_calculos.place(x=10, y=10, width=380, height=100)  
    etiqueta_sección_viga = tk.LabelFrame(ventana_mcr, text="Sección transversal")
    etiqueta_sección_viga.place(x=10, y=110, width=380, height=200)
    etiqueta_momento_viga = tk.LabelFrame(ventana_mcr, text="Momento de agrietamiento")
    etiqueta_momento_viga.place(x=10, y=310, width=380, height=100)
    etiqueta_Rn_viga = tk.LabelFrame(ventana_mcr, text="Resistencia Requerida y Cuantia Requerida")
    etiqueta_Rn_viga.place(x=400, y=10, width=390, height=120)
    etiqueta_As_viga = tk.LabelFrame(ventana_mcr, text="Asignar Refuerzo a Compresión")
    etiqueta_As_viga.place(x=400,y=130, width=390, height=280)
    
    # Crear un Canvas dentro del LabelFrame
    canvas_seccion_1 = tk.Canvas(etiqueta_sección_viga, bg='white',bd=4,relief="ridge" ,width=130, height=150)
    canvas_seccion_1.place(x=220, y=10)  
    canvas_seccion_2 = tk.Canvas(etiqueta_As_viga, bg='white',bd=4,relief="ridge" ,width=160, height=170)
    canvas_seccion_2.place(x=210, y=40)  
    
    # Agregar label a la ventana Mcr
    label_seccion_VG = tk.Label(etiqueta_calculos, text="Sección:")
    label_seccion_VG.place(x=10, y=10)
    label_seccion_luz_VG = tk.Label(etiqueta_calculos, text="Luz:")
    label_seccion_luz_VG.place(x=10, y=40)
    label_material_fc= tk.Label(etiqueta_calculos,text="f'c:")
    label_material_fc.place(x=200, y=10)
    label_material_fy= tk.Label(etiqueta_calculos,text="fy:")
    label_material_fy.place(x=200, y=40)
    label_tipo_viga_VG = tk.Label(etiqueta_sección_viga, text="Tipo:")
    label_tipo_viga_VG.place(x=10,y=10)
    label_base_viga = tk.Label(etiqueta_sección_viga, text="b:")
    label_base_viga.place(x=10,y=50)
    label_unidad_base = tk.Label(etiqueta_sección_viga, text="m")
    label_unidad_base.place(x=80,y=50)
    label_altura_viga = tk.Label(etiqueta_sección_viga, text="h:")
    label_altura_viga.place(x=120,y=50)
    label_unidad_altura = tk.Label(etiqueta_sección_viga, text="m")
    label_unidad_altura.place(x=190,y=50)
    label_recubrimiento_viga = tk.Label(etiqueta_sección_viga, text="r:")
    label_recubrimiento_viga.place(x=10,y=90)
    label_unidad_recubrimiento = tk.Label(etiqueta_sección_viga, text="m")
    label_unidad_recubrimiento.place(x=80,y=90)
    label_d_viga = tk.Label(etiqueta_sección_viga, text="d:")
    label_d_viga.place(x=120,y=90)
    label_unidad_d = tk.Label(etiqueta_sección_viga, text="m")
    label_unidad_d.place(x=190,y=90)
    label_Mcr = tk.Label(etiqueta_momento_viga, text="Mcr:")
    label_Mcr.place(x=70,y=20)
    label_unidad_Mcr = tk.Label(etiqueta_momento_viga, text="kNm")
    label_unidad_Mcr.place(x=200,y=20)
    label_mensaje1= tk.Label(etiqueta_momento_viga,text="")
    label_mensaje1.place(x=10,y=45)
    label_Rn =tk.Label(etiqueta_Rn_viga,text="Rn:")
    label_Rn.place(x=6,y=40)
    label_unidad_Rn=tk.Label(etiqueta_Rn_viga,text="kN/m²")
    label_unidad_Rn.place(x=115,y=40)
    label_ρ=tk.Label(etiqueta_Rn_viga,text="ρreq:")
    label_ρ.place(x=250,y=40)
    label_ρmin = tk.Label(etiqueta_Rn_viga,text="ρmin:")
    label_ρmin.place(x=250,y=6)
    label_mensaje2 = tk.Label(etiqueta_Rn_viga, text="", wraplength=350, justify="left", anchor="w", width=50)
    label_mensaje2.place(x=1,y=60)
    label_escoger_barra =tk.Label(etiqueta_As_viga,text="Seleccione la designación de la barra:")
    label_escoger_barra.place(x=6,y=6)
    label_mensaje3 = tk.Label(etiqueta_As_viga,text="",justify="left")
    label_mensaje3.place(x=10, y=50, width=200, height=110)
    label_As_prima = tk.Label(etiqueta_As_viga,text="As':")
    label_As_prima.place(x=10,y=160)
    label_Ab_area = tk.Label(etiqueta_As_viga,text="Ab:")
    label_Ab_area.place(x=10,y=190)
    label_num_barra = tk.Label(etiqueta_As_viga,text="#barras:")
    label_num_barra.place(x=10,y=220)
    label_unidad_As=tk.Label(etiqueta_As_viga,text="mm²")
    label_unidad_As.place(x=140,y=160)
    label_unidad_Ab=tk.Label(etiqueta_As_viga,text="mm²")
    label_unidad_Ab.place(x=140,y=190)
        
    # Agregar entrys en la ventana Mcr
    entry_seccion_viga_VG = tk.Entry(etiqueta_calculos)
    entry_seccion_viga_VG.place(x=80, y=10, width=80)
    entry_seccion_luz = tk.Entry(etiqueta_calculos)
    entry_seccion_luz.place (x=80,y=40, width=80 )
    entry_base_viga = tk.Entry(etiqueta_sección_viga)
    entry_base_viga.place(x=30, y=50 ,width=50)
    entry_altura_viga = tk.Entry(etiqueta_sección_viga)
    entry_altura_viga.place(x=140, y=50 ,width=50)
    entry_recubrimiento_viga = tk.Entry(etiqueta_sección_viga)
    entry_recubrimiento_viga.place(x=30, y=90 ,width=50)
    entry_d_viga =tk.Entry(etiqueta_sección_viga)
    entry_d_viga.place(x=140,y=90, width=50)
    entry_Mcr =tk.Entry(etiqueta_momento_viga)
    entry_Mcr.place(x=110,y=20,width=80)
    entry_Rn =tk.Entry(etiqueta_Rn_viga)
    entry_Rn.place(x=33,y=40,width=80)
    entry_ρ =tk.Entry(etiqueta_Rn_viga)
    entry_ρ.place(x=290,y=40,width=70)
    entry_ρmin =tk.Entry(etiqueta_Rn_viga)
    entry_ρmin.place(x=290,y=6,width=70)
    entry_ρmin.insert(0, "0.0033")  
    entry_ρmin.config(state='readonly')
    entry_As_prima= tk.Entry(etiqueta_As_viga)
    entry_As_prima.place(x=65,y=160,width=70)
    entry_Ab_area= tk.Entry(etiqueta_As_viga)
    entry_Ab_area.place(x=65,y=190,width=70)
    entry_num_barra= tk.Entry(etiqueta_As_viga)
    entry_num_barra.place(x=65,y=220,width=70)
    
    # Botón para guardar datos de entradas y cerrar ventana_calculos
    boton_guardar_datos_Mcr = ttk.Button(ventana_mcr,text="Agregar datos",command=insertar_datos_treeview_3)
    boton_guardar_datos_Mcr.place(x=270,y=420,width=100)
    boton_aceptar_ventana = ttk.Button(ventana_mcr,text="Aceptar",command=cerrar_ventana_Mcr)
    boton_aceptar_ventana.place(x=420,y=420,width=100)
    
    # Asignar los valores de los Label a los Entry
    entry_seccion_viga_VG.insert(0, label_seccion_cargas.cget("text"))  
    entry_seccion_luz.insert(0, label_seccion_luz.cget("text")+"m")  
    
    # Variable para almacenar el estado del Checkbutton
    check_var = tk.BooleanVar()
    
    # Crear el Checkbutton en la interfaz
    check_button = tk.Checkbutton(etiqueta_As_viga, text="As'", variable=check_var,command=actualizar_texto_canvas)
    check_button.place(x=140,y=220)
    
    # Variable de control para el Checkbutton Rn
    var_Rn = tk.BooleanVar()
    
    # Variable de control para otro Checkbutton
    var_seccion_constante = tk.BooleanVar()
    
    # Crear el Checkbutton
    checkbutton_Mcr = tk.Checkbutton(etiqueta_sección_viga, text="Mantener sección constante",variable=var_seccion_constante)
    checkbutton_Mcr.place(x=10,y=130)
    
    # Crear el Checkbutton
    Checkbutton_Rn = tk.Checkbutton(etiqueta_Rn_viga, text="Considerar  ɸ = 0,90 para tracción",variable=var_Rn, command=on_checkbutton_Rn_select)
    Checkbutton_Rn.place(x=6,y=6)
    
    # Crear el botón para calcular Mcr
    boton_Mcr = ttk.Button(etiqueta_momento_viga, text="Calcular Mcr", command=calcular_Mcr)
    boton_Mcr.place(x=250, y=15)
    
    
    
    # Agregar Combobox o lista de datos
    # Lista de opciones para el Combobox
    opciones_fc = [
    "17.5 MPa",
    "21 MPa",
    "24.5 MPa",
    "28 MPa",
    "35 MPa",
    "42 MPa"
    ]
    
    opciones_fy = [
    "420 Mpa"
    ]
    
    opciones2= [
    "Sección rectangular",
    "Sección cuadrada"
    ]
    
    # Crear el Combobox
    combobox1 = ttk.Combobox(etiqueta_calculos, values=opciones_fc, state="readonly")
    combobox1.set("Seleccionar")  # Establecer el valor inicial
    combobox1.place(x=240,y=10,width=100)
    
    combobox2 = ttk.Combobox(etiqueta_calculos, values=opciones_fy, state="readonly")
    combobox2.set("Seleccionar")  # Establecer el valor inicial
    combobox2.place(x=240,y=40,width=100)
    
    combobox3 = ttk.Combobox(etiqueta_sección_viga, values=opciones2, state="readonly")
    combobox3.set("Seleccionar")  # Establecer el valor inicial
    combobox3.place(x=50,y=10,width=130)
    
    # Crear el Spinbox usando la lista de valores
    spinbox_barras = ttk.Spinbox(etiqueta_As_viga, values=list(barras_info_refuerzo_1.keys()))
    spinbox_barras.place(x=10,y=40)
    spinbox_barras.bind("<ButtonRelease-1>",actualizar_y_calcular)
    
    
    entry_base_viga.bind("<KeyRelease>", actualizar_cotas)
    entry_altura_viga.bind("<KeyRelease>", actualizar_cotas)
    entry_recubrimiento_viga.bind("<KeyRelease>", calcular_d)
    
        
    ventana_mcr.protocol("WM_DELETE_WINDOW", cerrar_ventana_Mcr)  

# Globalmente almacenamos el objeto canvas
canvas = None

def guardar_imagen(canvas):
    # Ruta relativa donde se guardará la imagen
    ruta_guardado_1 = "Reportes/imagenes_pilot/grafico_final.png"
    
    # Guardar la figura con fondo transparente
    if canvas is not None:
        canvas.figure.savefig(ruta_guardado_1, dpi=300, transparent=True)

def Dibujar_Despiece_Viga():
    global canvas
    # Obtener el valor del Entry de la longitud de la viga L (eliminamos la parte " m")
    valor_cota = entry_luz_Ld.get()  # Longitud de la viga L
    L_despiece = float(valor_cota.split()[0])  # Tomamos solo la parte numérica y la convertimos a flotante
    
    # Obtener el valor de Wu desde el Entry
    valor_Wu = entry_Wu_Ld.get()  # Wu
    Wu_ld = float(valor_Wu.split()[0])  # Tomamos solo la parte numérica y la convertimos a flotante
    
    # Crear la figura y el eje
    fig, ax = plt.subplots(figsize=(8, 6))
    
    # Definir las coordenadas de los puntos (x, y) para la figura original (sin la línea duplicada)
    puntos_viga_original = [
        (1, 0.5), (1, 4.5),  # Línea vertical izquierda alargada
        (1, 4.5), (3, 4.5),  # Línea horizontal superior izquierda
        (3, 4.5), (3, 3.5),  # Línea vertical derecha (corta, baja a un tercio)
        (3, 3.5), (8, 3.5),  # Línea horizontal proyectada más alargada desde el tercio
        (8, 3.5), (8, 4.5),  # Línea vertical corta subiendo desde la línea horizontal proyectada
        (8, 4.5), (10, 4.5),  # Línea horizontal superior derecha proyectada
        (10, 4.5), (10, 0.5),  # Línea vertical derecha alargada
        (10, 0.5), (8, 0.5),  # Línea horizontal inferior de la misma longitud
        (8, 0.5), (8, 1.5),  # Línea corta vertical subiendo a un tercio
        (8, 1.5), (3, 1.5),  # Línea horizontal proyectada desde el tercio hacia la izquierda
        (3, 1.5), (3, 0.5),  # Línea corta vertical bajando a la misma longitud de la línea vertical anterior
        (3, 0.5), (1, 0.5),  # Línea horizontal inferior en sentido izquierdo
    ]
    
    # Definir las coordenadas de la línea duplicada como una cota
    linea_duplicada = [(3, 0.4), (8, 0.4)]  # Línea horizontal separada desplazada hacia abajo
    
    # Dibujar la figura original
    x_original = [p[0] for p in puntos_viga_original]
    y_original = [p[1] for p in puntos_viga_original]
    ax.fill(x_original, y_original, color='lightgrey', alpha=0.5)  # Hacemos la figura translúcida para distinción
    ax.plot(x_original, y_original, 'k-', linewidth=2)

    # Dibujar la cota
    x_linea_cota = [p[0] for p in linea_duplicada]
    y_linea_cota = [p[1] for p in linea_duplicada]
    ax.plot(x_linea_cota, y_linea_cota, 'r-', linewidth=1.5, label='Cota')  # Línea de cota

    # Líneas de extensión
    ax.plot([3, 3], [0.4, 0.7], 'r--', linewidth=1)  # Línea de extensión izquierda
    ax.plot([8, 8], [0.4, 0.7], 'r--', linewidth=1)  # Línea de extensión derecha

    # Flechas en los extremos
    ax.annotate('', xy=(3, 0.4), xytext=(8, 0.4), arrowprops=dict(arrowstyle='<->', color='red', lw=1.5))

    # Texto de la cota (valor del Entry)
    ax.text(5.5, 0.5, valor_cota, color='red', fontsize=8, ha='center', fontweight='bold')  # Ajustamos el texto dinámicamente

    # Dibujar la figura copia (sin la cota), desplazándola hacia arriba
    x_copia = [p[0] for p in puntos_viga_original]
    y_copia = [p[1] + 5 for p in puntos_viga_original]  # Desplazamos hacia arriba
    ax.fill(x_copia, y_copia, color='lightgrey', alpha=0.5)
    ax.plot(x_copia, y_copia, 'k--', linewidth=2)
    
    
    # Calcular el centro de la figura copia en el eje Y
    y_centro = (min(y_copia) + max(y_copia)) / 2

    # Dibujar la línea horizontal negra continua 
    ax.plot([3, 8], [y_centro, y_centro], 'k-', linewidth=1.5, label='Línea centrada')

    # Dibujar el primer punto rojo en la figura copia
    ax.plot(3, 4.5 + 5, 'ro')  

    # Dibujar el segundo punto rojo 
    ax.plot(5.5, 1.5 + 5, 'ro')  

    # Dibujar el tercer punto rojo en la figura copia
    # Coordenadas de los tres puntos rojos
    puntos_rojos = np.array([(3, 4.5 + 5), (5.5, 1.5 + 5), (8, 4.5 + 5)])

    # Ajustar los puntos para la curva
    x_puntos = puntos_rojos[:, 0]
    y_puntos = puntos_rojos[:, 1]

    # Interpolación cúbica para obtener la curva que pasa por los puntos
    spline = CubicSpline(x_puntos, y_puntos, bc_type='natural')

    # Crear puntos en el eje X para dibujar la curva
    x_dibujo = np.linspace(min(x_puntos), max(x_puntos), 500)
    y_dibujo = spline(x_dibujo)

    # Dibujar la curva
    ax.plot(x_dibujo, y_dibujo, 'r-', label='Curva cóncava hacia abajo')

    # Encontrar los puntos de intersección con la línea horizontal
    intersecciones_x = np.linspace(min(x_dibujo), max(x_dibujo), 500)
    intersecciones_y = spline(intersecciones_x)
    
    # Suponiendo que la línea horizontal está en y_centro
    intersecciones = np.where(np.isclose(intersecciones_y, y_centro, atol=0.1))[0]
    
    # Si hay intersecciones, encontrar la más a la izquierda
    if len(intersecciones) > 0:
        interseccion_x_izquierda = intersecciones_x[intersecciones[0]]  # El primer índice es el más a la izquierda
        interseccion_y_izquierda = intersecciones_y[intersecciones[0]]
    
    # Intersección más a la derecha (mayor valor de x)
        interseccion_x_derecha = intersecciones_x[intersecciones[-1]]
        interseccion_y_derecha = intersecciones_y[intersecciones[-1]]
    
    # Dibujar el punto rojo en la intersección más a la izquierda
        ax.plot(interseccion_x_izquierda, interseccion_y_izquierda, 'o', color='red', markersize=6, label='Intersección con la línea horizontal')
    
    # Dibujar el punto rojo en la intersección más a la derecha
        ax.plot(interseccion_x_derecha, interseccion_y_derecha, 'o', color='red', markersize=6, label='Intersección derecha')
    
    # Línea de extensión vertical para la intersección izquierda (hacia abajo)
    ax.plot([interseccion_x_izquierda, interseccion_x_izquierda], [interseccion_y_izquierda, min(intersecciones_y) - 5], 'r--', linewidth=1.5)
    
    # Línea de extensión vertical para la intersección derecha (hacia abajo)
    ax.plot([interseccion_x_derecha, interseccion_x_derecha], [interseccion_y_derecha, min(intersecciones_y) - 5], 'r--', linewidth=1.5)
    
    # Agregar texto a la línea de extensión izquierda (vertical)
    ax.text(interseccion_x_izquierda - 0.3, (interseccion_y_izquierda + min(intersecciones_y)) / 2.8, 'P. Inflexión', 
            color='red', fontsize=9, rotation=90, verticalalignment='center', horizontalalignment='left', fontweight='bold')

    # Agregar texto a la línea de extensión derecha (vertical)
    ax.text(interseccion_x_derecha + 0.1, (interseccion_y_derecha + min(intersecciones_y)) / 2.8, 'P. Inflexión', 
            color='red', fontsize=9, rotation=90, verticalalignment='center', horizontalalignment='left', fontweight='bold')
    
    # Calcular el punto medio entre las dos intersecciones
    interseccion_x_centro = (interseccion_x_izquierda + interseccion_x_derecha) / 2
    interseccion_y_centro = (interseccion_y_izquierda + interseccion_y_derecha) / 2

    # Desplazar el punto central hacia abajo
    desplazamiento_y = abs(max(intersecciones_y) - min(intersecciones_y)) * 0.36
    interseccion_y_centro_desplazado = interseccion_y_centro - desplazamiento_y

    # Dibujar un punto más abajo del centro
    ax.plot(interseccion_x_centro, interseccion_y_centro_desplazado, 'o', color='red', markersize=6, label='Centro desplazado')
    
    # Línea de extensión duplicada hacia otro punto (por ejemplo, desplazada en x hacia la derecha)
    nuevo_punto_x = interseccion_x_centro + 2.5  # Desplazamos en el eje X
    nuevo_punto_y = interseccion_y_centro_desplazado  # Mantenemos la misma altura inicial
    
    # Desplazamos hacia la izquierda en el eje X
    nuevo_punto_x_izquierda = interseccion_x_centro - 2.5  # Desplazamos a la izquierda
    nuevo_punto_y_izquierda = interseccion_y_centro_desplazado  # Mantenemos la misma altura inicial
    
    # Dibujar la nueva línea de extensión desplazada hacia la izquierda
    ax.plot([nuevo_punto_x_izquierda, nuevo_punto_x_izquierda], [nuevo_punto_y_izquierda, min(intersecciones_y) + 2], 'g--', linewidth=1.5)
    
    # Dibujar la nueva línea de extensión
    ax.plot([nuevo_punto_x, nuevo_punto_x], [nuevo_punto_y, min(intersecciones_y) + 2], 'g--', linewidth=1.5)
    
    # Línea de extensión vertical desde el punto central desplazado hacia abajo
    ax.plot([interseccion_x_centro, interseccion_x_centro], [interseccion_y_centro_desplazado, min(intersecciones_y) + 2], 'g--', linewidth=1.5)

    # Agregar texto al punto desplazado (horizontal, sin rotación)
    ax.text(interseccion_x_centro, interseccion_y_centro_desplazado + desplazamiento_y + 1.1 , 'Sección Crítica',	 
        color='green', fontsize=9, verticalalignment='center', horizontalalignment='center', fontweight='bold')
    
    # Colorear las áreas bajo la curva entre los puntos de intersección
    if len(intersecciones) >= 2:
        for i in range(len(intersecciones) - 1):
            x1, x2 = intersecciones_x[intersecciones[i]], intersecciones_x[intersecciones[i + 1]]
            y1, y2 = spline(x1), spline(x2)
            ax.fill_between(x_dibujo, y_dibujo, y_centro, where=(x_dibujo >= x1) & (x_dibujo <= x2), color='blue', alpha=0.5)

    # Colorear la área antes de la primera intersección (de la línea horizontal hasta el primer punto de intersección)
    if len(intersecciones) > 0:
        x_inicio = 3  # El inicio de la línea horizontal
        x_fin_1 = intersecciones_x[intersecciones[0]]
        ax.fill_between(x_dibujo, y_dibujo, y_centro, where=(x_dibujo >= x_inicio) & (x_dibujo <= x_fin_1), color='lightcoral', alpha=1)

    # Colorear la área después de la segunda intersección (desde el segundo punto de intersección hasta el final de la línea horizontal)
    if len(intersecciones) > 1:
        x_inicio_2 = intersecciones_x[intersecciones[-1]]
        x_fin_2 = 8  # El fin de la línea horizontal
        ax.fill_between(x_dibujo, y_dibujo, y_centro, where=(x_dibujo >= x_inicio_2) & (x_dibujo <= x_fin_2), color='lightcoral', alpha=1)
    
    
    # Calcular los momentos máximos negativo y positivo
    M1_ld = (1 / 12) * Wu_ld * L_despiece ** 2
    M2_ld = (1 / 24) * Wu_ld * L_despiece ** 2
    M3_ld = (1 / 12) * Wu_ld * L_despiece ** 2

    # Colocar las etiquetas con los momentos
    ax.text(3, 4.5 + 5.2, f'Mu[-]: {M1_ld:.2f} kNm', color='black', fontsize=8, ha='center', fontweight='bold')
    ax.text(5.5, 1.5 + 4.5, f'Mu[+]: {M2_ld:.2f} kNm', color='black', fontsize=8, ha='center', fontweight='bold')
    ax.text(8, 4.5 + 5.2, f'Mu[-]: {M3_ld:.2f} kNm', color='black', fontsize=8, ha='center', fontweight='bold')
    
    
    # Ajustar la visualización
    ax.set_xlim(0, 11)
    ax.set_ylim(-0.1, 10)  # Escalamos los límites para acomodar ambas figuras

    # Usar un aspecto automático y ajustar márgenes
    ax.set_aspect('auto')  # Elimina la relación fija entre los ejes para que las figuras no se reduzcan
    fig.tight_layout()  # Ajusta automáticamente los márgenes de la figura
    # Ocultar los ejes
    ax.axis('off')  # Esto elimina los ejes, marcas y etiquetas
    
    
    # Incrustar la figura en el frame de Tkinter
    canvas = FigureCanvasTkAgg(fig, master=frame_despiece)  # 'frame_despiece' es el contenedor
    canvas.draw()  # Dibuja la figura

    # Mostrar el gráfico usando place con la posición ajustada en la parte superior
    canvas.get_tk_widget().place(x=-10, y=10, width=frame_despiece.winfo_width(), height=frame_despiece.winfo_height() *0.88)

def Dibujar_Despiece_Aceros_Flexion():
    global canvas
    
    if canvas is not None:
        # Obtener el eje del canvas para agregar la nueva línea
        ax = canvas.figure.axes[0]  # Usamos el primer eje de la figura ya dibujada
        
        # Obtener el texto actual de los labels (estos valores son tratados como texto)
        As_negativo_izquierda_valor = label_As_negativo_izquierda.cget("text")
        As_positivo_centro_valor = label_As_positivo_centro.cget("text")
        As_negativo_derecha_valor = label_As_negativo_derecha.cget("text")
        
        # Obtener el valor de Barras_compresion del Combobox
        Barras_compresion_valor = Barras_compresion.get()
        
        # Obtener el texto del label de Tkinter
        texto_label_seccion_cargas = label_seccion_cargas.cget('text')
        texto_label_seccion_luz = "Luz: " + label_seccion_luz.cget('text') + " m"
        
        # Definir las coordenadas de la nueva línea As_positivo
        As_positivo = [3.5, 7.5]  
        y_linea_positiva = [1.7, 1.7]  

        # Dibujar la línea As[+] en azul
        ax.plot(As_positivo, y_linea_positiva, 'b-', linewidth=2)  # Línea azul

        # Agregar el texto con el valor de As_positivo_centro
        ax.text(5.5, 1.9, f'As[+]: {As_positivo_centro_valor}', fontsize=7, ha='center', color='blue',fontweight='bold')  # Coloca el texto justo sobre la línea As[+]
        
        # Definir las coordenadas de As_negativo
        As_negativo = [1.2, 4.8]  
        y_linea_negativa = [3.3, 3.3]  

        # Dibujar la línea As[-] en roja
        ax.plot(As_negativo, y_linea_negativa, 'r-', linewidth=2)  # Línea roja
        
        # Agregar el texto con el valor de As_negativo_izquierda
        ax.text(2.2, 3.5, f'As[-]: {As_negativo_izquierda_valor}', fontsize=7, ha='center', color='red',fontweight='bold')  # Coloca el texto justo sobre la línea As[-]
        
        # Agregar una línea vertical roja en la coordenada x = 1.2
        y_vertical = [2.5, 3.3]  
        ax.plot([1.2, 1.2], y_vertical, 'r-', linewidth=2)  # Línea vertical roja

        # Copiar la línea As[-] y moverla a la derecha
        As_negativo_copia = [x + 5 for x in As_negativo]  
        ax.plot(As_negativo_copia, y_linea_negativa, 'r-', linewidth=2)  # Copia de As[-] en roja

        # Agregar el texto con el valor de As_negativo_derecha
        ax.text(8.9, 3.5, f'As[-]: {As_negativo_derecha_valor}', fontsize=7, ha='center', color='red',fontweight='bold')  # Coloca el texto justo sobre la línea copiada
        
        # Copiar la línea vertical y moverla a la derecha
        x_vertical_copia = 1.2 + 8.6  
        ax.plot([x_vertical_copia, x_vertical_copia], y_vertical, 'r-', linewidth=2)  # Copia de la línea vertical roja

        # Definir las coordenadas de la línea As_compresión
        As_compresion = [1.3, 4.5]  
        y_linea_compresion = [1.85, 1.85]  

        # Dibujar la línea As_compresión en color verde
        ax.plot(As_compresion, y_linea_compresion, 'g-', linewidth=2, label='As_compresión')  # Línea verde
        
        # Agregar el texto con el valor de Barras_compresion
        ax.text(2.9, 1.9, f"As': {Barras_compresion_valor}", fontsize=7, ha='center', color='green', fontweight='bold')
        
        # Agregar una línea vertical verde en la coordenada x = 1.3
        y_vertical_verde = [1.85, 2.5]  # Ajuste del rango en el eje y para la línea vertical verde
        ax.plot([1.3, 1.3], y_vertical_verde, 'g-', linewidth=2)  # Línea vertical verde

        # Hacer una copia de la línea As_compresión y moverla a la derecha
        As_compresion_copia = [x + 5.2 for x in As_compresion]  
        ax.plot(As_compresion_copia, y_linea_compresion, 'g-', linewidth=2)  # Copia de la línea As_compresión en verde
        
        ax.text(8, 1.9, f"As': {Barras_compresion_valor}", fontsize=7, ha='center', color='green', fontweight='bold')
        
        # Hacer una copia de la línea vertical verde y moverla a la derecha
        x_vertical_verde_copia = 1.3 + 8.4  
        ax.plot([x_vertical_verde_copia, x_vertical_verde_copia], y_vertical_verde, 'g-', linewidth=2)  # Copia de la línea vertical verde

        # Definir las coordenadas de la línea As_compresion_centro (más arriba de la línea azul)
        As_compresion_centro = [3.7, 7.3]  # Usamos las mismas coordenadas que As_positivo
        y_linea_compresion_centro = [3.17, 3.17]  

        # Dibujar la nueva línea As_compresion_centro en color naranja
        ax.plot(As_compresion_centro, y_linea_compresion_centro, 'g-', linewidth=2, label='As_compresion_centro')  # Línea naranja
        
        ax.text(5.5, 2.8, f"As': {Barras_compresion_valor}", fontsize=7, ha='center', color='green', fontweight='bold')
        
        # Crear una leyenda personalizada
        legend_elements = [
            Line2D([0], [0], color='blue', lw=2, label=f'As[+]: {As_positivo_centro_valor}'),
            Line2D([0], [0], color='red', lw=2, label=f'As[-] Izq.: {As_negativo_izquierda_valor}'),
            Line2D([0], [0], color='red', lw=2, label=f'As[-] Der.: {As_negativo_derecha_valor}'),
            Line2D([0], [0], color='green', lw=2, label=f"As': {Barras_compresion_valor}"),
            Line2D([0], [0], color='grey', lw=0, marker='s', label=texto_label_seccion_cargas),
            Line2D([0], [0], color='black', lw=2, label=texto_label_seccion_luz)
        ]
        
        # Crear una propiedad de fuente personalizada para el título
        bold_title_font = font_manager.FontProperties(weight='bold', size=7)
        
        ax.legend(
            handles=legend_elements,
            loc='lower center',  # Posición de la leyenda
            bbox_to_anchor=(0.5, -0.081),  # Ajuste de posición
            fontsize=7,
            title='Leyenda',
            title_fontproperties=bold_title_font,  # Negrita para el título
            frameon=True,
            prop={'size': 7, 'weight': 'bold'},
            handlelength=1.5,
            labelspacing=0.4,
            ncol=3,
            edgecolor='lightgrey', 
            facecolor='white'
            
        )
        
        
        
        # Redibujar la figura con todas las líneas
        canvas.draw()
        
        # Llamar a la función guardar_imagen después de dibujar
        guardar_imagen(canvas)

# Ejecutar ambas funciones
Dibujar_Despiece_Aceros_Flexion()

# Variable global para controlar si la ventana ya está abierta
ventana_Ld = None

label_As_negativo_izquierda = tk.Label(ventana,text="",bg="red")
#label_As_negativo_izquierda.place(x=200,y=650,width=100)
label_As_positivo_centro = tk.Label(ventana,text="",bg="blue")
#label_As_positivo_centro.place(x=300,y=650,width=100)
label_As_negativo_derecha = tk.Label(ventana,text="",bg="red")
#label_As_negativo_derecha.place(x=400,y=650,width=100)

label_Ldh_traccion = tk.Label(ventana,text="",bg="green")
#label_Ldh_traccion.place(x=500,y=650,width=100)
label_Ldh_compresion = tk.Label(ventana,text="",bg="blue")
#label_Ldh_compresion.place(x=600,y=650,width=100)
label_Ldh_traccion_longitud = tk.Label(ventana,text="",bg="green")
#label_Ldh_traccion_longitud.place(x=700,y=650,width=100)
label_Ldh_compresion_longitud = tk.Label(ventana,text="",bg="blue")
#label_Ldh_compresion_longitud.place(x=800,y=650,width=100)


def abrir_ventana_longitud_desarrollo():
    global ventana_Ld,frame_despiece, entry_luz_Ld,entry_Wu_Ld,Barras_traccion,Momento_Mu,combo_barras_traccion
    global combo_ψt,combo_ψe,combo_ψs,combo_Cb,combo_λ,combo_db,combo_Ld,combo_datos_fc,boton_calcular_Ld
    global check_button_Ø,combo_barras_diametro,combo_barras_ldc,Barras_compresion,combo_barras_diametro_ldc
    global combo_fc_Ldc,combo_Ldc,label_Ldc_db,label_Ldc_db_1,label_18db_1,label_resultados_Ldc,combo_ganchos,frame_ganchos
    global combo_barras_doblado,label_diametro_doblado_1,label_concreto_λ_factor,label_factor_ψe_1,label_resultado_Ldh_1
    global combo_concreto_Ldh,treeview_Ldh,label_treeview_Ldh,treeview_Ldh_compresion,label_treeview_Ldh_compresion
    global treeview_ganchos,label_treeview_ganchos,boton_agregar_datos,treeview_Ld
    if ventana_Ld is not None and ventana_Ld.winfo_exists():
        return  
    
    # Crear la ventana 
    ventana_Ld = tk.Toplevel()
    ventana_Ld.title("Longitud de desarrollo")
    ventana_Ld.geometry("900x700")  
    ventana_Ld.resizable(False, False)  
    ventana_Ld.attributes('-topmost', True)  
    
    #Crear contenido en la ventana longitud desarrollo
    labelframe_Ld = tk.LabelFrame(ventana_Ld,text="")
    labelframe_Ld.place(x=20,y=20,width=860,height=50)
    
    label_tipo_Ld = tk.Label(labelframe_Ld,text="Tipo viga:")
    label_tipo_Ld .place(x=10,y=10)
    entry_tipo_Ld = tk.Entry(labelframe_Ld)
    entry_tipo_Ld.place(x=80,y=10,width=110)
    
    
    label_seccion_Ld = tk.Label(labelframe_Ld,text="Sección:")
    label_seccion_Ld.place(x=200,y=10)
    entry_seccion_Ld = tk.Entry(labelframe_Ld)
    entry_seccion_Ld.place(x=260,y=10,width=110)
    
    
    label_luz_Ld= tk.Label(labelframe_Ld,text="Luz:")
    label_luz_Ld.place(x=380,y=10)
    entry_luz_Ld = tk.Entry(labelframe_Ld)
    entry_luz_Ld.place(x=420,y=10,width=100)
    
    label_Wu_Ld = tk.Label(labelframe_Ld,text="Wu:")
    label_Wu_Ld.place(x=540,y=10)
    entry_Wu_Ld = tk.Entry(labelframe_Ld)
    entry_Wu_Ld.place(x=570,y=10,width=100)
    
    boton_Ld= ttk.Button(labelframe_Ld,text="Aplicar",command=Dibujar_Despiece_Viga)
    boton_Ld.place(x=700,y=10,width=100)
    
    labelframe_opciones = tk.LabelFrame(ventana_Ld,text="")
    labelframe_opciones.place(x=20,y=640,width=860,height=50)
    
    boton_dibujar_flexion = ttk.Button(ventana_Ld, text="Dibujar",command=Dibujar_Despiece_Aceros_Flexion)
    boton_dibujar_flexion.place(x=200, y=650, width=100)
    
    boton_agregar_datos = ttk.Button(ventana_Ld, text="Agregar datos",command=lambda: agregar_datos_treeview_Ld(treeview_Ld_1, combo_barras_diametro, combo_Ld, treeview_Ldc,
                                combo_barras_ldc,combo_barras_diametro_ldc,label_Ldc_db_1,treeview_ganchos_Ldh,label_Ldh_traccion, label_Ldh_compresion,combo_ganchos,
                                label_Ldh_traccion_longitud, label_Ldh_compresion_longitud,label_ganchos_check,label_icon_Ld, icon_check_on,label_ancho_columna))
    boton_agregar_datos.place(x=400, y=650, width=100)
    
    boton_cancelar_ld = ttk.Button(ventana_Ld, text="Cancelar", command=ventana_Ld.destroy)
    boton_cancelar_ld.place(x=600, y=650, width=100)
    
    tipo_viga_ld = label_tipo_viga_cargas.cget('text')  
    seccion_ld = label_seccion_cargas.cget('text')  
    luz_ld = label_seccion_luz.cget('text')  
    wu_ld = label_seccion_Wu.cget('text') 
    
    entry_tipo_Ld.insert(0,tipo_viga_ld)  
    entry_seccion_Ld.insert(0,seccion_ld)  
    entry_luz_Ld.insert(0, f"{luz_ld} m")  
    entry_Wu_Ld.insert(0, f"{wu_ld} kN/m")  
    
    labelframe_despiece = tk.LabelFrame(ventana_Ld,text="Despiece de aceros a flexión")
    labelframe_despiece.place(x=20,y=80,width=500,height=550)
    frame_despiece = tk.Frame(labelframe_despiece,bg="white")
    frame_despiece.pack(fill="both", expand=True)
    
        
    frame_ld= tk.Frame(ventana_Ld,bd=2,relief="ridge")
    frame_ld.place(x=530,y=87,width=350,height=200)
    
    # Configurar un estilo personalizado para el Notebook
    style = ttk.Style()
    style.configure("CustomNotebook.TNotebook", background="lightgray", tabmargins=[0, 0, 0, 0])
    style.configure("CustomNotebook.TNotebook.Tab", background="white", foreground="black", padding=[10, 2])
    style.map("CustomNotebook.TNotebook.Tab", background=[("selected", "lightgray")])

    # Crear el Notebook
    notebook_ld = ttk.Notebook(frame_ld, style="CustomNotebook.TNotebook")
    notebook_ld.pack(fill="both", expand=True)

    # Crear las pestañas
    tab1_ld = tk.Frame(notebook_ld)
    

    notebook_ld.add(tab1_ld, text="Requisitos NSR-10")
    
    # --- Insertar Canvas y Scrollbar en la pestaña "Requisitos NSR-10" ---
    canvas_ld = tk.Canvas(tab1_ld)
    canvas_ld.pack(side="left", fill="both", expand=True)

    # Crear un Scrollbar vertical para el canvas
    scrollbar_ld = tk.Scrollbar(tab1_ld, orient="vertical", command=canvas_ld.yview)
    scrollbar_ld.place(x=320,y=1,width=20,height=165)

    # Configurar el Scrollbar para que funcione con el Canvas
    canvas_ld.config(yscrollcommand=scrollbar_ld.set)
    
    #Crear contenido en la pestaña "Requisitos NSR-10"
    label_ld = tk.Label(canvas_ld, 
                        text="Nota: La NSR-10 tiene simplificado las fórmulas para el cálculo de la longitud de desarrollo de barras de acero en elementos de concreto reforzado, en función de la resistencia del concreto y del acero, el diámetro de la barra y el tipo de anclaje,según lo estipulado en el Capítulo C.12",
                        justify="left",  
                        wraplength=300)  
    canvas_ld.create_window(157,50, window=label_ld)
    
    label_critica = tk.Label(canvas_ld,
                            text="Sección crítica: Es la sección de la viga en la que el acero experimenta el mayor esfuerzo debido al máximo momento",
                            justify="left",
                            wraplength=300)
    canvas_ld.create_window(160,120, window=label_critica)
    
    label_adherencia = tk.Label(canvas_ld,text="Condiciones para garantizar adherencia",
                                font=("Arial", 9, "bold", "underline"))
    canvas_ld.create_window(160,180, window=label_adherencia)
    
    label_adherencia_info = tk.Label(canvas_ld,
                            text="""1. Si la barra de acero se coloca de manera continua, se debe garantizar que la longitud mínima de desarrollo esté presente en ambos extremos.
2. La colocación de ganchos puede ser de 90° o 180°. La norma establece que se debe garantizar una longitud mínima de desarrollo (Ldh) para los ganchos, la cual debe ser menor que la longitud de desarrollo de la barra.
3. En el caso de la colocación de dobles ganchos de lado a lado, se debe garantizar una longitud mínima de desarrollo (Ldh) en ambos extremos de la sección crítica. Esta longitud Ldh debe ser siempre menor que la longitud de anclaje de la barra.""",
                            justify="left",
                            wraplength=300)
    canvas_ld.create_window(160,300, window=label_adherencia_info)
    
    label_factores = tk.Label(canvas_ld,text="Factores que afectan la longitud de desarrollo",
                            font=("Arial", 9, "bold", "underline"))
    canvas_ld.create_window(160,420, window=label_factores)
    
    label_factores_info = tk.Label(canvas_ld,
                            text="""1. Resistencia del concreto (f'c): A mayor resistencia del concreto, menor será la longitud de desarrollo.
2. Recubrimiento (r): Si se pone poco recubrimiento, la viga puede fallar por adherencia.
3. Separación entre barras (S): No se puede poner las barras muy juntas,por que puede fallar por adherencia.
4  Refuerzo en exceso (ρ): A mayor refuerzo, menor será la longitud de desarrollo.""",
                            justify="left",
                            wraplength=300)
    canvas_ld.create_window(160,510, window=label_factores_info)
    
    label_fallas = tk.Label(canvas_ld,text="Tipo de falla por adherencia",
                            font=("Arial", 9, "bold", "underline"))
    canvas_ld.create_window(160,600, window=label_fallas)
    
    label_fallas_info = tk.Label(canvas_ld,
                            text="1. Desprendimiento de las barras:\nHay un desprendimientos de las barras de acero en el concreto y se presenta grietas paralelo a la posición del acero.",
                            justify="left",
                            wraplength=300)
    canvas_ld.create_window(160,650, window=label_fallas_info)     
    
    label_NSR_10 = tk.Label(canvas_ld,text="La norma establece que, como mínimo, la longitud de desarrollo debe ser igual o superior a 30 cm. No obstante, es posible reducir esta longitud utilizando la fórmula general para calcular la longitud de desarrollo (Ld), que se encuentra en el índice C.12.2.3., según la siguiente fórmula:",
                            justify="left",
                            wraplength=300)
    canvas_ld.create_window(160,750, window=label_NSR_10)
    
    frame_ld= tk.Frame(canvas_ld,bd=4,relief="ridge")
    canvas_ld.create_window(160,870, window=frame_ld,width=200,height=110)
    
    # Cargar la imagen
    # Ruta relativa para la imagen
    image_ld_path = os.path.join("Iconos_proyecto", "Formula_Ld.png")  # Ruta relativa de la imagen
    image_ld = Image.open(image_ld_path)
    image_ld = image_ld.resize((200, 110))  # Redimensionar la imagen si es necesario
    
    # Convertir la imagen a un formato que Tkinter pueda manejar
    photo_ld = ImageTk.PhotoImage(image_ld)
    
    # Insertar la imagen en un Label dentro del Frame
    label_ecuacion = tk.Label(frame_ld, image=photo_ld)
    label_ecuacion.image = photo_ld  # Guardar una referencia de la imagen
    label_ecuacion.pack()
    
    label_parametros = tk.Label(canvas_ld,text="""Parámetros de Cálculo:
- f'c: Resistencia a la compreción del concreto
- fy: Esfuerzo de fluencia del acero
- λ: Factor por peso del concreto
- ψt: Factor colocación del acero
- ψe: Factor de recubrimiento epóxico 
- ψs: Factor del diametro del refuerzo 
- Cb: Distancia mínima entre barras de refuerzo longitudinal o distancia al borde
- Ktr: La norma permite considerar un valor de 0 como una opción conservadora
- db: Diámetro de la barra de refuerzo""",
                            justify="left",
                            wraplength=300)
    canvas_ld.create_window(160,1030, window=label_parametros)
    
    label_compresión = tk.Label(canvas_ld,text="Longitud desarrollo a compresión",font=("Arial", 9, "bold", "underline"))
    canvas_ld.create_window(160,1150, window=label_compresión)
    
    label_compresión_info = tk.Label(canvas_ld,text="""La norma establece que, para las barras sometidas a compresión, la longitud de desarrollo mínima (Ldc) debe ser de 20 cm. Si se requiere una longitud menor, esta deberá calcularse utilizando la fórmula:
* Ldc = [0.24 * fy] / [λ * √f'c] * db
* Ldc = [0.043 * fy * db]""",
                            justify="left",
                            wraplength=300)
    canvas_ld.create_window(160,1220, window=label_compresión_info)
    
    label_ganchos_As = tk.Label(canvas_ld,text="Longitud de desarrollo para ganchos a tracción",font=("Arial", 9, "bold", "underline"))
    canvas_ld.create_window(160,1290, window=label_ganchos_As)
    
    label_ganchos_As_info = tk.Label(canvas_ld,text="""La norma establece los requisitos para los ganchos estándar sometidos a tracción en el índice C.12.5. Existen dos tipos de ganchos: a 90° y a 180°. Para el gancho de 180°, deben cumplirse las siguientes condiciones:

1- El diámetro de doblez debe cumplir con las condiciones mínimas especificadas en la norma.
2- La extensión mínima, medida desde el final del diámetro de doblez hasta el extremo del gancho, debe ser al menos 4 veces el diámetro de la barra o, como mínimo, 6.5 cm.\n
Para el gancho de 90°, se deben cumplir las siguientes condiciones:
1- Extensión mínima: Al finalizar el doblado de la barra, la extensión mínima deberá ser 12 veces el diámetro de la barra (12db)
2- Longitud de desarrollo con ganchos (Ldh): Según lo indicado en el índice C.12.5.3 de la norma, la longitud de desarrollo con ganchos debe medirse desde el extremo del gancho y debe ser igual o mayor a 8 veces el diámetro de la barra (8db) o 15 cm, esta longitud debe ser suficiente para llegar hasta la sección crítica de la barra.\n
La fórmula para calcular la longitud de desarrollo con ganchos (Ldh) es:""",
                            justify="left",
                            wraplength=300)
    canvas_ld.create_window(160,1530, window=label_ganchos_As_info)
    
    frame_formula_ganchos = tk.Frame(canvas_ld,bd=4,relief="ridge")
    canvas_ld.create_window(160,1790, window=frame_formula_ganchos,width=200,height=40)
    
    # Ruta de la imagen
    # Ruta relativa de la imagen
    ruta_imagen_gancho = os.path.join("Iconos_proyecto", "Ldh.png")
    # Abrir la imagen con PIL
    imagen_gancho = Image.open(ruta_imagen_gancho)
    # Redimensionar la imagen si es necesario
    imagen_gancho = imagen_gancho.resize((200, 40))

    # Convertir la imagen a un formato que Tkinter pueda manejar (ImageTk.PhotoImage)
    foto_gancho = ImageTk.PhotoImage(imagen_gancho)

    # Insertar la imagen en un Label dentro del Frame
    label_ecuacion_gancho = tk.Label(frame_formula_ganchos, image=foto_gancho)
    label_ecuacion_gancho.image = foto_gancho  # Mantener una referencia de la imagen
    label_ecuacion_gancho.pack()
    
    label_doblado = tk.Label(canvas_ld,text="""Diámetro de doblado: El diámetro de doblado varía según el tipo de barra y se especifica de la siguiente manera:

- Para barras de #3 a #8, el diámetro de doblado será igual a 6 veces el diámetro de la barra (6db).
- Para barras de #9 a #11, el diámetro de doblado será igual a 8 veces el diámetro de la barra (8db).
- Para barras de #14 a #18, el diámetro de doblado será igual a 10 veces el diámetro de la barra (10db).""",
                            justify="left",
                            wraplength=300)
    canvas_ld.create_window(160,1900, window=label_doblado)
    
    frame_calculo_Ld= tk.Frame(ventana_Ld,bd=2,relief="ridge")
    frame_calculo_Ld.place(x=530,y=300,width=350,height=330)
    
    # Configurar un estilo personalizado para el Notebook
    style = ttk.Style()
    style.configure("CustomNotebook.TNotebook", background="lightgray", tabmargins=[0, 0, 0, 0])
    style.configure("CustomNotebook.TNotebook.Tab", background="white", foreground="black", padding=[10, 2])
    style.map("CustomNotebook.TNotebook.Tab", background=[("selected", "lightgray")])
    
    # Crear el Notebook
    notebook_calculo = ttk.Notebook(frame_calculo_Ld, style="CustomNotebook.TNotebook")
    notebook_calculo.pack(fill="both", expand=True)
    
    # Crear las pestañas
    tab1_calculo = tk.Frame(notebook_calculo)
    
    
    notebook_calculo.add(tab1_calculo, text="Cálculos previos")
    
    # --- Insertar Canvas y Scrollbar en la pestaña "Requisitos NSR-10" ---
    canvas_calculo = tk.Canvas(tab1_calculo)
    canvas_calculo.pack(side="left", fill="both", expand=True)
    
    # Crear un Scrollbar vertical para el canvas
    scrollbar_calculo = tk.Scrollbar(tab1_calculo, orient="vertical", command=canvas_calculo.yview)
    scrollbar_calculo.place(x=320,y=1,width=20,height=295)
    
    # Configurar el Scrollbar para que funcione con el Canvas
    canvas_calculo.config(yscrollcommand=scrollbar_calculo.set)
    
    #Crear contenido en la pestaña "Cálculos previos"
    labelframe_datos = tk.LabelFrame(canvas_calculo,text="")
    canvas_calculo.create_window(160,35, window=labelframe_datos,width=300,height=50)
    
    label_datos_fc = tk.Label(labelframe_datos,text="f'c:")
    label_datos_fc.place(x=10,y=10)
    
    combo_datos_fc = ttk.Combobox(labelframe_datos, values=["17.5 Mpa", "21 Mpa", "24.5 Mpa", "28 Mpa", "35 Mpa", "42 Mpa"])
    combo_datos_fc.place(x=40,y=10,width=80)
    
    label_datos_fy = tk.Label(labelframe_datos,text="fy:")
    label_datos_fy.place(x=150,y=10)
    
    combo_datos_fy = ttk.Combobox(labelframe_datos, values=["420 Mpa"])
    combo_datos_fy.place(x=180,y=10,width=80)
    
    labelframe_calculo = tk.LabelFrame(canvas_calculo,text="")
    canvas_calculo.create_window(160,170, window=labelframe_calculo,width=300,height=200)
    
    label_barras_traccion = tk.Label(labelframe_calculo,text="#Barras:")
    label_barras_traccion.place(x=10,y=10)
    
    combo_barras_traccion = ttk.Combobox(labelframe_calculo)
    combo_barras_traccion.place(x=60,y=10,width=80)
    
    label_diametro_barras = tk.Label(labelframe_calculo,text="ØBarras:")
    label_diametro_barras.place(x=10,y=160)
    combo_barras_diametro = ttk.Combobox(labelframe_calculo)
    combo_barras_diametro.place(x=60,y=160,width=80)
    
    check_button_Ø= tk.Checkbutton(labelframe_calculo,text="Agregar diámetro")
    check_button_Ø.place(x=150,y=160)
    
    check_button_Ø.config(command=agregar_diametros_barras)
    
    boton_traccion = ttk.Button(labelframe_calculo,text="Agregar")
    boton_traccion.place(x=180,y=5,width=80)
    
    # Asignar la función al botón para agregar los datos
    boton_traccion.config(command=lambda: agregar_datos_treeview(treeview_ld))
    
    # Asignar los mismos valores de Barras_traccion a combo_barras_traccion
    combo_barras_traccion['values'] = Barras_traccion['values']
    
    # Si hay algún valor seleccionado en Barras_traccion, seleccionarlo también en combo_barras_traccion
    if Barras_traccion.get():
        combo_barras_traccion.set(Barras_traccion.get())
    
    # Crear el Treeview para la tabla con 2 columnas
    treeview_ld = ttk.Treeview(labelframe_calculo, columns=("Mu", "As"), show="headings")
    treeview_ld.place(x=40, y=50, width=200, height=100)
    
    # Definir los encabezados de las columnas
    treeview_ld.heading("Mu", text="Mu")
    treeview_ld.heading("As", text="#Barra")
        
    # Insertar tres filas con valores de ejemplo para las columnas Mu y As
    treeview_ld.insert("", "end", values=("", ""))
    treeview_ld.insert("", "end", values=("", ""))
    treeview_ld.insert("", "end", values=("", ""))
    
    def no_resize(event):
    # Restaurar el tamaño original de las columnas "Mu" y "As" usando un ciclo
        for col in treeview_ld["columns"]:
            treeview_ld.column(col, width=98, anchor="center")
    
    # Definir el ancho de las columnas (100px como tamaño original) y evitar que se estiren
    for col in treeview_ld["columns"]:
        treeview_ld.column(col, width=98, anchor="center", stretch=False)
    
    # Vincular el evento de clic con la función no_resize
    treeview_ld.bind("<ButtonRelease-1>", no_resize)
    
    labelframe_factores = tk.LabelFrame(canvas_calculo,text="Factores de reducción [Ld]")
    canvas_calculo.create_window(160,440, window=labelframe_factores,width=300,height=320)
    
    label_ψt = tk.Label(labelframe_factores,text="ψt:")
    label_ψt.place(x=60,y=10)
    
    combo_ψt = ttk.Combobox(labelframe_factores, values=["1.0","1.3"])
    combo_ψt.place(x=100,y=10,width=110)
    combo_ψt.set("Seleccionar")
    
    label_ψe = tk.Label(labelframe_factores,text="ψe:")
    label_ψe.place(x=60,y=50)
    
    combo_ψe = ttk.Combobox(labelframe_factores, values=["1.0"])
    combo_ψe.place(x=100,y=50,width=110)
    combo_ψe.set("Seleccionar")
    
    label_ψs = tk.Label(labelframe_factores,text="ψs:")
    label_ψs.place(x=60,y=90)
    
    combo_ψs = ttk.Combobox(labelframe_factores, values=["0.8","1.0"]) 
    combo_ψs.place(x=100,y=90,width=110)
    combo_ψs.set("Seleccionar")
    
    label_λ = tk.Label(labelframe_factores,text="λ:")
    label_λ.place(x=60,y=130)
    
    combo_λ = ttk.Combobox(labelframe_factores, values=["0.75","1.0"])
    combo_λ.place(x=100,y=130,width=110)
    combo_λ.set("Seleccionar")
    
    label_Cb = tk.Label(labelframe_factores,text="Cb:")
    label_Cb.place(x=60,y=170)
    
    combo_Cb = ttk.Combobox(labelframe_factores, values=["25.4 mm"])
    combo_Cb.place(x=100,y=170,width=110)
    combo_Cb.set("Seleccionar")
    
    label_Ktr = tk.Label(labelframe_factores,text="Ktr:")
    label_Ktr.place(x=60,y=210)
    
    combo_Ktr = ttk.Combobox(labelframe_factores, values=["0.0"])
    combo_Ktr.place(x=100,y=210,width=110)
    combo_Ktr.set("Seleccionar")
    
    label_db = tk.Label(labelframe_factores,text="db:")
    label_db.place(x=60,y=250)
    
    combo_db = ttk.Combobox(labelframe_factores, values=[])
    combo_db.place(x=100,y=250,width=110)
    combo_db.set("Seleccionar")
    
    labelframe_resultados = tk.LabelFrame(canvas_calculo,text="Cálcular Ld para barras a tracción")
    canvas_calculo.create_window(160,640, window=labelframe_resultados,width=300,height=70)
    
    label_Ld = tk.Label(labelframe_resultados,text="Ld:")
    label_Ld.place(x=30,y=10)
    
    combo_Ld = ttk.Combobox(labelframe_resultados, values=[])
    combo_Ld.place(x=70,y=10,width=110)
    combo_Ld.set("Seleccionar")
    
    boton_calcular_Ld = ttk.Button(labelframe_resultados,text="Calcular")
    boton_calcular_Ld.place(x=200,y=5,width=80)
    
    boton_calcular_Ld.config(command=calcular_Ld_traccion)
    
    labelframe_comprobación = tk.LabelFrame(canvas_calculo,text="Cálcular Ld para barras a compresión Ldc ≥ 20 cm")
    canvas_calculo.create_window(160,790, window=labelframe_comprobación,width=300,height=200)
    
    label_Ldc = tk.Label(labelframe_comprobación,text="En el caso de barras sometidas a compresión, la norma establece que la longitud mínima de desarrollo (Ldc) debe ser ≥ 20 cm. Sin embargo, se deben evaluar dos condiciones para Ldc. Dependiendo de cuál de los resultados sea más favorable, se seleccionará el que cumpla con los requisitos para el diseño.",
                            justify="left",
                            wraplength=280)
    
    label_Ldc.place(x=10,y=10)
    
    label_barras_ldc = tk.Label(labelframe_comprobación,text="#Barras:")
    label_barras_ldc.place(x=10,y=140)
    
    combo_barras_ldc = ttk.Combobox(labelframe_comprobación, values=[])
    combo_barras_ldc.place(x=60,y=140,width=80)
    
    label_diametro_barras_ldc = tk.Label(labelframe_comprobación,text="ØBarras:")
    label_diametro_barras_ldc.place(x=150,y=140)
    
    combo_barras_diametro_ldc = ttk.Combobox(labelframe_comprobación, values=[])
    combo_barras_diametro_ldc.place(x=206,y=140,width=80)
    
    labelframe_resultados_ldc = tk.LabelFrame(canvas_calculo,text="Cálcular Ldc para barras a compresión")
    canvas_calculo.create_window(160,940, window=labelframe_resultados_ldc,width=300,height=100)
    
    label_fc_Ldc = tk.Label(labelframe_resultados_ldc,text="f'c:")
    label_fc_Ldc.place(x=10,y=10)
    
    combo_fc_Ldc = ttk.Combobox(labelframe_resultados_ldc, values=["17.5 Mpa", "21 Mpa", "24.5 Mpa", "28 Mpa", "35 Mpa", "42 Mpa"])
    combo_fc_Ldc.place(x=40,y=10,width=80)
    
    combo_fc_Ldc.bind("<<ComboboxSelected>>", Calcular_Ldc_compresion)
    
    label_Ldc = tk.Label(labelframe_resultados_ldc,text="Ldc:")
    label_Ldc.place(x=150,y=10)
    
    combo_Ldc = ttk.Combobox(labelframe_resultados_ldc, values=[])
    combo_Ldc.place(x=180,y=10,width=80)
    
    label_Ldc_db = tk.Label(labelframe_resultados_ldc,text="")
    label_Ldc_db.place(x=1,y=40)
    
    label_Ldc_db_1 = tk.Label(labelframe_resultados_ldc,bd=2,relief="sunken")
    label_Ldc_db_1.place(x=40,y=40,width=80)
    
    label_18db = tk.Label(labelframe_resultados_ldc,text="18db:")
    label_18db.place(x=145,y=40)
    
    label_18db_1 = tk.Label(labelframe_resultados_ldc,bd=2,relief="sunken")
    label_18db_1.place(x=180,y=40,width=80)
    
    labelframe_resultados_Ldc = tk.LabelFrame(canvas_calculo,text="")
    canvas_calculo.create_window(160,1028, window=labelframe_resultados_Ldc,width=300,height=60)
    
    label_resultados_Ldc = tk.Label(labelframe_resultados_Ldc,text="",
                                    justify="left",
                                    wraplength=280)
    label_resultados_Ldc.place(x=10,y=5)
    
    labelframe_ganchos = tk.LabelFrame(canvas_calculo,text="Especificaciones para ganchos a tracción")
    canvas_calculo.create_window(160,1220, window=labelframe_ganchos,width=300,height=300)
    
    label_ganchos_titulo = tk.Label(labelframe_ganchos,text="C.12.5.1 (Ganchos estandar en tracción)")
    label_ganchos_titulo.place(x=10,y=10)
    
    label_ganchos = tk.Label(labelframe_ganchos,text="Ganchos:")
    label_ganchos.place(x=10,y=40)
    
    combo_ganchos = ttk.Combobox(labelframe_ganchos, values=["90°","180°"])
    combo_ganchos.place(x=70,y=40,width=100)
    combo_ganchos.set("Seleccionar")
    
    # Vincular el evento de selección al Combobox
    combo_ganchos.bind("<<ComboboxSelected>>", actualizar_imagen)
    
    frame_ganchos = tk.Frame(labelframe_ganchos,bd=4,relief="ridge",bg="white")
    frame_ganchos.place(x=40,y=70,width=210,height=200)
    
    labelframe_doblado = tk.LabelFrame(canvas_calculo,text="Especificaciones para diámetro de doblado")
    canvas_calculo.create_window(160,1430, window=labelframe_doblado,width=300,height=100)
    
    label_barra_doblado = tk.Label(labelframe_doblado,text="#Barras:")
    label_barra_doblado.place(x=50,y=10)
    
    combo_barras_doblado = ttk.Combobox(labelframe_doblado,values=list(barras_info_refuerzo_1.keys()))
    combo_barras_doblado.place(x=120,y=10,width=100)
    combo_barras_doblado.set("Seleccionar")
    
    # Vincular el evento de selección del Combobox con la función diametro_de_doblado
    combo_barras_doblado.bind("<<ComboboxSelected>>", diametro_de_doblado)
    
    label_diametro_doblado = tk.Label(labelframe_doblado,text="ØDoblado:")
    label_diametro_doblado.place(x=50,y=50)
    
    label_diametro_doblado_1 = tk.Label(labelframe_doblado,bd=2,relief="sunken")
    label_diametro_doblado_1.place(x=120,y=50,width=100)
    
    labelframe_longitud_desarrollo = tk.LabelFrame(canvas_calculo,text="Longitud de desarrollo con ganchos")
    canvas_calculo.create_window(160,1560, window=labelframe_longitud_desarrollo,width=300,height=140)
    
    label_Ldh = tk.Label(labelframe_longitud_desarrollo,text="Según la NSR-10, la longitud de desarrollo Ldh debe ser menor que la longitud normal de desarrollo.Esta longitud mínima (Ldh) se mide desde el extremo del gancho hasta la sección crítica de la barra.La longitud mínima de Ldh debe ser al menos 8db, o 15 cm como mínimo.",
                            justify="left",
                            wraplength=275)
    label_Ldh.place(x=10,y=10)
    
    labelframe_Calcular_Ldh = tk.LabelFrame(canvas_calculo,text="Cálcular Ldh con ganchos")
    canvas_calculo.create_window(160,1710, window=labelframe_Calcular_Ldh,width=300,height=150)
    
    label_concreto_Ldh = tk.Label(labelframe_Calcular_Ldh,text="Concreto:")
    label_concreto_Ldh.place(x=50,y=10)
    
    combo_concreto_Ldh = ttk.Combobox(labelframe_Calcular_Ldh, values=["Peso liviano","Peso normal"])
    combo_concreto_Ldh.place(x=120,y=10,width=100)
    
    combo_concreto_Ldh.bind("<<ComboboxSelected>>", lambda event: Calcular_Ldh())
    
    label_concretro_λ = tk.Label(labelframe_Calcular_Ldh,text="Factor [λ]:")
    label_concretro_λ.place(x=50,y=40)
    
    label_concreto_λ_factor = tk.Label(labelframe_Calcular_Ldh,bd=2,relief="sunken")
    label_concreto_λ_factor.place(x=120,y=40,width=100)
    
    label_factor_ψe = tk.Label(labelframe_Calcular_Ldh,text="Factor [ψe]:")
    label_factor_ψe.place(x=50,y=70)
    
    label_factor_ψe_1 = tk.Label(labelframe_Calcular_Ldh,bd=2,relief="sunken")
    label_factor_ψe_1.place(x=120,y=70,width=100)
    
    label_resultado_Ldh = tk.Label(labelframe_Calcular_Ldh,text="Ldh:")
    label_resultado_Ldh.place(x=50,y=100)
    
    label_resultado_Ldh_1 = tk.Label(labelframe_Calcular_Ldh,bd=2,relief="sunken")
    label_resultado_Ldh_1.place(x=120,y=100,width=100)
    
    labelframe_tabla_Ldh = tk.LabelFrame(canvas_calculo,text="Tabla mínimo Ldh a tracción")
    canvas_calculo.create_window(160,1890, window=labelframe_tabla_Ldh,width=300,height=200)
    
    # Crear la tabla Treeview dentro del LabelFrame
    treeview_Ldh = ttk.Treeview(labelframe_tabla_Ldh, columns=("barra", "ldh", "traccion"), show="headings")
    treeview_Ldh.place(x=50, y=10, width=200, height=80)
    
    # Definir las columnas
    treeview_Ldh.heading("barra", text="#Barra")
    treeview_Ldh.heading("ldh", text="Ldh (cm)")
    treeview_Ldh.heading("traccion", text="Tracción")
    
    # Configurar el ancho de las columnas
    treeview_Ldh.column("barra", width=50,anchor="center")
    treeview_Ldh.column("ldh", width=50,anchor="center")
    treeview_Ldh.column("traccion", width=50,anchor="center")
    
    # Insertar una fila de ejemplo (puedes agregar más filas según necesites)
    treeview_Ldh.insert("", "end", values=("", "" , "As[-]"))
    
    def no_resize(event):
    # Restaurar el tamaño original de las columnas usando un ciclo
        for col in treeview_Ldh["columns"]:
            treeview_Ldh.column(col, width=66, anchor="center")
    
    # Vincular el evento de clic con la función no_resize
    treeview_Ldh.bind("<ButtonRelease-1>", no_resize)
    
    label_treeview_Ldh = tk.Label(labelframe_tabla_Ldh,text="",
                            justify="left",
                            wraplength=285)
    label_treeview_Ldh.place(x=10,y=100)
    
    labelframe_tabla_Ldh_compresion = tk.LabelFrame(canvas_calculo,text="Tabla mínimo Ldh a compresión")
    canvas_calculo.create_window(160,2100, window=labelframe_tabla_Ldh_compresion,width=300,height=200)
    
    # Crear la tabla Treeview dentro del LabelFrame
    treeview_Ldh_compresion = ttk.Treeview(labelframe_tabla_Ldh_compresion, columns=("barra", "ldh", "compresión"), show="headings")
    treeview_Ldh_compresion.place(x=50, y=10, width=200, height=80)
    
    # Definir las columnas
    treeview_Ldh_compresion.heading("barra", text="#Barra")
    treeview_Ldh_compresion.heading("ldh", text="Ldh (cm)")
    treeview_Ldh_compresion.heading("compresión", text="Compresión")
    
    # Configurar el ancho de las columnas
    treeview_Ldh_compresion.column("barra", width=40,anchor="center")
    treeview_Ldh_compresion.column("ldh", width=40,anchor="center")
    treeview_Ldh_compresion.column("compresión", width=60,anchor="center")
    
    # Insertar una fila de ejemplo (puedes agregar más filas según necesites)
    treeview_Ldh_compresion.insert("", "end", values=("", "" , "As'"))
    
    # Función que previene el cambio de tamaño de las columnas
    def no_resize(event):
    # Definir los anchos específicos para cada columna
        treeview_Ldh_compresion.column("barra", width=50, anchor="center")  # Columna #Barra con ancho 60
        treeview_Ldh_compresion.column("ldh", width=60, anchor="center")     # Columna Ldh con ancho 60
        treeview_Ldh_compresion.column("compresión", width=87, anchor="center")  # Columna Compresión con ancho 70
    
    # Vincular el evento de clic con la función no_resize
    treeview_Ldh_compresion.bind("<ButtonRelease-1>", no_resize)
    
    label_treeview_Ldh_compresion = tk.Label(labelframe_tabla_Ldh_compresion,text="",justify="left",wraplength=285)
    label_treeview_Ldh_compresion.place(x=10,y=100)
    
    labelframe_ganchos_estandar = tk.LabelFrame(canvas_calculo,text="Calcular Longitud del gancho mínimo")
    canvas_calculo.create_window(160,2320, window=labelframe_ganchos_estandar,width=300,height=220)
    
    # Crear la tabla Treeview dentro del LabelFrame
    treeview_ganchos = ttk.Treeview(labelframe_ganchos_estandar, columns=("barra", "gancho", "longitud"), show="headings")
    treeview_ganchos.place(x=50, y=10, width=200, height=80)
    
    # Definir las columnas
    treeview_ganchos.heading("barra", text="#Barra")
    treeview_ganchos.heading("gancho", text="Gancho")
    treeview_ganchos.heading("longitud", text="Longitud")
    
    # Configurar el ancho de las columnas
    treeview_ganchos.column("barra", width=50,anchor="center")
    treeview_ganchos.column("gancho", width=50,anchor="center")
    treeview_ganchos.column("longitud", width=50,anchor="center")
    
    # Insertar una fila de ejemplo (puedes agregar más filas según necesites)
    treeview_ganchos.insert("", "end", values=("", "" , ""))
    treeview_ganchos.insert("", "end", values=("", "" , ""))
    
    label_treeview_ganchos = tk.Label(labelframe_ganchos_estandar,text="",justify="left",wraplength=280)
    label_treeview_ganchos.place(x=10,y=100)
    
    def no_resize(event):
    # Restaurar el tamaño original de las columnas usando un ciclo
        for col in treeview_ganchos["columns"]:
            treeview_ganchos.column(col, width=66, anchor="center")
    
    # Vincular el evento de clic con la función no_resize
    treeview_ganchos.bind("<ButtonRelease-1>", no_resize)
    
    # Función para ajustar el tamaño del canvas y el área de desplazamiento
    def update_scrollregion_calculo(event=None):
        bbox_calculo = canvas_calculo.bbox("all")  # Obtiene las coordenadas del área de todo el contenido
        if bbox_calculo:
            # Añadir un margen adicional de 100 píxeles a las coordenadas del área
            canvas_calculo.config(scrollregion=(0, 0, bbox_calculo[2] + 100, bbox_calculo[3] + 10))

    # Llamar a update_scrollregion para ajustar el área de desplazamiento
    canvas_calculo.bind("<Configure>", update_scrollregion_calculo)

    # Actualizar el área de scroll después de agregar contenido
    canvas_calculo.update_idletasks()
    canvas_calculo.config(scrollregion=canvas_calculo.bbox("all"))
    
    # Función para ajustar el tamaño del canvas y el área de desplazamiento
    def update_scrollregion(event=None):
        bbox_ld = canvas_ld.bbox("all")  # Obtiene las coordenadas del área de todo el contenido
        if bbox_ld:
            # Añadir un margen adicional de 100 píxeles a las coordenadas del área
            canvas_ld.config(scrollregion=(0, 0, bbox_ld[2] + 100, bbox_ld[3] + 10))

    # Llamar a update_scrollregion para ajustar el área de desplazamiento
    canvas_ld.bind("<Configure>", update_scrollregion)

    # Actualizar el área de scroll después de agregar contenido
    canvas_ld.update_idletasks()
    canvas_ld.config(scrollregion=canvas_ld.bbox("all"))


def agregar_datos_treeview(treeview_ld):
    # Obtener todos los valores seleccionados en el ComboBox Momento_Mu
    momento_mu_values = Momento_Mu['values']  # Momento_Mu es el ComboBox de la ventana principal
    
    # Obtener los valores seleccionados en el ComboBox combo_barras_traccion
    barras_traccion_values = combo_barras_traccion['values']  # combo_barras_traccion es otro ComboBox
    
    # Verificar si ambos ComboBoxes tienen al menos tres valores
    if len(momento_mu_values) >= 3 and len(barras_traccion_values) >= 3:
        # Asignar los valores a las filas del Treeview
        for i in range(3):  # Recorremos las 3 filas
            # Actualizar la primera columna "Mu" con los valores de Momento_Mu
            # Actualizar la segunda columna "As" con los valores de combo_barras_traccion
            treeview_ld.item(treeview_ld.get_children()[i], values=(momento_mu_values[i], barras_traccion_values[i]))
            
    # Ahora actualizamos las etiquetas con los valores de la columna "As"
        # Asignar el valor de la primera fila en la columna "As" a label_As_negativo_izquierda
        label_As_negativo_izquierda.config(text=barras_traccion_values[0])

        # Asignar el valor de la segunda fila en la columna "As" a label_As_positivo_centro
        label_As_positivo_centro.config(text=barras_traccion_values[1])

        # Asignar el valor de la tercera fila en la columna "As" a label_As_negativo_derecha
        label_As_negativo_derecha.config(text=barras_traccion_values[2])

def agregar_diametros_barras():
    # Obtener todos los valores del combo_barras_traccion (sin separar por coma)
    valores_traccion = combo_barras_traccion['values']  # Obtiene la lista completa de valores
    
    # Lista para almacenar los diámetros correspondientes
    diametros = []
    
    # Recorrer cada valor de barra de tracción seleccionada
    for valor in valores_traccion:
        # Extraer el número de la barra (último número después del "#")
        if "#" in valor:
            numero_barra = valor.split("#")[-1]
            
            # Buscar el diámetro de esa barra en el diccionario
            for barra, info in barras_info_refuerzo.items():
                if f"No.{numero_barra}" in barra:
                    diametros.append(f"Ø {info['diametro_mm']} mm")
                    break
    
    # Actualizar los valores del combo_barras_diametro con los diámetros encontrados
    combo_barras_diametro['values'] = diametros  # Asigna la lista completa de diámetros a combo_barras_diametro

    # Si hay diámetros disponibles, se selecciona el primero de ellos por defecto (opcional)
    if diametros:
        combo_barras_diametro.set(diametros[0])  # Selecciona el primer valor por defecto
    
    # Actualizar los valores del combo_db con los mismos diámetros encontrados
    combo_db['values'] = diametros  # Asigna la lista completa de diámetros a combo_db

    # Si hay diámetros disponibles, se selecciona el primero de ellos por defecto (opcional)
    if diametros:
        combo_db.set(diametros[0])  # Selecciona el primer valor por defecto
    
    # ---- Lógica para actualizar combo_barras_ldc ----
    
    # Obtener el valor seleccionado de Barras_compresion
    valor_compresion = Barras_compresion.get()
    
    # Lista para almacenar los valores correspondientes en combo_barras_ldc
    valores_ldc = []
    
    if valor_compresion:
        # Solo añadimos el valor seleccionado en Barras_compresion a combo_barras_ldc
        valores_ldc.append(valor_compresion)
    
    # Actualizar los valores del combo_barras_ldc con los valores encontrados
    combo_barras_ldc['values'] = valores_ldc
    
    # Si hay valores disponibles, seleccionar el primero (opcional)
    if valores_ldc:
        combo_barras_ldc.set(valores_ldc[0])  # Selecciona el primer valor por defecto
    
    # ---- Nueva lógica para actualizar combo_barras_diametro_ldc ----
    
    # Obtener el valor seleccionado de combo_barras_ldc (que es el mismo que el de Barras_compresion)
    valor_ldc = combo_barras_ldc.get()
    
    # Lista para almacenar los diámetros correspondientes en combo_barras_diametro_ldc
    diametros_ldc = []
    
    if valor_ldc:
        # Extraemos el último dígito (el número después del "#") del valor seleccionado en combo_barras_ldc
        numero_barra_ldc = valor_ldc.split("#")[-1]
        
        # Buscar el diámetro correspondiente en el diccionario barras_info_refuerzo
        for barra, info in barras_info_refuerzo.items():
            if f"No.{numero_barra_ldc}" in barra:
                # Añadir el diámetro correspondiente a la lista diametros_ldc
                diametros_ldc.append(f"Ø {info['diametro_mm']} mm")
                break
    
    # Actualizar el combo_barras_diametro_ldc con el diámetro encontrado
    combo_barras_diametro_ldc['values'] = diametros_ldc
    
    # Si hay un diámetro disponible, seleccionamos el primero (opcional)
    if diametros_ldc:
        combo_barras_diametro_ldc.set(diametros_ldc[0])  # Selecciona el primer valor por defecto


def calcular_Ld_traccion():
    # Obtener los valores de los combos
    fy = 420
    fc = combo_datos_fc.get()  # Obtener el valor de fc
    fc = float(fc.split()[0])  # Extraer solo el valor numérico (ej. "17.5")
    
    # Obtener los valores de los factores
    ψt = float(combo_ψt.get())  # ψt
    ψe = float(combo_ψe.get())  # ψe
    ψs = float(combo_ψs.get())  # ψs
    λ = float(combo_λ.get())    # λ
    
    # Extraer el valor numérico de Cb sin la unidad "mm"
    Cb_str = combo_Cb.get()  # Valor con unidad (ej. "25.4 mm")
    Cb = float(Cb_str.split()[0])  # Obtener solo la parte numérica antes del espacio
    
    db_values = combo_db['values']  # Obtener los diámetros de combo_db
    
    # Lista para almacenar los resultados redondeados
    resultados_Ld = []
    
    # Calcular Ld_tracción para cada valor de db
    for db_value in db_values:
        db_value_numeric = float(db_value.split()[1])  # Extraer solo el valor numérico (ej. "15.9")
        
        # Calcular Ld_tracción
        Ld_traccion = ((fy / (1.1 * λ * (fc**0.5))) * (ψt * ψe * ψs) / Cb) * db_value_numeric
        
        # Redondear al siguiente entero mayor
        Ld_traccion_redondeado = math.ceil(Ld_traccion)
        
        # Convertir a "cm" y agregar a la lista de resultados
        resultados_Ld.append(f"{Ld_traccion_redondeado} cm")
    
    # Actualizar el combo_Ld con los resultados calculados
    combo_Ld['values'] = resultados_Ld  # Asignar la lista de resultados con "cm"
    
    # Si hay resultados disponibles, seleccionar el primero (opcional)
    if resultados_Ld:
        combo_Ld.set(resultados_Ld[0])  # Selecciona el primer valor por defecto
    
    # Actualizar el valor en el label de diámetro de tracción
    db_seleccionado = combo_db.get()
    label_diametro_traccion.config(text=f"{db_seleccionado}")
    
    # Actualizar el valor en el label de Ld tracción
    Ld_seleccionado = combo_Ld.get()
    label_Ld_traccion.config(text=f"{Ld_seleccionado}")

def Calcular_Ldc_compresion(event):
    # Obtener el valor de f'c seleccionado
    f_c_Ld = combo_fc_Ldc.get()
    
    # Obtener el valor de db_Ld desde combo_barras_diametro_ldc
    db_Ld = combo_barras_diametro_ldc.get()  
    
    # Convertir db_Ld de texto a número (extraer solo la parte numérica)
    if db_Ld:
        try:
            # Extraer el número (15.9 de "Ø 15.9 mm")
            db_Ld_value = float(db_Ld.split()[1])  
            db_Ld_value = db_Ld_value / 10  # Dividir el valor entre 10
        except ValueError:
            db_Ld_value = 0  # Si no se puede convertir, asignar 0
    else:
        db_Ld_value = 0
    
    # Convertir f'c de texto a número (Mpa) - extraer el número
    if f_c_Ld:
        try:
            f_c_value = float(f_c_Ld.split()[0])  # Extraer el número de "Mpa"
            
            # Calcular Ldc
            Ldc_compresion = 0.24 * 420 / math.sqrt(f_c_value)
            
            # Redondear Ldc al entero más cercano
            Ldc_compresion_redondeado = round(Ldc_compresion)
            
            # Formatear el resultado como "{resultado}db"
            resultado = f"{Ldc_compresion_redondeado} db"
            
            # Actualizar el combo_Ldc con el resultado
            combo_Ldc.set(resultado)
            
            # Actualizar el label_Ldc_db con el mismo resultado pero con el formato "{resultado}:"
            label_Ldc_db.config(text=f"{resultado}:")
            
            # Realizar el cálculo Ldc_compresion * db_Ld
            resultado_Ldc_db_Ld = Ldc_compresion_redondeado * db_Ld_value
            
            # Redondear el resultado de Ldc * db_Ld al número entero más cercano
            resultado_Ldc_db_Ld_redondeado = round(resultado_Ldc_db_Ld)
            
            # Actualizar el label_Ldc_db_1 con el nuevo resultado (entero y con "cm")
            label_Ldc_db_1.config(text=f"{resultado_Ldc_db_Ld_redondeado} cm")
            
            # Calcular 18 * db_Ld_value
            resultado_18db = 18 * db_Ld_value
            
            # Redondear el resultado de 18db
            resultado_18db_redondeado = round(resultado_18db)
            
            # Actualizar el label_18db_1 con el resultado
            label_18db_1.config(text=f"{resultado_18db_redondeado} cm")
            
            # Comparar los dos valores para ver cuál es mayor
            if resultado_Ldc_db_Ld_redondeado > resultado_18db_redondeado:
                mayor_resultado = resultado_Ldc_db_Ld_redondeado
            else:
                mayor_resultado = resultado_18db_redondeado
            
            # Mostrar el resultado mayor en el label de resultados
            label_resultados_Ldc.config(
                text=f"Con un concreto de {f_c_Ld} se requiere una longitud mínima de desarrollo a compresión de {mayor_resultado} cm"
            )
            
            # ACTUALIZAR EL LABEL DE DIÁMETRO DE COMPRESIÓN
            label_diametro_compresion.config(text=f"{db_Ld}")
            
            # ACTUALIZAR EL LABEL DE LDC COMPRESIÓN
            label_Ldc_compresion.config(text=f"{mayor_resultado} cm")
            
        except ValueError:
            pass  # No hacemos nada en caso de error

# Función que se ejecuta al seleccionar una opción en el Combobox
def actualizar_imagen(event):
    seleccion = combo_ganchos.get()  # Obtenemos la opción seleccionada

    # Eliminar la imagen previa si existe
    for widget in frame_ganchos.winfo_children():
        widget.destroy()

    # Definir la ruta de la imagen según la selección
    if seleccion == "90°":
        ruta_imagen = os.path.join("Iconos_proyecto", "gancho_90.png")
    elif seleccion == "180°":
        ruta_imagen = os.path.join("Iconos_proyecto", "gancho_180.png")
    else:
        return  # Si no hay selección válida, no hacemos nada

    # Cargar la imagen
    imagen = Image.open(ruta_imagen)
    imagen = imagen.resize((200, 200))  

    # Convertir la imagen a un formato que pueda mostrar Tkinter
    imagen_tk = ImageTk.PhotoImage(imagen)

    # Mostrar la imagen dentro del frame
    etiqueta_imagen = tk.Label(frame_ganchos, image=imagen_tk)
    etiqueta_imagen.image = imagen_tk  # Necesario para evitar que la imagen se elimine automáticamente
    etiqueta_imagen.pack()

# Función para calcular el diámetro de doblado
def diametro_de_doblado(event):
    seleccion_doblado = combo_barras_doblado.get()  # Obtenemos la barra seleccionada
    barras_info_doblado = barras_info_refuerzo_1.get(seleccion_doblado)  # Obtenemos la información de la barra seleccionada
    
    if barras_info_doblado:
        db_doblado = barras_info_doblado['diametro_mm']  # Extraemos el valor del diámetro en mm
        
        if seleccion_doblado in barras_info_refuerzo_1:
            if seleccion_doblado in ["Barra No.2", "Barra No.3", "Barra No.4", "Barra No.5", "Barra No.6", "Barra No.7", "Barra No.8"]:
                # Fórmula para barras No.2 a No.8: (6 * db_doblado) / 10
                resultado_doblado = (6 * db_doblado) / 10
            elif seleccion_doblado in ["Barra No.9", "Barra No.10", "Barra No.11"]:
                # Fórmula para barras No.9 a No.11: (8 * db_doblado) / 10
                resultado_doblado = (8 * db_doblado) / 10
            elif seleccion_doblado in ["Barra No.14", "Barra No.18"]:
                # Fórmula para barras No.14 a No.18: (10 * db_doblado) / 10
                resultado_doblado = (10 * db_doblado) / 10
            
            # Mostrar el resultado sin decimales
            label_diametro_doblado_1.config(text=f"{int(resultado_doblado)} cm")

def Calcular_Ldh():
    # Obtener valores de los combos
    tipo_concreto = combo_concreto_Ldh.get()
    fc_Ldh = combo_fc_Ldc.get()
    db_Ldh = combo_barras_diametro.get()
    db_Ldh_traccion = combo_barras_traccion.get()
    barra_compresion = Barras_compresion.get()
    gancho_seleccionado = combo_ganchos.get()
    
    # Verificar si se han seleccionado todos los campos necesarios
    if not tipo_concreto or not fc_Ldh or not db_Ldh or not barra_compresion or not gancho_seleccionado:
        label_resultado_Ldh_1.config(text="Faltan datos")
        return
    
    # Establecer constantes
    psi_e_Ldh = 1.0  # valor constante
    fy_Ldh = 420  # valor constante
    
    # Asignar λ_Ldh basado en la opción de concreto
    if tipo_concreto == "Peso liviano":
        lambda_Ldh = 0.75
        label_concreto_λ_factor.config(text=f"{lambda_Ldh}")
    elif tipo_concreto == "Peso normal":
        lambda_Ldh = 1.0
        label_concreto_λ_factor.config(text=f"{lambda_Ldh}")
    else:
        label_resultado_Ldh_1.config(text="Opción de concreto no válida")
        return
    
    # Actualizar el valor de ψe (constantemente 1.0 en este caso)
    label_factor_ψe_1.config(text=f"{psi_e_Ldh}")
    
    # Obtener el valor de f'c_Ldh a partir del combo_fc_Ldc
    if fc_Ldh == "17.5 Mpa":
        fc_Ldh_value = 17.5
    elif fc_Ldh == "21 Mpa":
        fc_Ldh_value = 21
    elif fc_Ldh == "24.5 Mpa":
        fc_Ldh_value = 24.5
    elif fc_Ldh == "28 Mpa":
        fc_Ldh_value = 28
    elif fc_Ldh == "35 Mpa":
        fc_Ldh_value = 35
    elif fc_Ldh == "42 Mpa":
        fc_Ldh_value = 42
    else:
        label_resultado_Ldh_1.config(text="Opción de resistencia no válida")
        return
    
    # Extraer el valor numérico del diámetro de barra seleccionada
    # Usamos una expresión regular para capturar solo el número en el formato "Ø X mm"
    match = re.search(r'(\d+(\.\d+)?)', db_Ldh)
    if match:
        db_Ldh_value = float(match.group(1))  # Convertir a float el valor numérico
    else:
        label_resultado_Ldh_1.config(text="Diámetro de barra no válido")
        return
    
    # Calcular Ldh_desarrollo utilizando la fórmula 
    Ldh_desarrollo = (0.24 * psi_e_Ldh * fy_Ldh) / (lambda_Ldh * math.sqrt(fc_Ldh_value)) * db_Ldh_value
    
    # Dividir el resultado por 10
    Ldh_desarrollo /= 10
    
    # Convertir el resultado a entero (sin decimales)
    Ldh_desarrollo_entero = int(Ldh_desarrollo)
    
    # Redondear el resultado si la opción es "Peso normal" (al múltiplo de 5 más cercano)
    if tipo_concreto == "Peso normal":
        # Redondear al múltiplo de 5 más cercano
        Ldh_desarrollo_entero = round(Ldh_desarrollo_entero / 5) * 5
    
    # Mostrar el resultado en el label sin decimales
    label_resultado_Ldh_1.config(text=f"{Ldh_desarrollo_entero} cm")
    
    # Ahora actualizas el label_Ldh_traccion con el mismo valor o resultado
    label_Ldh_traccion.config(text=f"{Ldh_desarrollo_entero} cm")
    
    # Actualizar el label_ldh_t con el valor de Ldh_desarrollo_entero
    label_ldh_t.config(text=f"{Ldh_desarrollo_entero} cm")
    
    # Ahora actualizar el Treeview con los datos
    treeview_Ldh.item(treeview_Ldh.get_children()[0], values=(db_Ldh_traccion, Ldh_desarrollo_entero, "As[-]"))
    
    # Actualizar el label con el formato requerido
    label_treeview_Ldh.config(
        text=(
            f"Para el diseño de la viga con concreto de {fc_Ldh} y acero {db_Ldh_traccion} "
            f"se requiere una longitud mínima Ldh de {Ldh_desarrollo_entero} cm para garantizar "
            f"el anclaje adecuado del acero en el concreto y un aporte de adherencia necesario para el buen desempeño estructural."
        )
    )
    
    # Obtener el número de la barra de compresión desde el combo 
    barra_numero = barra_compresion.split('#')[-1]  # Obtener el último número
    
    # Buscar el valor del diámetro de la barra en el diccionario
    barra_key = f"Barra No.{barra_numero}"
    if barra_key in barras_info_refuerzo_1:
        barra_diametro = barras_info_refuerzo_1[barra_key]["diametro_mm"]
        
        # Calcular Ldh para compresión usando la misma fórmula que para la tracción
        Ldh_desarrollo_compresion = (0.24 * psi_e_Ldh * fy_Ldh) / (lambda_Ldh * math.sqrt(fc_Ldh_value)) * barra_diametro
        Ldh_desarrollo_compresion /= 10  # Dividir por 10 para convertir en cm
        
        # Convertir el resultado de compresión a entero (sin decimales)
        Ldh_desarrollo_compresion_entero = int(Ldh_desarrollo_compresion)
        
        # Redondear al múltiplo de 5 más cercano si es "Peso normal"
        if tipo_concreto == "Peso normal":
            Ldh_desarrollo_compresion_entero = round(Ldh_desarrollo_compresion_entero / 5) * 5
        
        label_Ldh_compresion.config(text=f"{Ldh_desarrollo_compresion_entero} cm")
        
        # Actualizar el label_ldh_c con el valor de Ldh_desarrollo_compresion_entero
        label_ldh_c.config(text=f"{Ldh_desarrollo_compresion_entero} cm")
        
        # Actualizar la segunda columna del treeview_Ldh_compresion con el cálculo de Ldh para compresión
        treeview_Ldh_compresion.item(treeview_Ldh_compresion.get_children()[0], values=(barra_compresion, Ldh_desarrollo_compresion_entero,"As'"))
        
        # Mostrar el resultado con gancho
        label_treeview_Ldh_compresion.config(
            text=(f"Para la barra de compresión {barra_compresion}, se requiere una longitud mínima Ldh de "
                  f"{Ldh_desarrollo_compresion_entero} cm para el anclaje adecuado en el concreto. "
                  f"Además, se procederá con las configuraciones del gancho seleccionado de {gancho_seleccionado}.")
        )
        
        # Calcular gancho para tracción
        if gancho_seleccionado == "90°":
            gancho_traccion = 12 * db_Ldh_value / 10  
        elif gancho_seleccionado == "180°":
            gancho_traccion = 4 * db_Ldh_value / 10  
        else:
            gancho_traccion = 0
        
        # Redondear el gancho para tracción al múltiplo de 5
        gancho_traccion_entero = round(gancho_traccion / 5) * 5
        
        # Calcular gancho para compresión
        if gancho_seleccionado == "90°":
            gancho_compresion = 12 * barra_diametro / 10  
        elif gancho_seleccionado == "180°":
            gancho_compresion = 4 * barra_diametro / 10  
        else:
            gancho_compresion = 0
        
        # Redondear el gancho para compresión al múltiplo de 5 
        gancho_compresion_entero = round(gancho_compresion / 5) * 5
        
        # Actualizar label_Ldh_traccion_longitud con el valor de gancho_traccion
        label_Ldh_traccion_longitud.config(text=f"{gancho_traccion_entero} cm")
        
        # Actualizar label_Ldh_compresion_longitud con el valor de gancho_compresion
        label_Ldh_compresion_longitud.config(text=f"{gancho_compresion_entero} cm")
        
        # Actualizar Treeview para ganchos con valores redondeados
        treeview_ganchos.item(treeview_ganchos.get_children()[0], values=(db_Ldh_traccion, gancho_seleccionado, f"{gancho_traccion_entero} cm"))
        treeview_ganchos.item(treeview_ganchos.get_children()[1], values=(barra_compresion, gancho_seleccionado, f"{gancho_compresion_entero} cm"))
        
        # Actualizar el label con el mensaje adicional
        label_treeview_ganchos.config(
            text=(
                f"En sistemas de pórticos resistentes diseñados para soportar cargas gravitacionales o sismo, "
                f"se recomienda garantizar un anclaje adecuado tanto para el acero superior como para el acero inferior. "
                f"Los ganchos calculados son: Tracción = {gancho_traccion_entero} cm, Compresión = {gancho_compresion_entero} cm."
            )
        )
        
        # Actualizar label_gancho_anclaje con el valor del gancho seleccionado
        label_gancho_anclaje.config(text=f"{gancho_seleccionado}")
        
        # Actualizar label_longitud_t con el valor de gancho_traccion_entero
        label_longitud_t.config(text=f"{gancho_traccion_entero} cm")
        
        # Actualizar label_longitud_c con el valor de gancho_compresion_entero
        label_longitud_c.config(text=f"{gancho_compresion_entero} cm")


def agregar_datos_treeview_Ld(treeview_Ld_1, combo_barras_diametro, combo_Ld, treeview_Ldc, combo_barras_ldc,combo_barras_diametro_ldc,label_Ldc_db_1,
                              treeview_ganchos_Ldh, label_Ldh_traccion, label_Ldh_compresion,combo_ganchos,label_Ldh_traccion_longitud,label_Ldh_compresion_longitud,
                              label_ganchos_check,label_icon_Ld, icon_check_on,label_ancho_columna):
    # Obtener todos los valores del ComboBox
    barras_traccion_values = Barras_traccion['values']  # Lista de valores del ComboBox
    
    # Obtener todos los valores del ComboBox combo_barras_diametro
    barras_diametro_values = combo_barras_diametro['values']  # Lista de valores del ComboBox combo_barras_diametro
    
    # Obtener todos los valores del ComboBox combo_Ld
    Ld_values = combo_Ld['values']  # Lista de valores del ComboBox combo_Ld
    
    # Obtener todos los valores del ComboBox combo_barras_ldc
    barras_ldc_values = combo_barras_ldc['values']  # ComboBox combo_barras_ldc
    
    # Obtener el valor del combo_barras_diametro_ldc 
    barra_diametro_ldc_value = combo_barras_diametro_ldc.get() 
    
    # Obtener el texto del Label label_Ldc_db_1
    label_text = label_Ldc_db_1.cget("text")  # Obtener el texto del label
    
    # Obtener el texto de los labels de tracción y compresión
    label_traccion_text = label_Ldh_traccion.cget("text")  # Obtener el texto de label_Ldh_traccion
    label_compresion_text = label_Ldh_compresion.cget("text")  # Obtener el texto de label_Ldh_compresion
    
    # Obtener el valor de combo_ganchos (para las columnas 4 de las filas 1 y 2)
    valor_combo_ganchos = combo_ganchos.get()  # Valor seleccionado en el combo_ganchos
    
    # Obtener los textos de longitud para tracción y compresión
    traccion_longitud_text = label_Ldh_traccion_longitud.cget("text")  # Longitud de tracción
    compresion_longitud_text = label_Ldh_compresion_longitud.cget("text")  # Longitud de compresión
    
    # Verificar si todos los ComboBoxes tienen al menos 3 valores (excepto combo_barras_ldc)
    if len(barras_traccion_values) >= 3 and len(barras_diametro_values) >= 3 and len(Ld_values) >= 3:
        # Verificar si el combo_barras_ldc tiene solo un valor
        if len(barras_ldc_values) == 1:
            barra_ldc = barras_ldc_values[0]  # Usar el único valor disponible en combo_barras_ldc
            
            # Actualizar las filas de ambos Treeviews
            for i in range(3):  # Solo recorremos 3 filas para cada Treeview
                barra_traccion = barras_traccion_values[i]
                barra_diametro = barras_diametro_values[i]
                Ld_value = Ld_values[i]
                
                # Actualizar el primer Treeview (treeview_Ld_1)
                if i == 0:
                    treeview_Ld_1.item(fila1_id, values=("As[-]", barra_traccion, barra_diametro, Ld_value))
                elif i == 1:
                    treeview_Ld_1.item(fila2_id, values=("As[+]", barra_traccion, barra_diametro, Ld_value))
                elif i == 2:
                    treeview_Ld_1.item(fila3_id, values=("As[-]", barra_traccion, barra_diametro, Ld_value))
                
                # Actualizar el segundo Treeview (treeview_Ldc) - solo la primera fila
                treeview_Ldc.item(fila1_ldc, values=("As'", barra_ldc, barra_diametro_ldc_value, label_text))
                
                # Actualizar el tercer Treeview (treeview_ganchos_Ldh)
                # Primera fila: insertar el primer valor de Barras_traccion en la segunda columna
                treeview_ganchos_Ldh.item(fila_gancho_1, values=("Tracción", barras_traccion_values[0], label_traccion_text,valor_combo_ganchos, traccion_longitud_text))
                
                # Segunda fila: insertar el primer valor de combo_barras_ldc en la segunda columna
                treeview_ganchos_Ldh.item(fila_gancho_2, values=("Compresión", barras_ldc_values[0], label_compresion_text,valor_combo_ganchos, compresion_longitud_text))
                
                # Cálculo del ancho mínimo de la columna
                recubrimiento_columna = 5  # Parámetro constante
                try:
                # Usamos una expresión regular para extraer el valor numérico de 'label_traccion_text'
                    match = re.match(r"(\d+(\.\d+)?)\s*cm", label_traccion_text)  # Busca números seguidos de " cm"
                    if match:
                        label_traccion_value = float(match.group(1))  # Convertir la parte numérica a float
                # Realizamos el cálculo de Ancho_Columna
                        Ancho_Columna = label_traccion_value + recubrimiento_columna
                    else:
                # Si no se encuentra un número, usamos un valor predeterminado
                        Ancho_Columna = recubrimiento_columna
                except ValueError:
                # Si hay algún error con la conversión, solo usamos recubrimiento_columna
                    Ancho_Columna = recubrimiento_columna
                
                # Actualizar el label_ganchos_check con el cálculo del ancho de la columna
                label_ganchos_check.config(text=f"La dimensión requerida para el ancho mínimo de la columna es de {Ancho_Columna} cm. Hasta este momento hemos completado el diseño de flexión. Ahora puedes proceder con las configuraciones correspondientes al diseño por cortante.")
                
                # Actualizar la imagen del icono
                label_icon_Ld.config(image=icon_check_on)
                
                # Actualizar el valor de Ancho_Columna en el label_ancho_columna
                label_ancho_columna.config(text=f"{Ancho_Columna} cm")  

# Diseño Cortante - Funciones de cálculo
# Variable para controlar si la ventana secundaria está abierta

lineas_discontinuas = []
posiciones_x = []  
cotas = []  
textos_cotas = []
# Variable para guardar el valor anterior de entry_borde_C
ultimo_valor_borde_C = None

# Variable global para verificar si la subventana_refuerzo ya fue abierta
subventana_abierta_cortante = False

# Diccionario para llevar el control del último estribo dibujado en cada grilla
ultimo_estribo = {"derecha": None, "izquierda": None}
estribos_plots =[]
cotas_plots  =[]
etiquetas_plots =[]
# Función para abrir la subventana
def abrir_subventana_refuerzo():
    global subventana_abierta_cortante,combobox_estribo_st,entry_diametro_sr,treeview_control,menu_opciones,entry_UN_flejes,entry_UN_luz
    global entry_UN_viga,canvas_UN_estribos,combo_r,label_r_info,spinbox_r,spinbox_UN_r,ax,fig,base_fig,borde_valor,canvas_tk,margen_grilla
    global estribos_plots,ultimo_estribo,cotas_plots,etiquetas_plots,entry_UN_viga
    
    # Si la subventana ya fue abierta, no hacer nada
    if subventana_abierta_cortante:
        return
    
    # Crear una nueva ventana para el refuerzo (subventana)
    subventana_refuerzo = tk.Toplevel()  # Usamos Toplevel() para crear una subventana independiente
    
    # Aseguramos que la subventana esté siempre en el frente
    subventana_refuerzo.attributes('-topmost', True)
    
    # Configuración de la subventana
    subventana_refuerzo.geometry('800x400')
    subventana_refuerzo.title("Configuración de refuerzo transversal")
    subventana_refuerzo.resizable(False, False)
    
    # Crear contenido
    
    labelframe_sr = tk.LabelFrame(subventana_refuerzo,text="")
    labelframe_sr.place(x=10,y=10,width=780,height=340)
    
    labelframe_sr_1 = tk.LabelFrame(labelframe_sr,text="General")
    labelframe_sr_1.place(x=10,y=10,width=350,height=60)
    
    label_estribo_sr = tk.Label(labelframe_sr_1,text="Estribo:")
    label_estribo_sr.place(x=10,y=10)
    
    combobox_estribo_st = ttk.Combobox(labelframe_sr_1, values=["E#3", "E#4"])
    combobox_estribo_st.place(x=70,y=10,width=100)
    combobox_estribo_st.bind("<<ComboboxSelected>>", actualizar_diametro)
    
    label_diametro_sr = tk.Label(labelframe_sr_1,text="Øbarra:")
    label_diametro_sr.place(x=200,y=10)
    
    entry_diametro_sr = tk.Entry(labelframe_sr_1)
    entry_diametro_sr.place(x=250,y=10,width=80)
    
    labelframe_control = tk.LabelFrame(labelframe_sr,text="Control de separación de estribos")
    labelframe_control.place(x=10,y=70,width=350,height=250)
    
    # Crear la tabla Treeview en la pestaña  'tad_optimización'
    treeview_control = ttk.Treeview(labelframe_control, columns=("L.refuerzo", "L(m)", "S(m)", "UN"), show="headings")
    treeview_control.place(x=5, y=10, width=250, height=100)
    
    # Definir las columnas
    treeview_control.heading("L.refuerzo", text="L.refuerzo")
    treeview_control.heading("L(m)", text="L(m)")
    treeview_control.heading("S(m)", text="S(m)")
    treeview_control.heading("UN", text="UN")
    
    # Configurar el ancho de las columnas
    treeview_control.column("L.refuerzo", width=40,anchor="center")
    treeview_control.column("L(m)", width=20,anchor="center")
    treeview_control.column("S(m)", width=20,anchor="center")
    treeview_control.column("UN", width=20,anchor="center")
    
    # Insertar las filas con los datos en la primera columna y vacío en el resto
    treeview_control.insert("", "end", values=("Tramo 1", "", "", ""))
    treeview_control.insert("", "end", values=("Tramo 2", "", "", ""))
    treeview_control.insert("", "end", values=("Tramo 3", "", "", ""))
    
    def no_resize(event):
    # Restaurar el tamaño original de las columnas usando un ciclo
        for col in treeview_control["columns"]:
            treeview_control.column(col, width=62, anchor="center")
        
        # Vincular el evento de clic con la función no_resize
    treeview_control.bind("<ButtonRelease-1>", no_resize)
    
    buton_agregar_control = ttk.Button(labelframe_control,text="Agregar",command=abrir_cuadro_agregar_control) 
    buton_agregar_control.place(x=260,y=20,width=80)
    
    buton_modificar_control = ttk.Button(labelframe_control,text="Modificar",command=modificar_fila_control) 
    buton_modificar_control.place(x=260,y=60,width=80)
    
    labelframe_UN_Flejes = tk.LabelFrame(labelframe_control,text="Unidad de estribos")
    labelframe_UN_Flejes.place(x=5,y=120,width=150,height=100)
    
    
    var_UN_estribos = tk.IntVar(value=0)
    radiobutton_UN_estribos = tk.Radiobutton(labelframe_UN_Flejes,text="Cantidad estribos",variable=var_UN_estribos,
                                command=Cantidad_estribos)
    radiobutton_UN_estribos.place(x=1,y=10)
    
    entry_UN_flejes = tk.Entry(labelframe_UN_Flejes)
    entry_UN_flejes.place(x=10,y=40,width=100)
    
    labelframe_UN_seccion = tk.LabelFrame(labelframe_control,text="Sección")
    labelframe_UN_seccion.place(x=170,y=120,width=170,height=100)
    
    label_UN_viga = tk.Label(labelframe_UN_seccion,text="Viga:")
    label_UN_viga.place(x=10,y=10)
    
    entry_UN_viga = tk.Entry(labelframe_UN_seccion)
    entry_UN_viga.place(x=50,y=10,width=100)
    
    label_UN_luz = tk.Label(labelframe_UN_seccion,text="Luz:")
    label_UN_luz.place(x=10,y=50)
    
    entry_UN_luz = tk.Entry(labelframe_UN_seccion)
    entry_UN_luz.place(x=50,y=50,width=100)
    
    frame_UN_luz = tk.Frame(labelframe_sr,bd=2,relief="ridge")
    frame_UN_luz.place(x=370,y=17,width=395,height=180)
    
    
    Notebook_UN_estribos = ttk.Notebook(frame_UN_luz,style="CustomNotebook.TNotebook")  
    
    tab_UN_estribos = ttk.Frame(Notebook_UN_estribos)  
    
    Notebook_UN_estribos.add(tab_UN_estribos, text="Despiece refuerzo transversal")
    
    Notebook_UN_estribos.pack(fill="both", expand=True)
    
    canvas_UN_estribos = tk.Canvas(tab_UN_estribos,bg="white")  
    canvas_UN_estribos.pack(fill="both", expand=True)
    
    # Función para redimensionar la imagen
    def redimensionar_imagen(ruta_imagen, tamano):
        imagen_lista_UN = Image.open(ruta_imagen)  
        imagen_lista_UN = imagen_lista_UN.resize(tamano) 
        imagen_generar_UN = Image.open(ruta_imagen)
        imagen_generar_UN = imagen_lista_UN.resize(tamano) 
        return ImageTk.PhotoImage(imagen_lista_UN,imagen_generar_UN )   
    
    # Cargar las imágenes de los iconos redimensionadas
    imagen_dibujar_UN = redimensionar_imagen("Iconos_proyecto/barra_desplegable.png", (15, 15))
    imagen_despiece_UN = redimensionar_imagen("Iconos_proyecto/generar_imagen.png", (15, 15))
    
    style = ttk.Style()
    style.configure("Custom.TButton", background="lightgrey", relief="flat")  
    
    boton_dibujar_UN = ttk.Button(labelframe_sr,image=imagen_dibujar_UN,style="Custom.TButton")
    boton_dibujar_UN .place(x=580,y=19)
    
    boton_generar_UN = ttk.Button(labelframe_sr,image=imagen_despiece_UN,style="Custom.TButton",command=guardar_imagen_dpi)
    boton_generar_UN .place(x=640,y=19)
    
    # Mantener una referencia de las imágenes
    boton_dibujar_UN.icono = imagen_dibujar_UN
    boton_generar_UN.icono = imagen_despiece_UN
    
    # Crear el menú desplegable
    menu_opciones = tk.Menu(labelframe_sr, tearoff=0)
    menu_opciones.add_command(label="Dibujar esquema", command=lambda: seleccionar_opcion("Dibujar esquema"))
    
    
    boton_dibujar_UN.bind("<Button-1>", mostrar_menu)
    
    labelframe_configuraciones = tk.LabelFrame(labelframe_sr,text="Ajuste refuerzo transversal")
    labelframe_configuraciones.place(x=370,y=200,width=395,height=120)
    
    label_r = tk.Label(labelframe_configuraciones,text="L.refuerzo:")
    label_r.place(x=5,y=10)
    
    combo_r = ttk.Combobox(labelframe_configuraciones, values=["Tramo 1", "Tramo 2", "Tramo 3"])
    combo_r.place(x=70 ,y=10, width=100)
    combo_r.bind("<<ComboboxSelected>>", actualizar_label_con_datos)
    
    label_r_info = tk.Label(labelframe_configuraciones,text="",bd=2,relief="sunken",
                            justify="left",
                            anchor="center",
                            wraplength=320)
    label_r_info .place(x=5,y=35,width=170,height=60)
    
    label_S_m = tk.Label(labelframe_configuraciones,text="S(m):")
    label_S_m.place(x=230,y=10)
    
    # Crear un Spinbox
    spinbox_r = tk.Spinbox(labelframe_configuraciones, from_=0.00, to=100.00,format="%.2f", increment=0.01)
    spinbox_r.place(x=280,y=10,width=70)
    
    label_UN_m = tk.Label(labelframe_configuraciones,text="UN:")
    label_UN_m.place(x=230,y=40)
    
    # Crear un Spinbox
    spinbox_UN_r = tk.Spinbox(labelframe_configuraciones, from_=1.0, to=100.00,format="%.1f", increment=1.0)
    spinbox_UN_r.place(x=280,y=40,width=70)
    spinbox_UN_r.config(command=dibujar_estribos)
    
    boton_Un_aceptar = ttk.Button(subventana_refuerzo,text="Aceptar")
    boton_Un_aceptar.place(x=140,y=360,width=100)
    
    boton_Un_agregar = ttk.Button(subventana_refuerzo,text="Agregar datos")
    boton_Un_agregar.place(x=330,y=360,width=100)
    
    boton_Un_cancelar = ttk.Button(subventana_refuerzo,text="Cancelar",command=lambda: cerrar_subventana_refuerzo(subventana_refuerzo))
    boton_Un_cancelar.place(x=530,y=360,width=100)
    
    # Vincular Shift + Enter para borrar solo los estribos
    subventana_refuerzo.bind("<Shift-Return>", borrar_estribos)
    
    # Marcar que la subventana ha sido abierta
    subventana_abierta_cortante = True
    
    # Configurar el evento de cierre de la subventana
    subventana_refuerzo.protocol("WM_DELETE_WINDOW", lambda: cerrar_subventana_refuerzo(subventana_refuerzo))

# Función para manejar el cierre de la subventana y permitir abrirla de nuevo
def cerrar_subventana_refuerzo(subventana_refuerzo):
    global subventana_abierta_cortante
    
    # Restablecer el estado para permitir abrir la subventana de nuevo
    subventana_abierta_cortante = False
    
    # Cerrar la subventana
    subventana_refuerzo.destroy()


# Función para mostrar el menú en la posición del botón
def mostrar_menu(event):
    menu_opciones.post(event.x_root, event.y_root)

def extraer_valor_numerico(texto):
    match = re.search(r"\d+(\.\d+)?", texto)  # Busca números en el texto
    return float(match.group()) if match else 1.0  # Retorna el número o 1.0 por defecto

def dibujar_esquema():
    global ventana_dibujar,fig, ax ,base_fig,borde_valor,canvas_tk,margen_grilla,estribos_plots,ultimo_estribo,cotas_plots,etiquetas_plots
    
    
    # Obtener valor numérico de la base desde entry_UN_luz
    texto_luz = entry_UN_luz.get()
    base_fig = extraer_valor_numerico(texto_luz)  
    # Obtener el valor numérico de entry_borde_C
    texto_borde = entry_borde_C.get()
    borde_valor = extraer_valor_numerico(texto_borde)  
    altura_fig = 1.0 
    texto_viga = entry_UN_viga.get()  
    texto_estribo = combobox_estribo_st.get()  

    
    # Crear la figura y el eje
    fig, ax = plt.subplots(figsize=(4, 2))  
    ax.set_xlim(0, base_fig)  
    ax.set_ylim(-1, 1)  
    
    
    # Dibujar rectángulo
    rect = plt.Rectangle((0, -0.5), base_fig, 1, edgecolor='black', facecolor='lightgrey')
    ax.add_patch(rect)
    
    # Dibujar línea discontinua roja según el valor de borde
    if 0 < borde_valor < base_fig:  
        ax.plot([borde_valor, borde_valor], [-0.5, 0.5], color='red', linestyle='--', linewidth=1.5, label="Borde C")
    
    # Crear la línea discontinua desplazada a la izquierda
        borde_copia = base_fig - borde_valor  # Nueva posición desplazada
        ax.plot([borde_copia, borde_copia], [-0.5, 0.5], color='red', linestyle='--', linewidth=1.5, label="Borde Copia")
    
    #  Líneas de grilla a 0.05 m de cada borde
        margen_grilla = 0.05  
        
        # Grilla a la derecha de la línea discontinua original
        ax.plot([borde_valor + margen_grilla, borde_valor + margen_grilla], [-0.5, 0.5], color='gray', linestyle='--', linewidth=1, label="Grilla")

        # Grilla a la izquierda de la línea copia
        ax.plot([borde_copia - margen_grilla, borde_copia - margen_grilla], [-0.5, 0.5], color='gray', linestyle='--', linewidth=1, label="Grilla")
    
    
    # Ocultar títulos de los ejes
    ax.set_xlabel("")
    ax.set_ylabel("")

    # Ocultar números de los ejes
    ax.set_xticks([])
    ax.set_yticks([])

    # Ajustar color de las líneas de los ejes a gris suave
    ax.axhline(0, color='gray', linewidth=1, alpha=0.5)
    ax.axvline(0, color='gray', linewidth=1, alpha=0.5)
    
    # Crear líneas para la leyenda
    linea_luz, = ax.plot([], [], color="black", linewidth=2, label=f"Luz: {texto_luz}")  
    linea_viga, = ax.plot([], [], color="gray", linewidth=2, label=f"Viga: {texto_viga}")  
    linea_estribo, = ax.plot([], [], color="black", linewidth=2, label=f"Estribo: {texto_estribo}") 

    # Agregar la leyenda en dos columnas, más abajo y con fuente 6
    ax.legend(
        handles=[linea_luz, linea_viga,linea_estribo], 
        loc="upper left", 
        ncol=3, 
        frameon=False, 
        prop={'size': 6},  
        bbox_to_anchor=(0, 0.20)  
    )
    
    # Limpiar canvas antes de dibujar
    for widget in canvas_UN_estribos.winfo_children():
        widget.destroy()
    
    # Insertar gráfico en el canvas de Tkinter
    canvas_tk = FigureCanvasTkAgg(fig, master=canvas_UN_estribos)
    canvas_tk.get_tk_widget().pack(fill=tk.BOTH, expand=True)
    canvas_tk.draw()
    
    # Devolver la figura y el eje para que se puedan usar en otras funciones
    return fig, ax


def dibujar_estribos(*args):  
    global fig, ax, base_fig, borde_valor, canvas_tk, margen_grilla, estribos_plots, ultimo_estribo
    global cotas_plots,etiquetas_plots

    try:
        # Obtener valores desde los Spinbox y ComboBox
        separacion_estribos = float(spinbox_r.get())  
        cantidad_estribos = int(float(spinbox_UN_r.get()))  
        longitud_refuerzo = combo_r.get()  
        tipo_estribo_1 = combobox_estribo_st.get()  # Obtener tipo de estribo

        # Diccionario de colores por tipo de refuerzo
        colores = {"Tramo 1": "blue", "Tramo 2": "green", "Tramo 3": "red"}
        color_estribo = colores.get(longitud_refuerzo, "black")

        #  Posiciones iniciales para la grilla derecha e izquierda
        if ultimo_estribo["derecha"] is None:
            posicion_actual = borde_valor + margen_grilla  # Inicia en la grilla derecha
        else:
            posicion_actual = ultimo_estribo["derecha"] + separacion_estribos  # Nuevo inicio

        if ultimo_estribo["izquierda"] is None:
            posicion_espejo = base_fig - borde_valor - margen_grilla  # Inicia en la grilla izquierda
        else:
            posicion_espejo = ultimo_estribo["izquierda"] - separacion_estribos  # Nuevo inicio

        #  Si es "L.min", se dibujan tres estribos: centro, derecha e izquierda
        if longitud_refuerzo == "L.min":
            posiciones_especiales = [base_fig / 2,  
                                     (base_fig / 2) + separacion_estribos,  
                                     (base_fig / 2) - separacion_estribos]  
        else:
            posiciones_especiales = None

        primer_estribo_derecha = None
        ultimo_estribo_derecha = None
        primer_estribo_izquierda = None
        ultimo_estribo_izquierda = None

        # Dibujar los estribos
        for _ in range(cantidad_estribos):
            if posiciones_especiales:
                #  Dibujar los tres estribos si es "L.min"
                for pos in posiciones_especiales:
                    line, = ax.plot([pos, pos], [-0.15, 0.15], color=color_estribo, linewidth=1)
                    estribos_plots.append((line, color_estribo))
                    
                #  Dibujar la cota para "L.min"
                inicio = posiciones_especiales[-1]  # Última posición (más a la izquierda)
                fin = posiciones_especiales[1]  # Segunda posición (más a la derecha)
                dibujar_cota(inicio, fin, "centro")  # Nueva cota para L.min
                
                # Etiqueta debajo del grupo de estribos
                agregar_etiqueta((inicio + fin) / 2, f"{cantidad_estribos}{tipo_estribo_1}@{separacion_estribos:.2f}")
                
                # Evitar que siga con la lógica normal
                break
            
            #  Estribo en la grilla derecha
            line, = ax.plot([posicion_actual, posicion_actual], [-0.15, 0.15], color=color_estribo, linewidth=1)
            estribos_plots.append((line, color_estribo))
            if primer_estribo_derecha is None:
                primer_estribo_derecha = posicion_actual
            ultimo_estribo_derecha = posicion_actual
            ultimo_estribo["derecha"] = posicion_actual  # Guardar última posición

            #  Estribo en la grilla izquierda
            line_esp, = ax.plot([posicion_espejo, posicion_espejo], [-0.15, 0.15], color=color_estribo, linewidth=1)
            estribos_plots.append((line_esp, color_estribo))
            if primer_estribo_izquierda is None:
                primer_estribo_izquierda = posicion_espejo
            ultimo_estribo_izquierda = posicion_espejo
            ultimo_estribo["izquierda"] = posicion_espejo  # Guardar última posición

            # Avanzar la posición según la separación
            posicion_actual += separacion_estribos  
            posicion_espejo -= separacion_estribos  

        # Dibujar cotas para cada grupo de estribos
        if primer_estribo_derecha is not None and ultimo_estribo_derecha is not None:
            dibujar_cota(primer_estribo_derecha, ultimo_estribo_derecha, "derecha")
            agregar_etiqueta((primer_estribo_derecha + ultimo_estribo_derecha) / 2, f"{cantidad_estribos}{tipo_estribo_1}@{separacion_estribos:.2f}")

        if primer_estribo_izquierda is not None and ultimo_estribo_izquierda is not None:
            dibujar_cota(primer_estribo_izquierda, ultimo_estribo_izquierda, "izquierda")
            agregar_etiqueta((primer_estribo_izquierda + ultimo_estribo_izquierda) / 2, f"{cantidad_estribos}{tipo_estribo_1}@{separacion_estribos:.2f}")
        
        
        # Redibujar la gráfica
        canvas_tk.draw()

    except Exception as e:
        print(f"Error en dibujar_estribos: {e}")


def dibujar_cota(inicio, fin, lado):
    """Dibuja una cota con líneas de extensión y etiqueta de distancia"""
    global ax, cotas_plots
    
    #  Línea horizontal de la cota
    y_cota = 0.20  # Un poco arriba de los estribos
    linea_cota, = ax.plot([inicio, fin], [y_cota, y_cota], color="black", linewidth=1)

    #  Líneas de extensión en los extremos
    linea_ext_izq, = ax.plot([inicio, inicio], [y_cota - 0.05, y_cota + 0.05], color="black", linewidth=1)
    linea_ext_der, = ax.plot([fin, fin], [y_cota - 0.05, y_cota + 0.05], color="black", linewidth=1)

    #  Etiqueta con la distancia
    distancia = abs(fin - inicio)
    texto_cota = ax.text((inicio + fin) / 2, y_cota + 0.02, f"{distancia:.2f}m", 
                        ha="center", va="bottom", fontsize=6, color="black")
    
    #  Guardar las cotas para poder eliminarlas después
    cotas_plots.append((linea_cota, linea_ext_izq, linea_ext_der, texto_cota))


def agregar_etiqueta(x, texto):
    """Dibuja una etiqueta de texto debajo del grupo de estribos"""
    global ax, etiquetas_plots
    etiqueta = ax.text(x, -0.25, texto, ha="center", va="top", fontsize=6, color="black")
    etiquetas_plots.append(etiqueta)

def borrar_estribos(event=None): 
    global estribos_plots, ultimo_estribo, cotas_plots,etiquetas_plots


    if not estribos_plots:
        return  # Si no hay estribos, no hace nada

    try:
        #  Eliminar cada línea de estribo de la gráfica
        for line, _ in estribos_plots:
            line.remove()  

        #  Vaciar la lista después de eliminar los estribos
        estribos_plots = []  
        ultimo_estribo = {"derecha": None, "izquierda": None}
        
        #  Eliminar todas las cotas
        for linea_cota, linea_ext_izq, linea_ext_der, texto_cota in cotas_plots:
            linea_cota.remove()
            linea_ext_izq.remove()
            linea_ext_der.remove()
            texto_cota.remove()
        cotas_plots = []  
        
        
        for etiqueta in etiquetas_plots:
            etiqueta.remove()
        etiquetas_plots = []
        
        canvas_tk.draw()

    except Exception as e:
        print(f"Error en borrar_estribos: {e}")

def guardar_imagen_dpi():
    """Guarda la imagen del gráfico con todos los elementos dibujados."""
    try:
        ruta_guardado = os.path.join("Reportes", "imagenes_pilot", "grafico_estribos.png")
        fig.savefig(ruta_guardado, dpi=300, bbox_inches="tight")
        print(f"Imagen guardada en: {ruta_guardado}")
    except Exception as e:
        print(f"Error al guardar la imagen: {e}")


def seleccionar_opcion(opcion):
    if opcion == "Dibujar esquema":
        dibujar_esquema()  # Dibuja el esquema 



# Variable global para verificar si la subventana de agregar control ya fue abierta
ventana_agregar_abierta = False

# Función para abrir el cuadro de agregar control
def abrir_cuadro_agregar_control():
    global ventana_agregar_abierta
    
    # Verificar si ya se abrió una ventana de agregar control
    if ventana_agregar_abierta:
        return  # No hacer nada si ya está abierta
    
    # Crear una nueva subventana
    cuadro_agregar_control = tk.Toplevel()
    cuadro_agregar_control.geometry("330x200")
    cuadro_agregar_control.title("Agregar opciones")
    cuadro_agregar_control.resizable(False, False)  # Evitar redimensionar la ventana
    cuadro_agregar_control.attributes('-topmost', True)  # Mantener la ventana al frente

    # Longitud refuerzo
    label_l_refuerzo = tk.Label(cuadro_agregar_control, text="Longitud refuerzo:")
    label_l_refuerzo.place(x=10, y=10)

    combo_l_refuerzo = ttk.Combobox(cuadro_agregar_control, values=["Tramo 1", "Tramo 2", "Tramo 3"])
    combo_l_refuerzo.place(x=120, y=10, width=170)

    # Separación
    label_separacion = tk.Label(cuadro_agregar_control, text="Separación [m]:")
    label_separacion.place(x=10, y=90)

    entry_control_S = tk.Entry(cuadro_agregar_control)
    entry_control_S.place(x=120, y=90, width=170)

    # Longitud
    label_longitud_m = tk.Label(cuadro_agregar_control, text="Longitud [m]:")
    label_longitud_m.place(x=10, y=50)

    entry_control_longitud = tk.Entry(cuadro_agregar_control)
    entry_control_longitud.place(x=120, y=50, width=170)

    # Botón para agregar datos
    boton_aceptar_control = ttk.Button(cuadro_agregar_control, text="Aceptar",
                                    command=lambda: agregar_datos_al_treeview(combo_l_refuerzo, entry_control_S, entry_control_longitud))
    boton_aceptar_control.place(x=60, y=140)

    # Botón para cerrar
    boton_cerrar_control = ttk.Button(cuadro_agregar_control, text="Cancelar", command=lambda: cerrar_ventana_agregar(cuadro_agregar_control))
    boton_cerrar_control.place(x=180, y=140)

    # Marcar que la ventana de agregar control está abierta
    ventana_agregar_abierta = True
    
    # Configurar el evento de cierre de la ventana
    cuadro_agregar_control.protocol("WM_DELETE_WINDOW", lambda: cerrar_ventana_agregar(cuadro_agregar_control))

# Función para cerrar la ventana de agregar control
def cerrar_ventana_agregar(cuadro):
    global ventana_agregar_abierta
    ventana_agregar_abierta = False  # Actualizar la variable para permitir abrirla nuevamente
    cuadro.destroy()  # Cerrar la ventana

# Función para agregar datos al Treeview
def agregar_datos_al_treeview(combo_l_refuerzo, entry_control_S, entry_control_longitud):
    # Obtener los valores de los Entry y ComboBox
    seleccion_refuerzo = combo_l_refuerzo.get()
    separacion_r_s = entry_control_S.get()
    longitud_r_s = entry_control_longitud.get()
    
    # Asegurarnos de que los valores son numéricos para realizar el cálculo
    try:
        separacion_r_s = float(separacion_r_s)
        longitud_r_s = float(longitud_r_s)
    except ValueError:
        return  # Si los valores no son numéricos, no hacer nada
    
    # Cálculo de UN_flejes
    if seleccion_refuerzo == "Tramo 1":
        UN_flejes = (longitud_r_s / separacion_r_s) + 1
        resultado_UN_fleje = math.ceil(UN_flejes)
        resultado_UN_fleje = f'{resultado_UN_fleje:.1f}'
    elif seleccion_refuerzo in ["Tramo 2", "Tramo 3"]:
        UN_flejes = longitud_r_s / separacion_r_s
    
    # Redondeamos a 10 decimales para evitar errores de precisión flotante
        UN_flejes = round(UN_flejes, 10)

    # Comprobamos si el resultado es entero
        if UN_flejes.is_integer():
            resultado_UN_fleje = f'{int(UN_flejes):.1f}'  # Convertimos a entero y mostramos con ".0"
        else:
            resultado_UN_fleje = f'{UN_flejes:.1f}'  # Mantenemos formato con un decimal
    
    
    # Verificar que los campos no estén vacíos
    if not separacion_r_s or not longitud_r_s:
        return  # Si algún campo está vacío, no hacemos nada
    
    # Según la opción del ComboBox, actualizamos la fila correspondiente
    if seleccion_refuerzo == "Tramo 1":
        # Actualizamos la primera fila (L.max)
        treeview_control.item(treeview_control.get_children()[0], values=("Tramo 1", longitud_r_s, separacion_r_s, resultado_UN_fleje))
    elif seleccion_refuerzo == "Tramo 2":
        # Actualizamos la segunda fila (L.medio)
        treeview_control.item(treeview_control.get_children()[1], values=("Tramo 2", longitud_r_s, separacion_r_s, resultado_UN_fleje))
    elif seleccion_refuerzo == "Tramo 3":
        # Actualizamos la tercera fila (L.min)
        treeview_control.item(treeview_control.get_children()[2], values=("Tramo 3", longitud_r_s, separacion_r_s, resultado_UN_fleje))
    else:
        return  # Si la selección no es válida, no hacer nada

def Cantidad_estribos():
    suma_UN = 0

    for item in treeview_control.get_children():
        valores = treeview_control.item(item, "values")

        if len(valores) > 3:
            valor_UN = valores[3].strip()

            try:
                valor_UN = float(valor_UN)  # Convertimos a float
                suma_UN += int(valor_UN)    # Convertimos a int y sumamos correctamente
            except ValueError:
                pass  # Si hay un error, simplemente lo ignoramos

    # Obtener solo el número del combobox
    valor_combobox = combobox_estribo_st.get()
    numero_estribo = ''.join(filter(str.isdigit, valor_combobox))  # Extraer solo el número

    # Formato del resultado
    resultado_UN = f"{suma_UN} UN #{numero_estribo}"

    # Mostrar resultado en el entry
    entry_UN_flejes.delete(0, tk.END)
    entry_UN_flejes.insert(0, resultado_UN)

    # Obtener los valores de los labels
    valor_luz_UN = label_seccion_luz.cget("text")
    valor_seccion_UN = label_seccion_cargas.cget("text")

    # Actualizar los entries con los valores de los labels
    entry_UN_luz.delete(0, tk.END)
    entry_UN_luz.insert(0, f"{valor_luz_UN} m")

    entry_UN_viga.delete(0, tk.END)
    entry_UN_viga.insert(0, valor_seccion_UN)

# Función para obtener los datos del Treeview según el valor seleccionado
def obtener_datos_de_treeview(valor_seleccionado):
    # Buscar las filas del Treeview que coinciden con el valor seleccionado
    for item in treeview_control.get_children():
        # Obtener el valor de la primera columna
        valor_fila = treeview_control.item(item, "values")[0]
        # Verificar si el valor de la primera columna coincide con la selección
        if valor_fila == valor_seleccionado:
            # Devolver los valores de la fila
            return treeview_control.item(item, "values")
    return None  # En caso de no encontrar el valor

# Función que se llama cuando el usuario selecciona una opción en el ComboBox
def actualizar_label_con_datos(event):
    # Obtener el valor seleccionado del ComboBox
    seleccion_r = combo_r.get()
    
    # Obtener los datos del Treeview correspondientes a la opción seleccionada
    datos_r = obtener_datos_de_treeview(seleccion_r)
    
    if datos_r:
        # Actualizar el texto del Label con los datos de la fila
        label_r_info.config(text=f"Datos para {seleccion_r}:\n L(m):{datos_r[1]}\n S(m):{datos_r[2]}\n UN:{datos_r[3]}", anchor="w", justify="left")
    else:
        # En caso de no encontrar los datos, mostrar un mensaje adecuado
        label_r_info.config(text=f"No se encontraron datos para {seleccion_r}.")


# Variable global para controlar si la ventana de edición está abierta
ventana_edicion_abierta = None

def modificar_fila_control():
    """Permite modificar una fila seleccionada del Treeview."""
    global ventana_edicion_abierta

    # Verificar si ya hay una ventana de edición abierta
    if ventana_edicion_abierta is not None and ventana_edicion_abierta.winfo_exists():
        return  # No permitir abrir más de una ventana de edición

    selected_item = treeview_control.selection()  # Obtener la fila seleccionada
    
    if not selected_item:
        return  # Si no hay fila seleccionada, no hacer nada
    
    valores_treeview_control = treeview_control.item(selected_item, "values")  # Obtener los valores de la fila
    
    # Crear la ventana de edición
    ventana_edicion_abierta = tk.Toplevel()
    ventana_edicion_abierta.title("Modificar Fila")
    ventana_edicion_abierta.geometry("250x190")
    ventana_edicion_abierta.resizable(False, False)  # No permitir cambiar tamaño
    ventana_edicion_abierta.attributes('-topmost', True)  # Mantener ventana al frente

    # Función para cerrar la ventana correctamente
    def cerrar_ventana():
        global ventana_edicion_abierta
        ventana_edicion_abierta.destroy()
        ventana_edicion_abierta = None  # Marcar como cerrada
    
    ventana_edicion_abierta.protocol("WM_DELETE_WINDOW", cerrar_ventana)  # Evento al cerrar
    
    # Etiquetas y cuadros de entrada
    labels_treeview_control = ["L.refuerzo", "L(m)", "S(m)", "UN"]
    entries_treeview_control = []
    
    for i, label in enumerate(labels_treeview_control):
        tk.Label(ventana_edicion_abierta, text=label).grid(row=i, column=0, padx=10, pady=5)
        entry_treeview_control = tk.Entry(ventana_edicion_abierta)
        entry_treeview_control.grid(row=i, column=1, padx=10, pady=5)
        entry_treeview_control.insert(0, valores_treeview_control[i])  # Insertar el valor actual en el Entry
        entries_treeview_control.append(entry_treeview_control)
    
    def guardar_cambios():
        """Guarda los cambios en el Treeview y cierra la ventana."""
        nuevos_valores = [entry.get() for entry in entries_treeview_control]
        treeview_control.item(selected_item, values=nuevos_valores)  # Actualizar Treeview
        cerrar_ventana()  # Cerrar la ventana de edición
    
    # Botón para guardar cambios
    btn_guardar = ttk.Button(ventana_edicion_abierta, text="Guardar", command=guardar_cambios)
    btn_guardar.place(x=90,y=140)


# Función para actualizar el Entry según la selección del ComboBox
def actualizar_diametro(event):
    seleccion = combobox_estribo_st.get()  
    if seleccion == "E#3":
        entry_diametro_sr.delete(0, tk.END)  
        entry_diametro_sr.insert(0, "9.5 mm")  
    elif seleccion == "E#4":
        entry_diametro_sr.delete(0, tk.END)
        entry_diametro_sr.insert(0, "12.7 mm")  

ventana_abierta = False

def abrir_ventana_cortante():
    global ventana_abierta,frame_V,labelframe_grafica,entry_info_estribo,entry_info_area,combo_Vu_Wu,entry_Vu_ultimo
    global combo_ɸ_revision ,combo_fc_revision,combo_factor_λ,entry_ɸVc_revision,entry_ɸVcmedios_revision,check_revisar_widget
    global  checkbutton_1_V,checkbutton_2_V,checkbutton_3_V,check_condición_1,check_condición_2,check_condición_3
    global label_mensaje_condicion,entry_resistencia_Vs,label_copia_Vs,label_copia_seccion,label_cumple_Vs,label_conclusion_V
    global entry_Smax,radiobutton_S,entry_Av,radiobutton_Av,label_b_prueba,radiobutton_ramas,entry_ramas,label_ramas_V,entry_Vs_estribos
    global label_Vs_estribos_1,entry_resistencia_Vs_requerida,treeview_cortante,label_resistencia_total,treeview_cortante_valores
    global entry_ancho_C , entry_borde_C,check_longitud_refuerzo,check_longitud_refuerzo_var,canvas_longitud,slider_cortante,labelframe_estribos
    global entry_posicion,imagen_agregar,imagen_eliminar,boton_agregar_marcador,boton_eliminar_marcador,lineas_discontinuas,cotas,label_primer_estribo
    global ultimo_valor_borde_C,textos_cotas,borde_valor,smax_var 
    
    # Solo abrir la ventana si no está abierta ya
    if not ventana_abierta:
        # Crear una nueva ventana de tipo Toplevel
        ventana_cortante = tk.Toplevel()
        
        # Configurar la ventana para que no se pueda redimensionar
        ventana_cortante.resizable(False, False)
        
        # Asegurar que la ventana esté siempre en el frente
        ventana_cortante.attributes('-topmost', True)
        
        # Establecer un tamaño para la ventana
        ventana_cortante.geometry('850x600')
        
        # Agregar un título a la ventana
        ventana_cortante.title("Diseño cortante")
        
        # Agregar contenido a la ventana
        labelframe_cortante = tk.LabelFrame(ventana_cortante, text="")
        labelframe_cortante.place(x=10, y=10, width=830, height=540)
        
        # Crear el estilo para personalizar las pestañas
        style = ttk.Style()
        
        # Estilo para el Notebook
        style.configure("CustomNotebook.TNotebook", 
                        background="lightgray",  
                        tabmargins=[0, 0, 0, 0])  
        
        # Estilo para las pestañas
        style.configure("CustomNotebook.TNotebook.Tab", 
                        background="white",   
                        foreground="black",   
                        padding=[10, 2],      
                        font=("Arial", 9))    
        
        # Estilo para la pestaña seleccionada
        style.map("CustomNotebook.TNotebook.Tab", 
                    background=[("selected", "lightgray")],  
                    foreground=[("selected", "black")])  
        
        # Crear el Notebook dentro del LabelFrame
        notebook_Cortante = ttk.Notebook(labelframe_cortante,style="CustomNotebook.TNotebook")
        notebook_Cortante.pack(fill="both", expand=True)
        
        # Crear las  pestañas del Notebook
        tab_requisitos = tk.Frame(notebook_Cortante)
        tab_diseño = tk.Frame(notebook_Cortante)
        tad_optimización = tk.Frame(notebook_Cortante)
        
        # Insertar las pestañas en el Notebook
        notebook_Cortante.add(tab_requisitos, text="Requisitos NSR-10")
        notebook_Cortante.add(tab_diseño, text="Diseño cortante")
        notebook_Cortante.add(tad_optimización, text="Optimización de estribos")
        
        # Crear labelframe para contenido de generalidades 
        labelframe_generalidades = tk.LabelFrame(tab_requisitos, text="")
        labelframe_generalidades.place(x=10, y=10, width=400, height=490)
        
        # Crear el Notebook dentro del LabelFrame de generalidades
        notebook_generalidades = ttk.Notebook(labelframe_generalidades,style="CustomNotebook.TNotebook")
        notebook_generalidades.pack(fill="both", expand=True)
        
        # Crear la pestaña del Notebook de generalidades 
        tab_generalidades = tk.Frame(notebook_generalidades)
        
        
        # Crear un Canvas dentro de la pestaña
        canvas_cortante = tk.Canvas(tab_generalidades,width=380, height=460)
        canvas_cortante.pack(fill="both", expand=True)
        
        labelframe_V= tk.LabelFrame(canvas_cortante,text="")
        
        label_V = tk.Label(labelframe_V, text="El diseño a cortante es fundamental porque la falla asociada a este efecto es considerada una falla frágil.Este tipo de falla ocurre de manera repentina y sin señales previas, lo cual es muy riesgoso. Por ello, en el diseño estructural de una viga, se busca evitar la falla por cortante.", 
                        justify="left", anchor="center",wraplength=320 )
        label_V.place(x=0,y=10)
        
        frame_V = tk.Frame(canvas_cortante,bg="white",bd=2,relief="ridge")
        
        # Cargar la imagen
        img_path = "Iconos_proyecto/esfuerzos.png"  # Asegúrate de que la ruta sea correcta
        img = Image.open(img_path)
        img = img.resize((300, 100))  # Ajusta el tamaño de la imagen según sea necesario
        
        # Convierte la imagen a un formato que Tkinter pueda usar
        img_tk = ImageTk.PhotoImage(img)
        
        # Inserta la imagen en un Label dentro del Frame
        label_img = tk.Label(frame_V, image=img_tk)
        label_img.image = img_tk  # Mantén una referencia de la imagen
        label_img.pack()
        
        labelframe_V_info = tk.LabelFrame(canvas_cortante)
        label_V_info = tk.Label(labelframe_V_info,
                        text="En una sección transversal, los esfuerzos son una combinación de esfuerzos cortantes y normales. En el eje neutro, el esfuerzo cortante alcanza su valor máximo, mientras que el esfuerzo normal es cero.Esta condición permite que los esfuerzos principales se ubiquen en un plano de 45°.",
                        justify="left", anchor="center", wraplength=320)
        label_V_info.place(x=0,y=0)
        
        labelframe_V_falla = tk.LabelFrame(canvas_cortante,text="Falla a cortante")
        label_V_falla= tk.Label(labelframe_V_falla,text="En el diseño a cortante de vigas de concreto reforzado, se busca que la viga falle por flexión, lo que es una falla dúctil, en lugar de fallar por cortante, que es una falla frágil.Esta última se considera frágil porque genera tensiones diagonales.",
                            justify="left", anchor="center", wraplength=320)
        label_V_falla.place(x=0,y=0)
        
        frame_V_falla = tk.Frame(canvas_cortante,bg="white",bd=2,relief="ridge")
        
        # Cargar la imagen
        img_cortante = Image.open("Iconos_proyecto/viga_reforzada.png")  # Ruta de la imagen
        img_cortante = img_cortante.resize((150, 100))  # Puedes ajustar el tamaño de la imagen si es necesario
        photo_cortante = ImageTk.PhotoImage(img_cortante)
        
        # Crear un Label para contener la imagen
        label_img_cortante = tk.Label(frame_V_falla, image=photo_cortante, bg="white")
        label_img_cortante.image = photo_cortante  # Mantén una referencia de la imagen
        label_img_cortante.pack()
        
        labelframe_V_1 = tk.LabelFrame(canvas_cortante,text="")
        
        label_V_1 = tk.Label(
        labelframe_V_1,
        text="El elemento que contrarrestará la falla por cortante son los estribos. Lo ideal es colocar estribos perpendiculares al eje de la viga y ubicarlos a una separación mínima necesaria para reducir el efecto de la falla por tracción diagonal.\n\n"
        "El comportamiento de las vigas de concreto reforzado con refuerzo transversal depende de la carga distribuida a lo largo de toda la longitud de la viga. Los estribos tienen un área aferente que corresponde a la separación entre ellos, "
        "y la cortante que puede ser absorbida por los estribos está relacionada con su área. La cortante disminuye a lo largo de la cara de la sección, por lo que el estribo debe contar con al menos dos ramas de confinamiento para ofrecer resistencia al cortante.",
        justify="left",
        anchor="center",
        wraplength=320
        )
        label_V_1.place(x=0,y=0)
        
        # Insertar la pestaña en el Notebook de generalidades
        notebook_generalidades.add(tab_generalidades, text="Generalidades")
        
        labelframe_re_V = tk.LabelFrame(tab_requisitos,text="")
        labelframe_re_V.place(x=420,y=10,width=390,height=80)
        
        label_re_V = tk.Label(labelframe_re_V,text="A continuación, se detallan los requisitos mínimos establecidos por la Norma NSR-10.Estos requisitos son fundamentales para calcular el diseño a cortante.",
                            justify="left",
                            anchor="center",
                            wraplength=350)
        
        label_re_V.place(x=10,y=10)
        
        labelframe_NSR10 = tk.LabelFrame(tab_requisitos,text="")
        labelframe_NSR10.place(x=420,y=100,width=390,height=400)
        
        # Crear el Notebook
        Notebook_NSR10 = ttk.Notebook(labelframe_NSR10,style="CustomNotebook.TNotebook")  # Crear el Notebook dentro del LabelFrame
        
        # Crear una pestaña dentro del Notebook
        tab_requisitos_NSR10 = ttk.Frame(Notebook_NSR10)  # Aquí es donde puedes colocar el contenido de la pestaña
        
        # Agregar la pestaña al Notebook con el título 'Requisitos'
        Notebook_NSR10.add(tab_requisitos_NSR10, text="Requisitos")
        
        # Empaquetar el Notebook en el LabelFrame
        Notebook_NSR10.pack(fill="both", expand=True)
        
        # Crear un Canvas dentro de la pestaña 'tab_requisitos_NSR10'
        canvas_nsr10 = tk.Canvas(tab_requisitos_NSR10, width=380, height=380)  # Ajusta el tamaño según lo necesario
        canvas_nsr10.pack(fill="both", expand=True)
        
        labelframe_req_1 = tk.LabelFrame(canvas_nsr10,text="")
        
        label_req_1 = tk.Label(labelframe_req_1 ,text="Diseño a Cortante y Torsión según la Norma NSR-10 (Capítulo C.11).",
                            justify="left",
                            anchor="center",
                            wraplength=280)
        
        label_req_1.place(x=0,y=10)
        
        labelframe_req_2 = tk.LabelFrame(canvas_nsr10,text="")
        
        label_req_2 = tk.Label(labelframe_req_2, text="[C.11.1] Se define el metodo de resistencia a cortante.\n\n"
                "El método de resistencia establece como condición de diseño que la solicitación a la que está sometido un elemento estructural debe ser menor o igual a su capacidad de resistencia.\n\n"
                "Vu = Resistencia o solicitación requerida\n"
                "ɸVn = Capacidad nominal de diseño\n\n"
                "Especifica tambien que la resistencia nominal de diseño va ser igual a lo que aporta el concreto más el acero,Por lo tanto, la expresión será:\n\n"
                "Vu = ɸ[Vc+Vs]\n\n"
                "[C.9.3.2.3] Se define el valor de ɸ para el diseño a cortante y torsión. En este caso, ɸ para el diseño cortante se establece en 0.75, ya que la norma reduce la capacidad de diseño con el objetivo de garantizar que el elemento falle primero por flexión antes que por cortante.\n\n"
                "[C.11.1.3] Especifica las condiciones bajo las cuales se puede realizar el diseño de cortante [Vu].\n\n",   
                justify="left",
                anchor="center",
                wraplength=300)
        
        label_req_2.place(x=10,y=10)
        
        frame_req_2 = tk.Frame(labelframe_req_2,bd=2,relief="ridge")
        frame_req_2.place(x=10,y=410,width=300,height=300)
        
        # Ruta de la imagen (cambiar a 'image_path_req')
        image_path_req = "Iconos_proyecto/diagrama_V_Wu.png"  # Ruta relativa
        
        # Abrir la imagen con PIL
        img_pil = Image.open(image_path_req)
        
        # Redimensionar la imagen (ajustar al tamaño del frame)
        img_resized = img_pil.resize((280, 280))  # Cambiar 300x300 por las dimensiones que prefieras
        
        # Convertir la imagen redimensionada a un formato compatible con Tkinter
        img_req = ImageTk.PhotoImage(img_resized)
        
        # Insertar la imagen en el Frame con un Label
        label_with_image = tk.Label(frame_req_2, image=img_req,bg="white")
        label_with_image.pack(fill="both", expand=True)
        
        # Mantener la referencia de la imagen
        label_with_image.image = img_req 
        
        label_req_3 = tk.Label(labelframe_req_2,text="Vmax = Cortante máximo en el eje del apoyo.\n"
                            "Vud = Cortante a una distancia 'd',de la cara del apoyo\n\n"
                            "Como evidentemente Vud es menor que Vmax, la norma permite diseñar la viga con Vud."
                            "Si se cumple que inicialmente existe una reacción de compresión,la siguiente condición es que entre la cara del apoyo y la distancia 'd' no debe haber una carga puntual.La carga puntual debe ubicarse más allá de dicha distancia 'd'.\n\n"
                            "[C.11.2] Se menciona la resistencia a cortante proporcionada por el concreto [Vc]\n\n"
                            "[C.11.2.1] La norma especifica el valor de Vc que se utiliza para calcular la resistencia de los elementos sometidos a flexión y cortante en vigas\n\n"
                            "Vc = 0.17*λ*√f'c*b*d\n\n"
                            "[C.11.2.1] Resistencia a cortante del refuerzo transversal.\n"
                            "Tipos: Estribos inclinados.\n"
                            "           Estribos paralelos al eje de la viga.\n"
                            "           Estribos espirales.\n\n"
                            "[C.11.2.1] Limites para la separación a cortante.\n"
                            "Estribos paralelos al eje:\n"
                            " A)      Sí Vs < 0.33*√f'c*b*d\n"    
                            "           S ≤ {d/2 ó 60cm}\n"
                            " B)      Sí Vs > 0.33*√f'c*b*d\n"
                            "           S ≤ {d/4 ó 30cm}\n\n"
                            "[C.11.4.6] Refuerzo mínimo a cortante.\n"
                            "Si Vu > ɸVc Entonces: Diseñar refuerzo transversal\n"
                            "Si 1/2*ɸVc < Vu < ɸVc Entonces: Colocar área mínima\n"
                            "Si Vu < 1/2*ɸVc Entonces: No se necesita refuerzo transversal\n\n"
                            "Nota: Estas son las condiciones basicas de como debemos diseñar una sección de concreto reforzado para cortante."
                            "El refuerzo transversal se debe llevar por lo menos hasta una sección donde Vu= 1/2*ɸVc\n\n"
                            "[C.11.4.6] La norma presenta una ecuación en función a una separación mínima.\n"
                            "A)     S₁ = Av*fy/0.062*√f'c*b\n"
                            "B)     S₂ = Av*fy/0.35*b\n"
                            "C)     Smax = min{S₁,S₂}\n\n"
                            "En el diseño a cortante de elementos estructurales, es mucho más facil garantizar el control de la separación mínima de los estribos utilizando la ecuación que define la cuantía de acero mínimo.\n\n"
                            "[C.11.4.7.2] Diseño de refuerzo para cortante Vu > ɸVc\n"
                            "De acuerdo con la norma, los estribos deben colocarse perpendiculares al eje del elemento. En este sentido, la norma establece que la capacidad de los estribos será igual a la expresión siguiente:\n\n"
                            "Vs = d*[Av*fy]/s\n"
                            "Av = Es la suma del área del número de ramas del estribo\n",
                            justify="left",
                            anchor="center",
                            wraplength=300)
        label_req_3.place(x=10,y=720)
        
        frame_req_3 = tk.Frame(labelframe_req_2,bd=2,relief="ridge",bg="white")
        frame_req_3.place(x=80,y=1640,width=170,height=150)
        
        # Ruta de la imagen
        image_path_cortante = "Iconos_proyecto/Cortante_Estribo.png"
        
        # Cargar la imagen con PIL
        img_cortante = Image.open(image_path_cortante)
        
        # Redimensionar la imagen si es necesario
        img_cortante = img_cortante.resize((170, 150), Image.Resampling.LANCZOS)  # Ajustar al tamaño del Frame
        
        # Convertir la imagen a formato compatible con Tkinter
        photo_cortante = ImageTk.PhotoImage(img_cortante)
        
        # Crear un Label para mostrar la imagen dentro del Frame
        label_img_cortante = tk.Label(frame_req_3, image=photo_cortante)
        label_img_cortante.image = photo_cortante  # Guardar la referencia de la imagen
        label_img_cortante.pack()
        
        label_req_4= tk.Label(labelframe_req_2,text="[C.11.4.7.9] Establece que se debe verificar el control de tamaño de la sección:\n\n"
                            "A)   Vs ≤ 0.66*√f'c*b*d\n"
                            "A) Si Vs > 0.66*√f'c*b*d entonces, se debe aumentar las dimensiones de la sección.\n\n"
                            "Finalmente, estos serían los requisitos mínimos para el cálculo del diseño a cortante en vigas,ahora realiza las configuraciones correspondientes",
                            justify="left",
                            anchor="center",
                            wraplength=300)
        label_req_4.place(x=10,y=1800)
        
        #Crear botones ventana diseño cortante
        boton_aceptar_cortante = ttk.Button(ventana_cortante,text="Aceptar",command=Crear_grafica_cortante)
        boton_aceptar_cortante.place(x=180,y=560,width=100)
        
        boton_agregar_cortante = ttk.Button(ventana_cortante,text="Agregar datos",command=agregar_datos_treeview_cortante)
        boton_agregar_cortante.place(x=360,y=560,width=100)
        
        boton_cancelar_cortante = ttk.Button(ventana_cortante,text="Cancelar",command=lambda: cerrar_ventana_v(ventana_cortante))
        boton_cancelar_cortante.place(x=540,y=560,width=100)
        
        #Agregar contenido en la pestaña tab_diseño
        labelframe_Diseño_V = tk.LabelFrame(tab_diseño,text="")
        labelframe_Diseño_V.place(x=10,y=10,width=400,height=40)
        
        # Variables para los Checkbuttons
        var_estribo = tk.BooleanVar()
        var_grafica = tk.BooleanVar()
        
        # Crear los Checkbuttons dentro del LabelFrame
        check_estribo = tk.Checkbutton(labelframe_Diseño_V, text="Estribo de diseño", variable=var_estribo,command=Estribo_diseño)
        check_estribo.place(x=40, y=5)
        
        check_grafica = tk.Checkbutton(labelframe_Diseño_V, text="Mostrar gráfica de cortante", variable=var_grafica,command=Crear_grafica_cortante)
        check_grafica.place(x=190, y=5)
        
        labelframe_Esquema = tk.LabelFrame(tab_diseño)
        labelframe_Esquema.place(x=10,y=60,width=400,height=390)
        
        # Crear el Notebook
        Notebook_Esquema = ttk.Notebook(labelframe_Esquema,style="CustomNotebook.TNotebook")  # Crear el Notebook dentro del LabelFrame
        
        # Crear una pestaña dentro del Notebook
        tab_Esquema = ttk.Frame(Notebook_Esquema)  # Aquí es donde puedes colocar el contenido de la pestaña
        
        # Agregar la pestaña al Notebook con el título 'Cálculos previos'
        Notebook_Esquema.add(tab_Esquema, text="Cálculos previos")
        
        # Empaquetar el Notebook en el LabelFrame
        Notebook_Esquema.pack(fill="both", expand=True)
        
        # Crear un Canvas dentro de la pestaña 'tab_Esquema'
        canvas_esquema = tk.Canvas(tab_Esquema)  # Ajusta el tamaño según lo necesario
        canvas_esquema.pack(fill="both", expand=True)
        
        # Crear el Scrollbar vertical
        scrollbar_esquema = tk.Scrollbar(tab_Esquema, orient="vertical",command=canvas_esquema.yview)
        scrollbar_esquema.place(x=370, y=0, width=20, height=355)
        
        # Vincular el Scrollbar vertical al Canvas
        canvas_esquema.config(yscrollcommand=scrollbar_esquema.set)
        
        labelframe_grafica = tk.LabelFrame(canvas_esquema,text="Gráfica de fuerza cortante [V]")
        
        labelframe_info_1 = tk.LabelFrame(canvas_esquema,text="")
        
        label_info_1 = tk.Label(labelframe_info_1,text="Estribo:")
        label_info_1.place(x=10,y=10)
        
        entry_info_estribo = tk.Entry(labelframe_info_1)
        entry_info_estribo.place(x=60,y=10,width=100)
        
        label_info_2 = tk.Label(labelframe_info_1,text="Área:")
        label_info_2.place(x=180,y=10)
        
        entry_info_area = tk.Entry(labelframe_info_1)
        entry_info_area.place(x=220,y=10,width=100)
        
        labelframe_Vu = tk.LabelFrame(canvas_esquema,text="Calcular cortante último [Vu]")
        
        label_Vu_Wu = tk.Label(labelframe_Vu,text="Wu:")
        label_Vu_Wu.place(x=20,y=10)
        
        combo_Vu_Wu = ttk.Combobox(labelframe_Vu)
        combo_Vu_Wu.place(x=60,y=10,width=100)
        # Asociar la función al evento de selección en el ComboBox
        combo_Vu_Wu.bind("<<ComboboxSelected>>", Calcular_Cortante_Vu)
        
        label_Vu_ultimo = tk.Label(labelframe_Vu,text="Vu:")
        label_Vu_ultimo.place(x=180,y=10)
        
        entry_Vu_ultimo = tk.Entry(labelframe_Vu)
        entry_Vu_ultimo.place(x=220,y=10,width=100)
        
        labelframe_revision = tk.LabelFrame(canvas_esquema,text="Revisar condiciones de diseño")
        
        label_ɸ_revision = tk.Label(labelframe_revision,text="ɸCortante:")
        label_ɸ_revision.place(x=70,y=10)
        
        combo_ɸ_revision = ttk.Combobox(labelframe_revision,values=("0.75",))
        combo_ɸ_revision.place(x=150,y=10,width=100)
        combo_ɸ_revision.set("Seleccionar")
        
        label_fc_revision = tk.Label(labelframe_revision,text="Concreto:")
        label_fc_revision.place(x=70,y=70)
        
        combo_fc_revision = ttk.Combobox(labelframe_revision,values=("17.5 Mpa","21 Mpa","24.5 Mpa","28 Mpa","35 Mpa","42 Mpa"))
        combo_fc_revision.place(x=150,y=70,width=100)
        combo_fc_revision.set("Seleccionar")
        #Asociar la función al evento de selección en el combo_factor_λ
        combo_fc_revision.bind("<<ComboboxSelected>>", Calcular_Resistencia_ɸVc)
        
        label_factor_λ = tk.Label(labelframe_revision,text="Factor λ:")
        label_factor_λ.place(x=70,y=40)
        
        combo_factor_λ = ttk.Combobox(labelframe_revision,values=("1.0",))
        combo_factor_λ.place(x=150,y=40,width=100)
        combo_factor_λ.set("Seleccionar")
        
        label_ɸVc_revision = tk.Label(labelframe_revision,text="ɸVc:")
        label_ɸVc_revision.place(x=90,y=100)
        
        entry_ɸVc_revision = tk.Entry(labelframe_revision)
        entry_ɸVc_revision.place(x=150,y=100,width=100)
        
        label_ɸVcmedios_revision = tk.Label(labelframe_revision,text="ɸVc/2:")
        label_ɸVcmedios_revision.place(x=90,y=130)
        
        entry_ɸVcmedios_revision = tk.Entry(labelframe_revision)
        entry_ɸVcmedios_revision.place(x=150,y=130,width=100)
        
        # Variable que controla el estado del checkbox
        check_revisar = tk.BooleanVar()
        
        check_revisar_widget = tk.Checkbutton(canvas_esquema, text="Revisar lo que resiste el concreto", variable=check_revisar,
                                            command=Revisar_condiciones_diseño)
        
        labelframe_condiciones = tk.LabelFrame(canvas_esquema,text="")
        
        # Crear las variables para los checkbuttons
        check_condición_1 = tk.BooleanVar()
        check_condición_2 = tk.BooleanVar()
        check_condición_3 = tk.BooleanVar()
        
        # Crear los checkbuttons
        checkbutton_1_V = tk.Checkbutton(labelframe_condiciones, text="Sí Vu > ɸVc [Diseñar refuerzo transversal]", variable=check_condición_1)
        checkbutton_1_V.place(x=10,y=10)
        checkbutton_2_V = tk.Checkbutton(labelframe_condiciones, text="Sí ɸVc/2 < Vu < ɸVc [Colocar área mínima]", variable=check_condición_2)
        checkbutton_2_V.place(x=10,y=40)
        checkbutton_3_V = tk.Checkbutton(labelframe_condiciones, text="Sí Vu < ɸVc/2 [No necesita refuerzo transversal]", variable=check_condición_3)
        checkbutton_3_V.place(x=10,y=70)
        
        labelframe_mensaje = tk.LabelFrame(labelframe_condiciones,text="Resistencia a cortante del concreto [ɸVc]")
        labelframe_mensaje.place(x=10,y=100,width=325,height=60)
        
        label_mensaje_condicion =tk.Label(labelframe_mensaje,text="")
        label_mensaje_condicion.place(x=10,y=10)
        
        labelframe_resistencia_acero = tk.LabelFrame(canvas_esquema,text="Resistencia del acero transversal [Vs]")
        
        label_resistencia_Vs = tk.Label(labelframe_resistencia_acero,text="Vs:")
        label_resistencia_Vs.place(x=20,y=15)
        
        entry_resistencia_Vs = tk.Entry(labelframe_resistencia_acero)
        entry_resistencia_Vs.place(x=60,y=15,width=100)
        
        label_resistencia_ɸVc = tk.Label(labelframe_resistencia_acero,text="ɸCortante: 0.75")
        label_resistencia_ɸVc.place(x=210,y=15)
        
        labelframe_verificacion = tk.LabelFrame(canvas_esquema,text="Control del tamaño de la sección del concreto")
        
        label_verificacion = tk.Label(labelframe_verificacion,text="Sí Vs ≤ 66% Sección:")
        label_verificacion.place(x=220,y=10)
        
        label_verificacion_Vs = tk.Label(labelframe_verificacion,text="Resistencia:")
        label_verificacion_Vs.place(x=10,y=10)
        
        label_copia_Vs = tk.Label(labelframe_verificacion,text="",bd=2,relief="sunken")
        label_copia_Vs.place(x=95,y=10,width=80)
        
        label_verificacion_seccion = tk.Label(labelframe_verificacion,text="66% Sección:")
        label_verificacion_seccion.place(x=10,y=35)
        
        label_copia_seccion = tk.Label(labelframe_verificacion,text="",bd=2,relief="sunken")
        label_copia_seccion.place(x=95,y=35,width=80)
        
        label_cumple_Vs = tk.Label(labelframe_verificacion,text="",bd=2,relief="sunken")
        label_cumple_Vs.place(x=240,y=35,width=80)
        
        label_conclusion_V = tk.Label(tab_diseño,text="",
                                    bd=2,
                                    relief="sunken",
                                    justify="left",
                                    anchor="center",
                                    wraplength=380)
        label_conclusion_V.place(x=10,y=450,width=400,height=57)
        
        labelframe_separacion_req = tk.LabelFrame(tab_diseño,text="Separación máxima según la NSR-10 [Vs]")
        labelframe_separacion_req.place(x=420,y=2,width=395,height=60)
        
        # Crear un IntVar para controlar el estado del Checkbutton
        var_S = tk.IntVar(value=0)
        
        radiobutton_S = tk.Radiobutton(labelframe_separacion_req,text="Calcular Smax",variable=var_S,command=Calcular_Smax)
        radiobutton_S.place(x=10,y=5)
        
        label_Smax= tk.Label(labelframe_separacion_req,text="Smax:")
        label_Smax.place(x=200,y=5)
        
        # Crear una variable de tipo StringVar para monitorear el cambio en entry_Smax
        smax_var = tk.StringVar()
        
        # Asociar el StringVar con el entry_Smax
        entry_Smax= tk.Entry(labelframe_separacion_req)
        entry_Smax.place(x=250,y=5,width=100)
        entry_Smax.config(textvariable=smax_var)
        
        # Usar trace para que llame a la función cada vez que el valor de entry_Smax cambie
        smax_var.trace("w", actualizar_label_Smax)
        
        labelframe_Av = tk.LabelFrame(tab_diseño,text="Calcular el acero de refuerzo transversal")
        labelframe_Av.place(x=420,y=63,width=395,height=60)
        
        # Crear un IntVar para controlar el estado del Checkbutton
        var_Av = tk.IntVar(value=0)
        
        radiobutton_Av = tk.Radiobutton(labelframe_Av,text="Calcular Av",variable=var_Av,command=Calcular_Av)
        radiobutton_Av.place(x=10,y=5)
        
        label_Av = tk.Label(labelframe_Av,text="Av:")
        label_Av.place(x=205,y=5)
        
        entry_Av = tk.Entry(labelframe_Av)
        entry_Av.place(x=250,y=5,width=100)
        
        labelframe_calcular_ramas = tk.LabelFrame(tab_diseño,text="Calcular el número de ramas de estribos")
        labelframe_calcular_ramas.place(x=420,y=125,width=395,height=60)
        
        # Crear un IntVar para controlar el estado del Checkbutton
        var_ramas = tk.IntVar(value=0)
        
        radiobutton_ramas = tk.Radiobutton(labelframe_calcular_ramas,text="Calcular #ramas",variable=var_ramas,command=Calcular_numero_ramas)
        radiobutton_ramas.place(x=10,y=5)
        
        label_ramas = tk.Label(labelframe_calcular_ramas,text="#ramas:")
        label_ramas.place(x=190,y=5)
        
        entry_ramas = tk.Entry(labelframe_calcular_ramas)
        entry_ramas.place(x=250,y=5,width=100)
        
        label_ramas_V = tk.Label(tab_diseño,text="",bd=2,relief="sunken",
                                justify="left",
                                anchor="center",
                                wraplength=380)
        label_ramas_V.place(x=420,y=190,width=395,height=50)
        
        labelframe_resistencia_estribos = tk.LabelFrame(tab_diseño,text="Calcular resistencia de los estribos en función de la separación")
        labelframe_resistencia_estribos.place(x=420,y=245,width=395,height=60) 
        
        var_resistencia = tk.IntVar(value=0)
        radiobutton_resistencia = tk.Radiobutton(labelframe_resistencia_estribos,text="Calcular resistencia",variable=var_resistencia,
                                command=Calcular_Vs_resistencia_estribos)
        radiobutton_resistencia.place(x=10,y=5)
        
        label_Vs_estribos = tk.Label(labelframe_resistencia_estribos,text="Vs:")
        label_Vs_estribos.place(x=200,y=5)
        
        entry_Vs_estribos = tk.Entry(labelframe_resistencia_estribos)
        entry_Vs_estribos.place(x=250,y=5,width=100)
        
        label_Vs_estribos_1 = tk.Label(tab_diseño,text="",bd=2,relief="sunken",
                                    justify="left",
                                    anchor="center",
                                    wraplength=380)
        label_Vs_estribos_1.place(x=420,y=310,width=395,height=50)
        
        labelframe_disposicion_estribos = tk.LabelFrame(tab_diseño,text="Disposición de los estribos")
        labelframe_disposicion_estribos.place(x=420,y=365,width=395,height=140)
        
        label_disposicion_estribos = tk.Label(labelframe_disposicion_estribos,text="Los estribos deben ser colocados de manera que se extiendan,como mínimo, hasta la sección en la que el esfuerzo cortante alcance el valor de Vu=1/2 ɸVc.\n"
                                            "Se recomienda colocar el primer estribo cerca de la cara del apoyo, a unos 5cm, ya que en esa zona la maginitud del cortante tambien es alta.Además,esta practica es conveniente en las obras, ya que facilita la colocación de los estribos.",
                                            justify="left",
                                            anchor="center",
                                            wraplength=380)
        label_disposicion_estribos.place(x=10,y=1)
        
        labelframe_optimizacion = tk.LabelFrame(tad_optimización,text="")
        labelframe_optimizacion.place(x=10,y=10,width=400,height=60)
        
        # Variable que controla el estado del checkbox
        check_resistencia = tk.BooleanVar()
        check_resistencia_total = tk.BooleanVar()
        check_resistencia = tk.Checkbutton(labelframe_optimizacion, text="Calcular resistencia requerida [Vs]", variable=check_resistencia,
                                        command=Calcular_resistencia_Vs_requerida)
        check_resistencia.place(x=10, y=5)
        check_resistencia_total = tk.Checkbutton(labelframe_optimizacion, text="Calcular resistencia total [ɸVn]", variable=check_resistencia_total,
                                        command=Calcular_resistencia_total_Vn)
        check_resistencia_total.place(x=10, y=30)
        
        entry_resistencia_Vs_requerida = tk.Entry(labelframe_optimizacion)
        #entry_resistencia_Vs_requerida.place(x=220,y=5,width=100)
        
        # Crear la tabla Treeview en la pestaña  'tad_optimización'
        treeview_cortante = ttk.Treeview(tad_optimización, columns=("Vs", "Vu", "ɸVn", "Vu ≤ ɸVn"), show="headings")
        treeview_cortante.place(x=10, y=80, width=400, height=80)
        
        # Definir las columnas
        treeview_cortante.heading("Vs", text="Vs")
        treeview_cortante.heading("Vu", text="Vu")
        treeview_cortante.heading("ɸVn", text="ɸVn")
        treeview_cortante.heading("Vu ≤ ɸVn", text="Vu ≤ ɸVn")
        
        # Configurar el ancho de las columnas
        treeview_cortante.column("Vs", width=50,anchor="center")
        treeview_cortante.column("Vu", width=50,anchor="center")
        treeview_cortante.column("ɸVn", width=50,anchor="center")
        treeview_cortante.column("Vu ≤ ɸVn", width=50,anchor="center")
        
        
        def no_resize(event):
        # Restaurar el tamaño original de las columnas usando un ciclo
            for col in treeview_cortante["columns"]:
                treeview_cortante.column(col, width=99, anchor="center")
        
        # Vincular el evento de clic con la función no_resize
        treeview_cortante.bind("<ButtonRelease-1>", no_resize)
        
        label_resistencia_total = tk.Label(tad_optimización,text="",bd=2,relief="sunken",
                                        justify="left",
                                        anchor="center",
                                        wraplength=380)
        label_resistencia_total.place(x=10,y=170,width=400,height=50)
        
        check_valores = tk.BooleanVar()
        check_valores = tk.Checkbutton(tad_optimización, text="Valores críticos y de diseño cortante", variable=check_valores,
                                        command=Insertar_datos_cortante_diseño)
        
        check_valores.place(x=10, y=220)
        
        # Crear la tabla Treeview en la pestaña  'tad_optimización'
        treeview_cortante_valores = ttk.Treeview(tad_optimización, columns=("Vmax", "Vu", "ɸVc", "ɸVc/2"), show="headings")
        treeview_cortante_valores.place(x=10, y=250, width=400, height=80)
        
        # Definir las columnas
        treeview_cortante_valores.heading("Vmax", text="Vmax")
        treeview_cortante_valores.heading("Vu", text="Vu")
        treeview_cortante_valores.heading("ɸVc", text="ɸVc")
        treeview_cortante_valores.heading("ɸVc/2", text="ɸVc/2")
        
        # Configurar el ancho de las columnas
        treeview_cortante_valores.column("Vmax", width=50,anchor="center")
        treeview_cortante_valores.column("Vu", width=50,anchor="center")
        treeview_cortante_valores.column("ɸVc", width=50,anchor="center")
        treeview_cortante_valores.column("ɸVc/2", width=50,anchor="center")
        
        
        def no_resize(event):
        # Restaurar el tamaño original de las columnas usando un ciclo
            for col in treeview_cortante_valores["columns"]:
                treeview_cortante_valores.column(col, width=99, anchor="center")
        
        # Vincular el evento de clic con la función no_resize
        treeview_cortante_valores.bind("<ButtonRelease-1>", no_resize)
        
        labelframe_columna = tk.LabelFrame(tad_optimización,text="Ancho mínimo de la columna")
        labelframe_columna.place(x=10,y=340,width=400,height=150)
        
        label_ancho_C = tk.Label(labelframe_columna,text="Ancho columna:")
        label_ancho_C.place(x=10,y=20)
        
        entry_ancho_C = tk.Entry(labelframe_columna)
        entry_ancho_C.place(x=120,y=20,width=100)
        
        label_borde_C = tk.Label(labelframe_columna,text="Borde columna:")
        label_borde_C.place(x=10,y=50)
        
        entry_borde_C = tk.Entry(labelframe_columna)
        entry_borde_C.place(x=120,y=50,width=100)
        
        label_mensaje_C = tk.Label(labelframe_columna,text="El ancho mínimo de la columna fue determinado a partir del análisis de la longitud de desarrollo de anclaje realizado durante el diseño a flexión",
                                justify="left",
                                anchor="center",
                                wraplength=380)
        label_mensaje_C.place(x=10,y=80,width=380)
        
        check_longitud_refuerzo_var = tk.BooleanVar()
        check_longitud_refuerzo = tk.Checkbutton(tad_optimización, text="Longitudes de refuerzo cortante", variable=check_longitud_refuerzo_var,
                                        command=dibujar_longitud_triangulo_cortante)
        
        check_longitud_refuerzo.place(x=420,y=10)
        
        frame_longitud_refuerzo = tk.Frame(tad_optimización,bd=2,relief="ridge")
        frame_longitud_refuerzo.place(x=420,y=40,width=395,height=250)
        
        # Crear el Notebook
        Notebook_longitud = ttk.Notebook(frame_longitud_refuerzo,style="CustomNotebook.TNotebook")  # Crear el Notebook dentro del LabelFrame
        
        # Crear una pestaña dentro del Notebook
        tab_longitud = ttk.Frame(Notebook_longitud)  # Aquí es donde puedes colocar el contenido de la pestaña
        
        # Agregar la pestaña al Notebook 
        Notebook_longitud.add(tab_longitud, text="Longitud triángulo")
        
        # Empaquetar el Notebook en el LabelFrame
        Notebook_longitud.pack(fill="both", expand=True)
        
        # Crear un Canvas dentro de la pestaña 'tab_longitud'
        canvas_longitud = tk.Canvas(tab_longitud,bg="white")  
        canvas_longitud.pack(fill="both", expand=True)
        
        # Crear frame_estribos_longitudes
        
        frame_estribos_longitudes = tk.Frame(tad_optimización,bd=2,relief="ridge")
        frame_estribos_longitudes.place(x=420,y=290,width=395,height=200)
        
        # Crear el Notebook
        Notebook_estribos = ttk.Notebook(frame_estribos_longitudes,style="CustomNotebook.TNotebook")  
        
        # Crear una pestaña dentro del Notebook
        tab_estribos = ttk.Frame(Notebook_estribos)  
        
        # Agregar la pestaña al Notebook 
        Notebook_estribos.add(tab_estribos, text="Ubicación refuerzo transversal")
        
        # Empaquetar el Notebook en el LabelFrame
        Notebook_estribos.pack(fill="both", expand=True)
        
        # Crear un Canvas dentro de la pestaña 'tab_estribos'
        canvas_estribos = tk.Canvas(tab_estribos)  
        canvas_estribos.pack(fill="both", expand=True)
        
        # Crear el Scrollbar vertical
        scrollbar_estribos = tk.Scrollbar(tab_estribos, orient="vertical",command=canvas_estribos.yview)
        scrollbar_estribos.place(x=370, y=0, width=20, height=170)
        
        # Vincular el Scrollbar vertical al Canvas
        canvas_estribos.config(yscrollcommand=scrollbar_estribos.set)
        
        # Crear labelframe_estribos
        labelframe_estribos = tk.LabelFrame(tab_estribos)
        
        # Crear Slider
        slider_cortante = tk.Scale(labelframe_estribos, from_=0.00, orient="horizontal", resolution=0.00)
        slider_cortante.place(x=250,y=1)
        
        label_posicion = tk.Label(labelframe_estribos,text="Posición [L]:")
        label_posicion.place(x=10,y=10)
        
        entry_posicion = tk.Entry(labelframe_estribos)
        entry_posicion.place(x=90,y=10,width=80)
        
        # Crear el label para mostrar el valor del slider
        label_valor = tk.Label(labelframe_estribos, text="",bd=2,relief="ridge")
        label_valor.place(x=253,y=1,width=100)
        
        labelframe_l_refuerzo = tk.LabelFrame(tab_estribos,text="")
        
        # Función para redimensionar la imagen
        def redimensionar_imagen(ruta_imagen, tamano):
            imagen_agregar_eliminar = Image.open(ruta_imagen)  
            imagen_agregar_eliminar = imagen_agregar_eliminar.resize(tamano)  
            imagen_longitud_refuerzo = Image.open(ruta_imagen)  
            imagen_longitud_refuerzo = imagen_longitud_refuerzo.resize(tamano)  
            return ImageTk.PhotoImage(imagen_agregar_eliminar,imagen_longitud_refuerzo)  
        
        # Cargar las imágenes de los iconos redimensionadas
        imagen_agregar = redimensionar_imagen("Iconos_proyecto/agregar_marcador.png", (20, 20))
        imagen_eliminar = redimensionar_imagen("Iconos_proyecto/eliminar_marcador.png", (20, 20))
        imagen_refuerzo = redimensionar_imagen("Iconos_proyecto/mano_de_obra.png", (30, 30))
        
        boton_agregar_marcador = tk.Button(labelframe_estribos,image=imagen_agregar,bd=2,relief="flat")
        boton_agregar_marcador.place(x=180,y=10)
        
        boton_eliminar_marcador = tk.Button(labelframe_estribos,image=imagen_eliminar,bd=2,relief="flat")
        boton_eliminar_marcador.place(x=215,y=10)
        
        # Mantener una referencia de las imágenes
        boton_agregar_marcador.icono = imagen_agregar
        boton_eliminar_marcador.icono = imagen_eliminar
        
        frame_distribucion_estribo = tk.Frame(labelframe_l_refuerzo,bd=2,relief="sunken")
        frame_distribucion_estribo.place(x=10,y=10,width=330,height=80)
        
        check_primer_refuerzo_var = tk.BooleanVar()
        check_longitud_estribo = tk.Checkbutton(frame_distribucion_estribo, text="Disposición del primer estribo a 5 cm", variable=check_primer_refuerzo_var,
                                        command=actualizar_dato_primer_estribo)
        check_longitud_estribo.place(x=10,y=10)
        
        label_primer_estribo = tk.Label(frame_distribucion_estribo,text="",bd=2,relief="sunken")
        label_primer_estribo.place(x=240,y=10,width=80)
        
        boton_longitud_refuerzo = tk.Button(tad_optimización,image=imagen_refuerzo,bd=2,relief="flat",command=abrir_subventana_refuerzo)
        boton_longitud_refuerzo.place(x=780,y=4)
        
        # Mantener una referencia de las imágenes
        boton_longitud_refuerzo.icono = imagen_refuerzo
        
        # Crear el Scrollbar vertical
        scrollbar_nsr10 = tk.Scrollbar(tab_requisitos_NSR10, orient="vertical",command=canvas_nsr10.yview)
        scrollbar_nsr10.place(x=360, y=0, width=20, height=370)
        
        # Vincular el Scrollbar vertical al Canvas
        canvas_nsr10.config(yscrollcommand=scrollbar_nsr10.set)
        
        # Crear el Scrollbar vertical
        scrollbar_cortante = tk.Scrollbar(tab_generalidades, orient="vertical", command=canvas_cortante.yview)
        scrollbar_cortante.place(x=370, y=0, width=20, height=460)
        
        # Vincular el Scrollbar vertical al Canvas
        canvas_cortante.config(yscrollcommand=scrollbar_cortante.set)
        
        canvas_cortante.create_window((185,70), window=labelframe_V, width=345, height=100)
        canvas_cortante.create_window((185,190),window =frame_V, width=300, height=100)
        canvas_cortante.create_window((185,310),window =labelframe_V_info, width=345, height=100)
        canvas_cortante.create_window((185,430),window =labelframe_V_falla, width=345, height=100)
        canvas_cortante.create_window((185,555),window =frame_V_falla, width=250, height=120)
        canvas_cortante.create_window((185,760),window =labelframe_V_1, width=345, height=240)
        canvas_nsr10.create_window((180,40),window=labelframe_req_1, width=335, height=60)
        canvas_nsr10.create_window((180,1065),window=labelframe_req_2, width=335, height=1960)
        canvas_esquema.create_window((185,160), window=labelframe_grafica, width=350, height=300)
        canvas_esquema.create_window((185,350),window=labelframe_info_1, width=350, height=50)
        canvas_esquema.create_window((185,420),window=labelframe_Vu, width=350, height=70)
        canvas_esquema.create_window((185,555),window=labelframe_revision, width=350, height=180)
        canvas_esquema.create_window((110,660),window=check_revisar_widget)
        canvas_esquema.create_window((185,770),window=labelframe_condiciones, width=350, height=180)
        canvas_esquema.create_window((185,910),window=labelframe_resistencia_acero, width=350, height=80)
        canvas_esquema.create_window((185,1000),window=labelframe_verificacion, width=350, height=80)
        canvas_estribos.create_window((185,30),window=labelframe_estribos, width=360, height=50)
        canvas_estribos.create_window((185,150),window=labelframe_l_refuerzo, width=360, height=180)
        
        # Función para actualizar el área de desplazamiento del canvas
        def update_scrollregion(event=None):
            bbox = canvas_estribos.bbox("all")  # Obtener las coordenadas de todo el contenido
            if bbox:
        # Ajustar el área de desplazamiento añadiendo márgenes
                canvas_estribos.config(scrollregion=(0, 0, bbox[2] + 50, bbox[3] + 10))
        
        # Llamar a update_scrollregion para ajustar el área de desplazamiento
        canvas_estribos.bind("<Configure>", update_scrollregion)
        
        # Función para actualizar el área de desplazamiento del canvas
        def update_scrollregion(event=None):
            bbox = canvas_cortante.bbox("all")  # Obtener las coordenadas de todo el contenido
            if bbox:
        # Ajustar el área de desplazamiento añadiendo márgenes
                canvas_cortante.config(scrollregion=(0, 0, bbox[2] + 50, bbox[3] + 10))
        
        # Llamar a update_scrollregion para ajustar el área de desplazamiento
        canvas_cortante.bind("<Configure>", update_scrollregion)
        
        # Función para actualizar el área de desplazamiento del canvas
        def update_scrollregion(event=None):
            bbox = canvas_nsr10.bbox("all")  # Obtener las coordenadas de todo el contenido
            if bbox:
        # Ajustar el área de desplazamiento añadiendo márgenes
                canvas_nsr10.config(scrollregion=(0, 0, bbox[2] + 50, bbox[3] + 10))
        
        # Llamar a update_scrollregion para ajustar el área de desplazamiento
        canvas_nsr10.bind("<Configure>", update_scrollregion)
        
        # Función para actualizar el área de desplazamiento del canvas
        def update_scrollregion(event=None):
            bbox = canvas_esquema.bbox("all")  # Obtener las coordenadas de todo el contenido
            if bbox:
        # Ajustar el área de desplazamiento añadiendo márgenes
                canvas_esquema.config(scrollregion=(0, 0, bbox[2] + 50, bbox[3] + 10))
        
        # Llamar a update_scrollregion para ajustar el área de desplazamiento
        canvas_esquema.bind("<Configure>", update_scrollregion)
        
        # Marcar que la ventana ahora está abierta
        ventana_abierta = True
        
        # Cuando la ventana se cierre, ejecutar la función para marcar que está cerrada
        ventana_cortante.protocol("WM_DELETE_WINDOW", lambda: cerrar_ventana_v(ventana_cortante))


def cerrar_ventana_v(ventana_cortante):
    global ventana_abierta
    ventana_abierta = False
    ventana_cortante.destroy()

def actualizar_dato_primer_estribo():
    # Obtener el texto del Entry
    texto_entry = entry_borde_C.get()
    
    # Extraer solo los números del texto
    numeros = re.findall(r'\d+\.*\d*', texto_entry)
    valor_numerico_1 = float(numeros[0]) if numeros else 0.0  # Convertir a float

    # Calcular el nuevo valor
    Primer_estribo = valor_numerico_1 + 0.05

    # Actualizar el Label con el nuevo valor
    label_primer_estribo.config(text=f"{Primer_estribo}m")


def Crear_grafica_cortante():
    # Verificar si el gráfico ya existe y eliminarlo si es necesario
    if hasattr(Crear_grafica_cortante, 'canvas'):
        Crear_grafica_cortante.canvas.get_tk_widget().destroy()

    # Obtener los valores de las variables
    try:
        Wu_cortante = float(label_seccion_Wu.cget("text"))  # Carga distribuida (kN/m)
        L_cortante = float(label_seccion_luz.cget("text"))  # Longitud de la viga (m)
    except ValueError:
        print("Error: Los valores de Wu_cortante y L_cortante deben ser numéricos.")
        return
    
    # Actualizar el valor de Wu_cortante en el combo (agregarlo como nuevo ítem en la lista)
    nuevo_valor = f"{Wu_cortante:.2f} kN/m"
    
    # Verificar si el valor ya está en el combobox, si no, agregarlo
    if nuevo_valor not in combo_Vu_Wu['values']:
        combo_Vu_Wu['values'] = (*combo_Vu_Wu['values'], nuevo_valor)
    
    # Dejar "Seleccionar" como el valor visible para el usuario
    combo_Vu_Wu.set("Seleccionar")
    
    # Calcular reacciones en los apoyos
    Reaccion_cortante_apoyos = (Wu_cortante * L_cortante) / 2
    Ray_cortante = Reaccion_cortante_apoyos
    Rby_cortante = Ray_cortante  # Viga simétrica
    
    # Actualizar el label con el valor de la Reacción Cortante en los apoyos
    label_Vmax_prueba.config(text=f"{Reaccion_cortante_apoyos:.2f} kN")
    
    # Crear figura de matplotlib
    fig = plt.Figure(figsize=(10, 10), dpi=70)
    ax = fig.add_subplot(111)

    # Calcular puntos clave del diagrama
    x = [0, L_cortante / 2, L_cortante]
    y = [Ray_cortante, 0, -Rby_cortante]  # Valores de la fuerza cortante en los puntos clave

    # Graficar la fuerza cortante
    ax.plot(x, y, label='Fuerza Cortante', color='blue', linewidth=2)

    # Sombrear el área positiva
    x_positiva = [0, L_cortante / 2]
    y_positiva = [Ray_cortante, 0]
    ax.fill_between(x_positiva, y_positiva, 0, color='Darkblue', alpha=1)

    # Sombrear el área negativa
    x_negativa = [L_cortante / 2, L_cortante]
    y_negativa = [0, -Rby_cortante]
    ax.fill_between(x_negativa, y_negativa, 0, color='red', alpha=1)
    
    # Agregar marcadores en Ray_cortante y Rby_cortante
    ax.scatter(0, Ray_cortante, color='green', label=f'Vmax: {Ray_cortante:.2f} kN', s=50, zorder=5)
    ax.scatter(L_cortante, -Rby_cortante, color='green', s=50, zorder=5)

    # Agregar leyenda para L_cortante (línea sin marcador)
    ax.plot([], [], color='black', label=f'Luz: {L_cortante:.2f} m', linewidth=2)

    # Configurar ejes y leyendas
    ax.axhline(0, color='black', linewidth=1)  # Línea horizontal en y=0
    ax.set_xlim(0, L_cortante)
    ax.set_ylim(min(y) - 10, max(y) + 10)
    
    # Personalizar texto de los ejes en negrita
    ax.set_xlabel("Longitud de la viga (m)", fontweight="bold")
    ax.set_ylabel("Fuerza Cortante (kN)", fontweight="bold")
    ax.yaxis.set_label_position("right")
    
    # Configurar la leyenda con borde negro
    legend = ax.legend(frameon=True)
    legend.get_frame().set_edgecolor("black")  # Establecer borde negro
    legend.get_frame().set_linewidth(1.5)  # Grosor del borde

    ax.grid(True)
    
    # Dibujar la gráfica en la interfaz
    canvas = FigureCanvasTkAgg(fig, master=labelframe_grafica)
    canvas.draw()
    canvas.get_tk_widget().pack(fill=tk.BOTH, expand=True)
    
    # Guardar la imagen con alta resolución en la ruta especificada
    ruta_imagen = os.path.join("Reportes", "imagenes_pilot", "grafica_cortante.png")
    if not os.path.exists(os.path.dirname(ruta_imagen)):
        os.makedirs(os.path.dirname(ruta_imagen))  

    fig.savefig(ruta_imagen, dpi=300)  
    
    # Guardar referencia al canvas
    Crear_grafica_cortante.canvas = canvas

# Función que se ejecutará cuando se active o desactive el Checkbutton
def Estribo_diseño():
    # Recuperar el valor que tiene la label_prueba_estribo 
    valor = label_prueba_estribo.cget("text")
    
    if valor == "9.5 mm":
        entry_info_estribo.delete(0, tk.END)  # Limpiar cualquier texto anterior
        entry_info_estribo.insert(0, "E#3")   # Actualizar con "E#3"
        entry_info_area.delete(0, tk.END)     # Limpiar cualquier valor anterior
        entry_info_area.insert(0, "71 mm²")  # Actualizar área con "71 mm²"
        
    elif valor == "12.7 mm":
        entry_info_estribo.delete(0, tk.END)  # Limpiar cualquier texto anterior
        entry_info_estribo.insert(0, "E#4")   # Actualizar con "E#4"
        entry_info_area.delete(0, tk.END)     # Limpiar cualquier valor anterior
        entry_info_area.insert(0, "129 mm²") # Actualizar área con "129 mm²"
        

def Calcular_Cortante_Vu(event=None):
    # Obtener los valores de los labels y el combobox
    try:
        # Obtener el valor de Vmax_V (solo el número sin "kN")
        Vmax_V = float(label_Vmax_prueba.cget("text").split()[0])  
        
        # Obtener el valor de Wu_V (solo el número sin "kN/m")
        Wu_V = float(combo_Vu_Wu.get().split()[0])  
        
        # Obtener el valor de d_V desde el label
        d_V = float(label_profundidad_prueba.cget("text").split()[0])  
        
        # Obtener el valor de base_Vu_V desde el label (label_b_prueba)
        base_Vu_V = float(label_b_prueba.cget("text").split()[0])  # Se espera que el texto sea un número
        
        # Verificar el valor de base_Vu_V
        
        
    except ValueError:
        print("Error: Los valores deben ser numéricos.")
        return
    
    # Calcular Vu_V con la nueva ecuación Vu_V = Vmax_V - Wu_V * (1/2 * base_Vu_V + d_V)
    Vu_V = Vmax_V - Wu_V * (0.5 * base_Vu_V + d_V)
    
    # Verificar el valor de Vu_V
    
    
    # Mostrar el resultado en el Entry
    entry_Vu_ultimo.delete(0, tk.END)  
    entry_Vu_ultimo.insert(0, f"{Vu_V:.2f} kN")  
    
    # Actualizar el valor en el Label
    label_Vu.config(text=f"{Vu_V:.2f} kN")

def Calcular_Resistencia_ɸVc(event=None):
    try:
        # Obtener el valor de ɸ_resistencia desde el combo
        ɸ_resistencia = combo_ɸ_revision.get()
        if ɸ_resistencia == "Seleccionar":
            raise ValueError("Por favor, seleccione un valor para ɸ_resistencia.")
        ɸ_resistencia = float(ɸ_resistencia)  
        
        # Obtener el valor de λ_resistencia desde el combo
        λ_resistencia = combo_factor_λ.get()
        if λ_resistencia == "Seleccionar":
            raise ValueError("Por favor, seleccione un valor para λ_resistencia.")
        λ_resistencia = float(λ_resistencia)  
        
        # Obtener el valor de f'c_resistencia desde el combo
        fc_text = combo_fc_revision.get()
        if fc_text == "Seleccionar":
            raise ValueError("Por favor, seleccione un valor para f'c_resistencia.")
        
        
        match = re.match(r"([0-9.]+)\s*(Mpa|MPa)", fc_text)
        if match:
            f_c_resistencia = float(match.group(1))  
        else:
            raise ValueError("f'c_resistencia no tiene el formato esperado. Asegúrese de seleccionar un valor con 'Mpa' o 'MPA'.")

        # Obtener los valores de los labels (b_resistencia y d_resistencia)
        b_resistencia = label_b_prueba.cget("text").strip()
        if not b_resistencia.replace('.', '', 1).isdigit():  
            raise ValueError("El valor de b_resistencia no es válido.")
        b_resistencia = float(b_resistencia)  
        
        d_resistencia = label_profundidad_prueba.cget("text").strip()
        if not d_resistencia.replace('.', '', 1).isdigit(): 
            raise ValueError("El valor de d_resistencia no es válido.")
        d_resistencia = float(d_resistencia) 

    except ValueError as e:
        print(f"Error: {e}")
        return
    
    # Calcular la resistencia al cortante ɸVc
    ɸVc_resistencia = ɸ_resistencia * 0.17 * λ_resistencia * math.sqrt(f_c_resistencia) * b_resistencia * d_resistencia * 1000
    
    # Mostrar el resultado en el Entry
    entry_ɸVc_revision.delete(0, tk.END)  
    entry_ɸVc_revision.insert(0, f"{ɸVc_resistencia:.2f} kN")  
    
    # Actualizar el label_ɸVc con el valor calculado
    label_ɸVc.config(text=f"{ɸVc_resistencia:.2f} kN")  # Actualiza el label
    
    # Calcular la mitad de la resistencia al cortante ɸVc/2
    ɸVc_media_resistencia = ɸVc_resistencia / 2
    
    # Mostrar el resultado en el Entry de la mitad
    entry_ɸVcmedios_revision.delete(0, tk.END)  
    entry_ɸVcmedios_revision.insert(0, f"{ɸVc_media_resistencia:.2f} kN")  
    
    # Actualizar el label_ɸVc_2 con la mitad de la resistencia calculada
    label_ɸVc_2.config(text=f"{ɸVc_media_resistencia:.2f} kN")  # Actualiza el label
    
    # Obtener el valor de Vu_estribo desde entry_Vu_ultimo 
    Vu_estribo_text = entry_Vu_ultimo.get().strip()
    if Vu_estribo_text.endswith("kN"):
        Vu_estribo_value = float(Vu_estribo_text.replace("kN", "").strip())  
    else:
        raise ValueError("El valor de Vu_estribo no tiene el formato esperado.")

    # Calcular la resistencia de los estribos (Vs_estribo)
    Vs_estribo = (Vu_estribo_value - ɸVc_resistencia) / 0.75
    
    # Mostrar el resultado en el Entry de resistencia de los estribos
    entry_resistencia_Vs.delete(0, tk.END)  
    entry_resistencia_Vs.insert(0, f"{Vs_estribo:.2f} kN")  
    
    # Actualizar el label_copia_Vs con el resultado de Vs_estribo
    label_copia_Vs.config(text=f"{Vs_estribo:.2f} kN")  
    
    # Actualizar el label Vs_resistencia con el resultado de Vs_estribo
    Vs_resistencia.config(text=f"{Vs_estribo:.2f} kN")  
    
    # Calcular el 66% de la sección
    seccion_66 = 0.66 * math.sqrt(f_c_resistencia) * b_resistencia * d_resistencia * 1000
    
    # Mostrar el resultado en el label_copia_seccion
    label_copia_seccion.config(text=f"{seccion_66:.2f} kN")  
    
    # Comparar Vs_estribo con el 66% de la sección y actualizar el label_cumple_Vs
    if Vs_estribo < seccion_66:
        label_cumple_Vs.config(text="Si Cumple")  
        # Actualizar el label_conclusion_V con el texto de "Cumple"
        label_conclusion_V.config(text="Con esto, se concluye que el 66% de la resistencia de la sección de concreto cumple con la condición de que la sección transversal diseñada es adecuada.")
        # Actualizar label_check_control
        label_check_control.config(text="Cumple: Se concluye que el 66% de la resistencia de la sección de concreto cumple con la condición de que la sección transversal diseñada es adecuada.")
        label_icon_cortante_1.config(image=icon_check_on)
    else:
        label_cumple_Vs.config(text="No Cumple")  
        # Actualizar el label_conclusion_V con el texto de "No Cumple"
        label_conclusion_V.config(text="En este caso, se concluye que el 66% de la resistencia de la sección de concreto no cumple con el requisito de que la sección transversal diseñada sea adecuada.")
        # Actualizar label_check_control
        label_check_control.config(text="No cumple: Se concluye que el 66% de la resistencia de la sección de concreto no cumple con el requisito de que la sección transversal diseñada sea adecuada.")  
        label_icon_cortante_1.config(image=icon_check_on)

def Revisar_condiciones_diseño():
    try:
        # Obtener los valores de los Entry, ignorando el texto "kN"
        Vu_ultimo_text = entry_Vu_ultimo.get()
        ɸVc_revision_text = entry_ɸVc_revision.get()
        ɸVcmedios_revision_text = entry_ɸVcmedios_revision.get()

        # Usamos expresiones regulares para extraer solo los valores numéricos antes de "kN"
        Vu_ultimo = float(re.match(r"([0-9.]+)", Vu_ultimo_text).group(1))
        ɸVc_revision = float(re.match(r"([0-9.]+)", ɸVc_revision_text).group(1))
        ɸVcmedios_revision = float(re.match(r"([0-9.]+)", ɸVcmedios_revision_text).group(1))

    except ValueError:
        print("Error: Asegúrese de que todos los campos tengan valores numéricos válidos.")
        return
    except AttributeError:
        print("Error: No se pudo extraer el valor numérico de uno de los campos.")
        return
    
    # Verificar las condiciones y realizar las comparaciones
    if Vu_ultimo > ɸVc_revision:
        # Condición 1: Vu > ɸVc
        check_condición_1.set(1)  # Marcar el primer checkbutton
        check_condición_2.set(0)  # Desmarcar el segundo
        check_condición_3.set(0)  # Desmarcar el tercero
        
        # Bloquear los demás checkbuttons
        checkbutton_1_V.config(state=tk.DISABLED)
        checkbutton_2_V.config(state=tk.DISABLED)
        checkbutton_3_V.config(state=tk.DISABLED)
        
        # Actualizar mensaje
        label_mensaje_condicion.config(text="Condición 1: Vu > ɸVc [Diseñar refuerzo transversal]")
        label_check_Vs.config(text="Condición de diseño Vu > ɸVc: Se debe diseñar refuerzo transversal")
        # Actualizar ícono
        label_icon_cortante.config(image=icon_check_on)  # Cambiar la imagen del ícono
        
        
    elif ɸVcmedios_revision < Vu_ultimo < ɸVc_revision:
        # Condición 2: ɸVc/2 < Vu < ɸVc
        check_condición_1.set(0)  # Desmarcar el primer checkbutton
        check_condición_2.set(1)  # Marcar el segundo
        check_condición_3.set(0)  # Desmarcar el tercero
        
        # Bloquear los demás checkbuttons
        checkbutton_1_V.config(state=tk.DISABLED)
        checkbutton_2_V.config(state=tk.DISABLED)
        checkbutton_3_V.config(state=tk.DISABLED)
        
        # Actualizar mensaje
        label_mensaje_condicion.config(text="Condición 2: ɸVc/2 < Vu < ɸVc [Colocar Área mínima]")
        label_check_Vs.config(text="Condición de diseño ɸVc/2 < Vu < ɸVc: Colocar área mínima de refuerzo")
        # Actualizar ícono
        label_icon_cortante.config(image=icon_check_on)  # Cambiar la imagen del ícono
        
        
    elif Vu_ultimo < ɸVcmedios_revision:
        # Condición 3: Vu < ɸVc/2
        check_condición_1.set(0)  # Desmarcar el primer checkbutton
        check_condición_2.set(0)  # Desmarcar el segundo
        check_condición_3.set(1)  # Marcar el tercero
        
        # Bloquear los demás checkbuttons
        checkbutton_1_V.config(state=tk.DISABLED)
        checkbutton_2_V.config(state=tk.DISABLED)
        checkbutton_3_V.config(state=tk.DISABLED)
        
        # Actualizar mensaje
        label_mensaje_condicion.config(text="Condición 3: Vu < ɸVc/2 [No necesita refuerzo transversal]")
        label_check_Vs.config(text="Condición de diseño Vu < ɸVc/2: No necesita refuerzo transversal")
        # Actualizar ícono
        label_icon_cortante.config(image=icon_check_on)  # Cambiar la imagen del ícono
        
        
    # Habilitar el checkbutton para revisar cuando se selecciona la opción
    check_revisar_widget.config(state=tk.NORMAL)

def actualizar_label_Smax(*args):
    """Actualiza el label Smax_estribos cuando se modifica el valor en entry_Smax."""
    try:
        # Obtener el valor del entry_Smax
        smax_text = entry_Smax.get().strip()
        # Asegurarse de que el valor es un número válido
        smax_value = float(re.sub(r'[^\d.]', '', smax_text))  # Extraer solo el número
        Smax_estribos.config(text=f"{round(smax_value)} cm")  # Actualizar el label con el valor redondeado
    except ValueError:
        # Si no es un número válido, no actualizar el label
        Smax_estribos.config(text="Error: Valor inválido")


def Calcular_Smax():
    try:
        # Obtener valores de entradas y combobox
        fc_revision = combo_fc_revision.get()
        texto_resistencia_Vs = entry_resistencia_Vs.get()
        resistencia_Vs = float(re.sub(r'[^\d.]', '', texto_resistencia_Vs))  # Extraer número
        
        profundidad_prueba = float(label_profundidad_prueba.cget("text"))
        b_prueba = float(label_b_prueba.cget("text"))
        fc_revision_val = float(fc_revision.split(" ")[0])  # Obtener valor numérico de fc_revision

        # Calcular 33% de la sección
        Seccion = 0.33 * math.sqrt(fc_revision_val) * b_prueba * profundidad_prueba * 1000
        
        # Determinar Smax
        Vs_Nsr10 = resistencia_Vs
        if Vs_Nsr10 < Seccion:
            S_max = profundidad_prueba * 100 / 2
        else:
            S_max = profundidad_prueba * 100 / 4
        
        # Redondear S_max al número entero más cercano
        S_max_redondeado = round(S_max)  # Redondear al entero más cercano
        
        # Actualizar campo de entrada y label
        entry_Smax.delete(0, tk.END)
        entry_Smax.insert(0, f"{S_max_redondeado} cm")
        
        # Actualizar el label Smax_estribos con el valor calculado
        Smax_estribos.config(text=f"{S_max_redondeado} cm")  # Actualiza el label
        
    except ValueError:
        # Manejar errores en entradas
        entry_Smax.delete(0, tk.END)
        entry_Smax.insert(0, "Error: Entradas inválidas")

def Calcular_Av():
    try:
        # Obtener los valores de los widgets
        texto_Smax = entry_Smax.get()  # Tomar el texto del Entry
        Smax = float(re.sub(r'[^\d.]', '', texto_Smax))  # Extraer solo el valor numérico

        b_prueba_texto = label_b_prueba.cget("text")  # Obtener el texto del Label
        b_prueba = float(b_prueba_texto)  # Convertirlo a un valor numérico

        fc_revision_texto = combo_fc_revision.get()  # Obtener el texto del ComboBox
        fc_revision = float(fc_revision_texto.split()[0])  # Extraer el valor numérico de fc_revision

        # Definir el valor de fy_Av
        fy_Av = 420

        # Calcular Sv y b_Av
        Sv = Smax * 10
        b_Av = b_prueba * 1000

        # Calcular Av_1 y Av_2
        Av_1 = (0.062 * Sv * b_Av * math.sqrt(fc_revision)) / fy_Av
        Av_2 = (0.35 * Sv * b_Av) / fy_Av

        # Seleccionar el valor mayor entre Av_1 y Av_2
        resultado = max(Av_1, Av_2)

        # Mostrar el resultado en el Entry correspondiente con el formato solicitado
        entry_Av.delete(0, tk.END)
        entry_Av.insert(0, f"{resultado:.2f} mm²")
        # Actualizar el label con el mismo resultado
        label_Av_requerida.config(text=f"{resultado:.2f} mm²")  # Actualizamos el label con el resultado


    except ValueError:
        # Manejar el error si alguna de las entradas es incorrecta
        entry_Av.delete(0, tk.END)
        entry_Av.insert(0, "Error: Entradas inválidas")
        label_Av_requerida.config(text="Error: Entradas inválidas")  # Mostrar error en el label si hay un problema

def Calcular_numero_ramas():
    try:
        # Obtener los valores de los Entry
        valor_Av = entry_Av.get()  # Obtener el texto completo
        valor_info_area = entry_info_area.get()  # Obtener el texto completo

        # Usar expresiones regulares para extraer solo los números
        Num_Av = float(re.search(r"[-+]?\d*\.\d+|\d+", valor_Av).group())  # Extraer el primer número
        Num_ramas = float(re.search(r"[-+]?\d*\.\d+|\d+", valor_info_area).group())  # Extraer el primer número

        # Realizar el cálculo
        if Num_ramas != 0:  # Para evitar división por cero
            resultado = Num_Av / Num_ramas
        else:
            resultado = 0  # Si Num_ramas es 0, el resultado será 0

        # Mostrar el resultado en el Entry correspondiente
        entry_ramas.delete(0, tk.END)  # Borrar cualquier valor previo
        entry_ramas.insert(0, str(resultado))  # Insertar el nuevo resultado
        
        # Lógica para aproximar el número de ramas:
        # Si el resultado es menor que 2, se asigna 2 ramas. 
        # Si es mayor o igual a 2, se usa el redondeo hacia arriba como antes.
        if resultado < 2:
            aproximar_ramas = 2
        else:
            aproximar_ramas = math.ceil(resultado)
        
        # Actualizar el texto del label_ramas_V con el mensaje de resultados
        label_ramas_V.config(text=f"El número de ramas para el estribo calculado es {resultado:.3f}, "
                                f"por lo tanto, se requiere un diseño con {aproximar_ramas} ramas.")
        
        # Actualizar el texto del label_num_ramas con el valor de aproximar_ramas
        label_num_ramas.config(text=f"{aproximar_ramas}")
        
        # Actualizar también el label_check_ramas con el mismo mensaje que label_ramas_V
        Label_check_ramas.config(text=f"El número de ramas para el estribo calculado es {resultado:.3f}, "
                                    f"por lo tanto, se requiere un diseño con {aproximar_ramas} ramas.")
        
    except (ValueError, AttributeError):
        # Si no se encuentra un número o el formato es incorrecto
        entry_ramas.delete(0, tk.END)
        entry_ramas.insert(0, "Error: Input inválido")
        label_ramas_V.config(text="Error: Input inválido")  
        label_num_ramas.config(text="Error: Input inválido")


# Función para calcular la resistencia de los estribos
def Calcular_Vs_resistencia_estribos():
    try:
        # Obtener el valor de entry_info_area (solo números)
        valor_info_area = entry_info_area.get()  # Obtener el texto completo
        Av_r_estribo = float(re.search(r"[-+]?\d*\.\d+|\d+", valor_info_area).group())  # Extraer el primer número

        # Obtener el valor de label_profundidad_prueba
        d_r_estribo = float(label_profundidad_prueba.cget("text"))  # Obtener el texto y convertirlo a número

        # Obtener el valor de entry_Smax (solo números)
        valor_Smax = entry_Smax.get()  # Obtener el texto completo
        S_r_estribo = float(re.search(r"[-+]?\d*\.\d+|\d+", valor_Smax).group())  # Extraer el primer número

        # Obtener el valor de label_num_ramas (este es num_r_estribo)
        # Aquí vamos a asegurarnos de que extraemos solo el número del texto
        num_r_estribo_text = label_num_ramas.cget("text")
        num_r_estribo = float(re.search(r"[-+]?\d*\.\d+|\d+", num_r_estribo_text).group())  # Extraer el número

        # Definir Fy_r_estribo (valor constante)
        Fy_r_estribo = 420  # Valor constante dado en el enunciado
        
        # Obtener el valor de entry_info_estribo (solo números)
        valor_info_estribo = entry_info_estribo.get()  # Obtener el texto completo
        Av_info_estribo = float(re.search(r"[-+]?\d*\.\d+|\d+", valor_info_estribo).group())  

        # Aplicar la fórmula para calcular Vs_resistencia_estribos
        Vs_resistencia_estribos = (Fy_r_estribo * num_r_estribo * Av_r_estribo * d_r_estribo) / S_r_estribo
        
        # Multiplicar el resultado por 0.1
        Vs_resistencia_estribos = Vs_resistencia_estribos * 0.1
        
        # Mostrar el resultado en el entry_Vs_estribos
        entry_Vs_estribos.delete(0, tk.END)  # Borrar cualquier valor previo
        entry_Vs_estribos.insert(0, f"{Vs_resistencia_estribos:.3f} kN")  # Insertar el resultado con 2 decimales
        
        # Actualizar el label_Vs_estribos con el mensaje requerido
        label_Vs_estribos_1.config(
            text=f"El valor calculado de la resistencia de los estribos {valor_info_estribo} es de {Vs_resistencia_estribos:.3f} kN colocados cada {S_r_estribo} cm"
        )
        # Actualizar el label_Vs_resistencia_req con el valor calculado de Vs_resistencia_estribos
        Vs_resistencia_req.config(
            text=f"{Vs_resistencia_estribos:.3f} kN"
        
        )
        
        # Actualizar el label_cortante_check_separacion con el mismo mensaje de label_Vs_estribos_1
        Label_check_separacion.config(
            text=f"El valor calculado de la resistencia de los estribos {valor_info_estribo} es de {Vs_resistencia_estribos:.3f} kN colocados cada {S_r_estribo} cm"
        )
        
    except (ValueError, AttributeError):
        # Si no se encuentra un número o el formato es incorrecto
        entry_Vs_estribos.delete(0, tk.END)
        entry_Vs_estribos.insert(0, "Error: Input inválido")
        label_Vs_estribos_1.config(text="Error: Input inválido")

# Función para calcular la resistencia requerida Vs
def Calcular_resistencia_Vs_requerida():
    try:
        # Obtener el valor de entry_Vs_estribos (solo números)
        valor_Vs_estribos = entry_Vs_estribos.get()  # Obtener el texto completo
        Vs_estribos = float(re.search(r"[-+]?\d*\.\d+|\d+", valor_Vs_estribos).group())  # Extraer el primer número

        # Mostrar el valor de Vs_estribos en entry_resistencia_Vs_requerida
        entry_resistencia_Vs_requerida.delete(0, tk.END)  # Borrar cualquier valor previo
        entry_resistencia_Vs_requerida.insert(0, f"{Vs_estribos:.3f} kN")  # Insertar el valor con 3 decimales y unidad

    except (ValueError, AttributeError):
        # Si no se encuentra un número o el formato es incorrecto
        entry_resistencia_Vs_requerida.delete(0, tk.END)
        entry_resistencia_Vs_requerida.insert(0, "Error: Input inválido")

def Calcular_resistencia_total_Vn():
    try:
        # Obtener el valor de entry_resistencia_Vs_requerida
        valor_Vs_requerida = entry_resistencia_Vs_requerida.get()  
        # Usar expresión regular para extraer solo el número
        Vs_Vn = float(re.search(r"[-+]?\d*\.\d+|\d+", valor_Vs_requerida).group())  

        # Obtener el valor de entry_ɸVc_revision
        valor_ɸVc_revision = entry_ɸVc_revision.get()  
        # Extraer solo el número
        Vc_Vn = float(re.search(r"[-+]?\d*\.\d+|\d+", valor_ɸVc_revision).group())  

        # Obtener directamente el valor de entry_Vu_ultimo y extraer solo el número
        valor_Vu_ultimo = entry_Vu_ultimo.get()
        # Usar expresión regular para extraer solo el número
        Vu_ultimo = float(re.search(r"[-+]?\d*\.\d+|\d+", valor_Vu_ultimo).group())  
        
        # Obtener el valor de entry_Smax
        valor_Smax_req = entry_Smax.get()
        Smax_req = float(re.search(r"[-+]?\d*\.\d+|\d+", valor_Smax_req).group())  
        
        # Calcular la resistencia total
        Resistencia_total_Vn = (0.75 * Vs_Vn) + Vc_Vn
        
        # Comparar Vu_ultimo con Resistencia_total_Vn
        if Vu_ultimo <= Resistencia_total_Vn:
            cumple_condicion = "Si cumple"
        else:
            cumple_condicion = "No cumple"
        
        # Buscar si ya existe una fila con el mismo Vu_ultimo
        for item in treeview_cortante.get_children():
            # Comparar Vu_ultimo con el valor de la segunda columna (que es el Vu_ultimo)
            if float(treeview_cortante.item(item)["values"][1].replace(" kN", "")) == Vu_ultimo:  
                # Si encuentra la fila, actualizar los valores de toda la fila
                treeview_cortante.item(item, values=(
                    f"{Vs_Vn:.3f} kN", 
                    f"{Vu_ultimo:.3f} kN", 
                    f"{Resistencia_total_Vn:.3f} kN", 
                    cumple_condicion))
                break  # Termina el ciclo una vez que haya actualizado la fila
        else:
            # Si no encuentra ninguna fila con el Vu_ultimo, insertar una nueva fila
            treeview_cortante.insert("", "end", values=(
                f"{Vs_Vn:.3f} kN", 
                f"{Vu_ultimo:.3f} kN", 
                f"{Resistencia_total_Vn:.3f} kN", 
                cumple_condicion))

        # Actualizar el label_resistencia_total 
        label_resistencia_total.config(
            text=f"El valor calculado de ɸVn es de {Resistencia_total_Vn:.3f} kN, lo que representa la capacidad de la sección de concreto cuando se colocan estribos cada {Smax_req:.2f} cm."
        )
        
        # Actualizar el label_ɸVn con el valor de Resistencia_total_Vn
        label_ɸVn.config(text=f"{Resistencia_total_Vn:.3f} kN")

        # Actualizar el label_Vu_ɸVn con el resultado de cumple_condicion
        label_Vu_ɸVn.config(text=f"{cumple_condicion}")
        
         # **Actualizar el label_check_Vu_ɸVn con el mensaje completo**
        label_check_Vu_ɸVn.config(
            text=f"El valor calculado de ɸVn es de {Resistencia_total_Vn:.3f} kN, lo que representa la capacidad de la sección de concreto cuando se colocan estribos cada {Smax_req:.2f} cm."
        )
        
    except (ValueError, AttributeError) as e:
        print(f"Error: {e}")  # Solo para depuración si es necesario
        print("Error: Input inválido")


def Insertar_datos_cortante_diseño():
    # Obtener los valores de los labels
    Vmax = label_Vmax_prueba.cget("text").strip()  # Vmax de label_Vmax_prueba
    Vu = label_Vu.cget("text").strip()  # Vu de label_Vu
    ɸVc = label_ɸVc.cget("text").strip()  # ɸVc de label_ɸVc
    ɸVc_2 = label_ɸVc_2.cget("text").strip()  # ɸVc/2 de label_ɸVc_2
    ancho_columna = label_ancho_columna.cget("text").strip()  # Ancho de columna de label_ancho_columna

    # Verificar si los valores no están vacíos
    if not Vmax or not Vu or not ɸVc or not ɸVc_2 or not ancho_columna:
        print("Error: Algunos de los valores están vacíos.")
        return

    # Comprobar si ya hay una fila existente y actualizarla
    if treeview_cortante_valores.get_children():
        # Tomamos la primera fila (podrías elegir otra fila si es necesario)
        item_id = treeview_cortante_valores.get_children()[0]  # Primer ítem (fila)
        treeview_cortante_valores.item(item_id, values=(Vmax, Vu, ɸVc, ɸVc_2))  # Actualizamos la fila existente
    else:
        # Si no hay filas, insertamos la primera fila
        treeview_cortante_valores.insert("", tk.END, values=(Vmax, Vu, ɸVc, ɸVc_2))

    # Convertir el valor de ancho de columna de cm a metros
    try:
        ancho_columna_float = float(ancho_columna.replace("cm", "").strip())  # Eliminar "cm" y convertir a float
        ancho_columna_metros = ancho_columna_float / 100  # Convertir de cm a metros
    except ValueError:
        print("Error: El valor de ancho de columna no es numérico.")
        return
    
    # Mostrar el valor convertido en el Entry de ancho de columna en metros
    entry_ancho_C.delete(0, tk.END)  # Limpiar el Entry antes de insertar el nuevo valor
    entry_ancho_C.insert(0, f"{ancho_columna_metros:.2f} m")  # Insertar el valor en metros

    # Calcular la mitad del ancho de la columna en metros
    mitad_ancho = ancho_columna_metros / 2  # Calcular la mitad
    
    # Actualizar el Entry con la mitad del ancho de la columna
    entry_borde_C.delete(0, tk.END)  # Limpiar el Entry antes de insertar el nuevo valor
    entry_borde_C.insert(0, f"{mitad_ancho:.2f} m")  # Insertar el valor de la mitad en metros


def dibujar_longitud_triangulo_cortante():
    # Obtener los valores de las variables
    
    try:
        Wu_cortante_C = float(label_seccion_Wu.cget("text"))  
        L_cortante_C = float(label_seccion_luz.cget("text"))  
        label_profundidad_prueba_valor = float(label_profundidad_prueba.cget("text"))  
    except ValueError:
        print("Error: Los valores de Wu_cortante_C, L_cortante_C y label_profundidad_prueba deben ser numéricos.")
        return

    # Calcular las reacciones en los apoyos
    Reaccion_cortante_apoyos_C = (Wu_cortante_C * L_cortante_C) / 2
    Ray_cortante_C = Reaccion_cortante_apoyos_C  
    Rby_cortante_C = Ray_cortante_C  

    # Asignar Vmax y base_l de acuerdo con la nueva lógica
    Vmax = Ray_cortante_C  
    base_l = L_cortante_C / 2  
    
    
    # Actualizar el valor en el Entry
    entry_base_triangulo.delete(0, tk.END)  # Borrar el valor anterior
    entry_base_triangulo.insert(0, str(base_l))  # Insertar el nuevo valor
    
    # Crear una figura y un eje para graficar el triángulo
    fig, ax = plt.subplots()

    # Desplazar el triángulo más a la derecha ajustando las coordenadas
    desplazamiento = 2  

    # Factor de escala para hacer el triángulo más grande
    factor_escala = 1.8  

    # Definir las coordenadas del triángulo (x, y) 
    x = [base_l * factor_escala + desplazamiento, 0 + desplazamiento, 0 + desplazamiento]
    y = [0, 0, Vmax * factor_escala]  

    # Dibujar el triángulo conectando los puntos
    ax.fill(x, y, color=(0.5, 0.5, 0.5, 0.3))  
    ax.plot(x + [x[0]], y + [y[0]], color='black')  

    # Configurar los límites del gráfico para mostrar solo el triángulo positivo
    ax.set_xlim(-1, base_l * factor_escala + desplazamiento + 1)  
    ax.set_ylim(-1, Vmax * factor_escala * 1.05 + 1)  
    
    # Habilitar los grids
    ax.grid(True)
    
    # Remover los títulos de los ejes y las marcas (ticks)
    ax.set_xticks([])  
    ax.set_yticks([])  
    ax.set_xlabel('')  
    ax.set_ylabel('')  
    
    # Remover el borde de los ejes (esto elimina el borde negro alrededor de la gráfica)
    ax.spines['top'].set_visible(False)   
    ax.spines['right'].set_visible(False) 
    ax.spines['bottom'].set_visible(False) 
    ax.spines['left'].set_visible(False)  

    # Agregar marcador rojo en la altura (Vmax) del triángulo
    marcador_rojo=ax.plot(0 + desplazamiento, Vmax * factor_escala, 'ro',markersize=4)  

    # Añadir la etiqueta con el valor de Vmax al lado izquierdo del marcador
    ax.text(0 + desplazamiento + 0.2, Vmax * factor_escala, f"Vmax", color='r', fontsize=8, verticalalignment='center')
    
    # --- NUEVO CÁLCULO PARA LA CORTANTE EN x --- 
    try:
        # Obtener el valor de x desde el Entry (ignorar texto y tomar el valor numérico)
        valor_entry = entry_borde_C.get()  
        
        # Extraer solo el valor numérico usando expresiones regulares
        x_cortante_match = re.findall(r"[-+]?\d*\.\d+|\d+", valor_entry)  

        if x_cortante_match:
            x_cortante = float(x_cortante_match[0])  
        else:
            print("Error: No se encontró un valor numérico válido en el Entry.")
            return

        # Validar que x_cortante esté dentro del rango válido
        if x_cortante < 0 or x_cortante > base_l:
            print("Error: El valor de x debe estar entre 0 y la base de la viga.")
            return

        # Calcular el valor de la cortante en x usando la fórmula del triángulo
        cortante_en_x = Vmax * (1 - (x_cortante / base_l))  

        # Añadir marcador en el gráfico para el valor de cortante en x
        marcador_rojo_cortante= ax.plot(x_cortante * factor_escala + desplazamiento, cortante_en_x * factor_escala, 'ro',markersize=4)  
        ax.text(x_cortante * factor_escala + desplazamiento +0.2, cortante_en_x * factor_escala, 
                f"V(borde)", color='r', fontsize=8)

        # --- Agregar la línea discontinua roja en Vmax (marcador) --- 
        ax.plot([0 + desplazamiento, 0 + desplazamiento], [0, Vmax * factor_escala], 'r--')  

        # --- Agregar la línea discontinua roja en cortante en x (marcador) --- 
        ax.plot([x_cortante * factor_escala + desplazamiento, x_cortante * factor_escala + desplazamiento], 
                [0, cortante_en_x * factor_escala], 'r--')  

        # --- Agregar la línea discontinua horizontal roja en cortante en x --- 
        ax.plot([0 + desplazamiento, x_cortante * factor_escala + desplazamiento], 
                [cortante_en_x * factor_escala, cortante_en_x * factor_escala], 'r--')  

        # --- Cálculo para Vu_base y posición de Vu ---
        # Obtener el valor de entry_Vu_ultimo desde el Entry
        valor_entry_Vu_ultimo = entry_Vu_ultimo.get()  
        
        # Extraer solo el valor numérico usando expresiones regulares
        x_Vu_match = re.findall(r"[-+]?\d*\.\d+|\d+", valor_entry_Vu_ultimo)  
        
        if x_Vu_match:
            Vu_ultimo = float(x_Vu_match[0])  
        else:
            print("Error: No se encontró un valor numérico válido en el Entry Vu_ultimo.")
            return
        
        # Paso 1: Calcular Vu_base
        Vu_base = Vu_ultimo * base_l
        
        
        # Paso 2: Despejar x_Vu
        x_Vu = Vu_base / Vmax
        
        
        # Paso 3: Calcular (x)_b_Vu
        x_b_Vu = base_l - x_Vu
        
        
        # Paso 4: Calcular (x)_c_Vu
        x_c_Vu = x_b_Vu
        
        
        # Ubicar el marcador morado en la posición correcta de Vu
        marcador_Vu_morado = ax.plot(x_c_Vu * factor_escala + desplazamiento, Vu_ultimo * factor_escala, 'mo', markersize=4)  
        
        # Añadir la etiqueta con el valor de Vu al lado del marcador
        ax.text(x_c_Vu * factor_escala + desplazamiento + 0.2, Vu_ultimo * factor_escala +2 , 
        f"Vu", color='m', fontsize=8)
        
        # --- Agregar la línea discontinua morada en Vu (vertical) ---
        ax.plot([x_c_Vu * factor_escala + desplazamiento, x_c_Vu * factor_escala + desplazamiento], 
        [0, Vu_ultimo * factor_escala], 'm--')  
        
        # --- Agregar la línea discontinua morada horizontal ---
        ax.plot([0 + desplazamiento, x_c_Vu * factor_escala + desplazamiento], 
        [Vu_ultimo * factor_escala, Vu_ultimo * factor_escala], 'm--')  
        
        # --- NUEVO CÁLCULO PARA ɸVc_revision --- 
        
        # Obtener el valor de ɸVc_revision desde el Entry
        valor_entry_ɸVc_revision = entry_ɸVc_revision.get()  
        
        # Extraer solo el valor numérico usando expresiones regulares
        x_ɸVc_revision_match = re.findall(r"[-+]?\d*\.\d+|\d+", valor_entry_ɸVc_revision)  

        if x_ɸVc_revision_match:
            cortante_ɸVc_revision = float(x_ɸVc_revision_match[0])  
        else:
            print("Error: No se encontró un valor numérico válido en el Entry ɸVc_revision.")
            return

        # Paso 1: Calcular ɸVc_base
        ɸVc_base = cortante_ɸVc_revision * base_l
        

        # Paso 2: Despejar x
        x = ɸVc_base / Vmax
        

        # Paso 3: Calcular (x)_1
        x_1 = base_l - x
        

        # Paso 4: Calcular (x)_2
        x_2 = x_1
        

        # Ubicar el marcador verde en la posición correcta de ɸVc_revision
        marcador_verde = ax.plot(x_2 * factor_escala + desplazamiento, cortante_ɸVc_revision * factor_escala, 'go',markersize=4) 

        # Añadir la etiqueta con el valor de la cortante ɸVc_revision al lado del marcador verde
        ax.text(x_2 * factor_escala + desplazamiento +0.2, cortante_ɸVc_revision * factor_escala -6, 
                f"ɸVc", color='g', fontsize=8)

        # Agregar una línea discontinua verde en el marcador de cortante ɸVc_revision (vertical)
        ax.plot([x_2 * factor_escala + desplazamiento, x_2 * factor_escala + desplazamiento], 
                [0, cortante_ɸVc_revision * factor_escala], 'g--')  

        # Agregar la línea discontinua verde horizontal en cortante ɸVc_revision
        ax.plot([0 + desplazamiento, x_2 * factor_escala + desplazamiento], 
                [cortante_ɸVc_revision * factor_escala, cortante_ɸVc_revision * factor_escala], 'g--')  
        
        
        # --- NUEVO CÁLCULO PARA ɸVcmedios_revision --- 
        
        # Obtener el valor de ɸVcmedios_revision desde el Entry
        valor_entry_ɸVcmedios_revision = entry_ɸVcmedios_revision.get()  
        
        # Extraer solo el valor numérico usando expresiones regulares
        x_ɸVcmedios_revision_match = re.findall(r"[-+]?\d*\.\d+|\d+", valor_entry_ɸVcmedios_revision)  
        
        if x_ɸVcmedios_revision_match:
            cortante_ɸVcmedios_revision = float(x_ɸVcmedios_revision_match[0])  
        else:
            print("Error: No se encontró un valor numérico válido en el Entry ɸVcmedios_revision.")
            return
        
        # Paso 1: Calcular ɸVc_medios_base
        ɸVc_base_medios = cortante_ɸVcmedios_revision * base_l
        
        
        # Paso 2: Despejar x_a
        x_a = ɸVc_base_medios / Vmax
        
        
        # Paso 3: Calcular (x)_b
        x_b = base_l - x_a
        
        
        # Paso 4: Calcular (x)_c
        x_c = x_b
        
        
        # Ubicar el marcador verde en la posición correcta de ɸVcmedios_revision
        marcador_azul = ax.plot(x_c * factor_escala + desplazamiento, cortante_ɸVcmedios_revision * factor_escala, 'bo',markersize=4)  
        
        # Añadir la etiqueta con el valor de la cortante ɸVcmedios_revision al lado del marcador verde
        ax.text(x_c * factor_escala + desplazamiento + 0.2, cortante_ɸVcmedios_revision * factor_escala +2, 
        f"ɸVc/2", color='b', fontsize=8)
        
        # Agregar una línea discontinua verde en el marcador de cortante ɸVcmedios_revision (vertical)
        ax.plot([x_c * factor_escala + desplazamiento, x_c * factor_escala + desplazamiento], 
        [0, cortante_ɸVcmedios_revision * factor_escala], 'b--')  
        
        # Agregar la línea discontinua verde horizontal en cortante ɸVcmedios_revision
        ax.plot([0 + desplazamiento, x_c * factor_escala + desplazamiento], 
        [cortante_ɸVcmedios_revision * factor_escala, cortante_ɸVcmedios_revision * factor_escala], 'b--')  
        
        # --- NUEVO CÁLCULO PARA Vs_estribos --- 
        
        # Obtener el valor de Vs_estribos desde el Entry
        valor_entry_Vs_estribos = entry_Vs_estribos.get()  
        
        # Extraer solo el valor numérico usando expresiones regulares
        x_Vs_estribos_match = re.findall(r"[-+]?\d*\.\d+|\d+", valor_entry_Vs_estribos)  
        
        if x_Vs_estribos_match:
            cortante_Vs_estribos = float(x_Vs_estribos_match[0])  
        else:
            print("Error: No se encontró un valor numérico válido en el Entry Vs_estribos.")
            return
        
        # Paso 1: Calcular Vs_estribos_base
        Vs_estribos_base = cortante_Vs_estribos * base_l
        
        
        # Paso 2: Despejar x_estribo
        x_estribo = Vs_estribos_base / Vmax
        
        
        # Paso 3: Calcular (x)_estribo_b
        x_estribo_b = base_l - x_estribo
        
        
        # Paso 4: Calcular (x)_estribo_c
        x_estribo_c = x_estribo_b
        
        
        # Ubicar el marcador amarillo en la posición correcta de Vs_estribos
        marcador_naranja = ax.plot(x_estribo_c * factor_escala + desplazamiento, cortante_Vs_estribos * factor_escala, 'o', color=(1.0, 0.647, 0.0), markersize=4)  
        
        # Añadir la etiqueta con el valor de la cortante Vs_estribos al lado del marcador amarillo
        ax.text(x_estribo_c * factor_escala + desplazamiento + 0.2, cortante_Vs_estribos * factor_escala + 8, 
        f"Vs", color=(1.0, 0.647, 0.0), fontsize=8)
        
        # Agregar una línea discontinua amarilla en el marcador de cortante Vs_estribos (vertical)
        ax.plot([x_estribo_c * factor_escala + desplazamiento, x_estribo_c * factor_escala + desplazamiento], 
        [0, cortante_Vs_estribos * factor_escala], '--',color=(1.0, 0.647, 0.0))  
        
        # Agregar la línea discontinua amarilla horizontal en cortante Vs_estribos
        ax.plot([0 + desplazamiento, x_estribo_c * factor_escala + desplazamiento], 
        [cortante_Vs_estribos * factor_escala, cortante_Vs_estribos * factor_escala], '--',color=(1.0, 0.647, 0.0)) 
        
        
        # Agregar leyenda para el marcador rojo con el valor de Vmax
        ax.legend(
        [marcador_rojo[0], marcador_rojo_cortante[0], marcador_Vu_morado[0], marcador_verde[0], marcador_azul[0], marcador_naranja[0]], 
        [f"Vmax: {Vmax} kN", f"V(borde): {cortante_en_x:.2f} kN", f"Vu: {Vu_ultimo:.2f} kN", 
        f"ɸVc: {cortante_ɸVc_revision:.2f} kN", f"ɸVc/2: {cortante_ɸVcmedios_revision:.2f} kN", f"Vs: {cortante_Vs_estribos:.2f} kN"], 
        loc='upper left', fontsize=7, bbox_to_anchor=(-0.17, 1),
        frameon=False,  
        )
        
        # Crear la anotación FIJA a la derecha del gráfico sin borde
        anotacion = ax.text(
        L_cortante_C * 1.1, Vmax * 1.5,  
        f"Valores\nV: {Vmax:.2f} kN\nL: {0:.2f} m",  
        color="black", fontsize=7, ha="left",  
        bbox=dict(facecolor='white', boxstyle='round,pad=0.5', edgecolor='none')
        )
        
    except ValueError:
        print("Error: Ingrese un valor numérico válido para x.")
        return
    
    # Comprobar si el Checkbutton está marcado (comprobamos la variable BooleanVar)
    if check_longitud_refuerzo_var.get():  
        # Colocar la figura en el canvas de tkinter
        canvas_l = FigureCanvasTkAgg(fig, master=canvas_longitud)  
        canvas_l.draw()
        canvas_l.get_tk_widget().pack(fill="both", expand=True)  
    else:
        # Si no está marcado, borrar el canvas
        for widget in canvas_longitud.winfo_children():
            widget.destroy()  
    
    # Guardar la imagen en alta calidad (DPI 300)
    ruta_guardado_2 = os.path.join("Reportes", "imagenes_pilot", "longitud_refuerzo.png")
    os.makedirs(os.path.dirname(ruta_guardado_2), exist_ok=True)  # Crear directorio si no existe
    fig.savefig(ruta_guardado_2, dpi=300, bbox_inches='tight')
    
    
    # Crear el Slider
    slider_cortante = tk.Scale(labelframe_estribos, from_=0, to=base_l, orient="horizontal", resolution=0.00)
    slider_cortante.set(base_l)  # Establecer el valor máximo
    slider_cortante.place(x=250, y=1)
    
    # Crear entry_posicion 
    entry_posicion = tk.Entry(labelframe_estribos)
    entry_posicion.place(x=90,y=10,width=80)
    
    # Crear el label para mostrar el valor del slider
    label_valor = tk.Label(labelframe_estribos, text=f"x={base_l:.2f} m",bd=2,relief="ridge")
    label_valor.place(x=253,y=1,width=100)
    
    # Crear el marcador negro, iniciando en la posición del vértice superior (Vmax)
    marcador_negro, = ax.plot([desplazamiento], [Vmax * factor_escala], 'ko', markersize=4)
    
    linea_discontinua, = ax.plot([desplazamiento, desplazamiento], [Vmax * factor_escala, 0], 'k--')  
    
    
    # Función para redimensionar la imagen
    def redimensionar_imagen(ruta_imagen, tamano):
        imagen_agregar_eliminar = Image.open(ruta_imagen)  # Abrir la imagen
        imagen_agregar_eliminar = imagen_agregar_eliminar.resize(tamano)  # Redimensionarla
        return ImageTk.PhotoImage(imagen_agregar_eliminar)  # Convertirla en un formato compatible con Tkinter
        
        # Cargar las imágenes de los iconos redimensionadas
        imagen_agregar = redimensionar_imagen("Iconos_proyecto/agregar_marcador.png", (20, 20))
        imagen_eliminar = redimensionar_imagen("Iconos_proyecto/eliminar_marcador.png", (20, 20))
        
        # Mantener una referencia de las imágenes
        boton_agregar_marcador.icono = imagen_agregar
        boton_eliminar_marcador.icono = imagen_eliminar
    
    
    def actualizar_marcador(value):
        
        # Obtener el valor ingresado en el Entry
        try:
            valor_entry = float(entry_posicion.get())  # Capturamos el dato del Entry
        except ValueError:
            print("Error: El valor ingresado en entry_posicion no es válido.")
            return  
        
        nuevo_x = float(value) * factor_escala + desplazamiento  
        nuevo_y = Vmax * (1 - (float(value) / base_l))  
        
        marcador_negro.set_data([nuevo_x], [nuevo_y * factor_escala])  
        
        # Actualizar la línea discontinua para que llegue hasta la base
        linea_discontinua.set_data([nuevo_x, nuevo_x], [nuevo_y * factor_escala, 0])
        
        anotacion.set_text(f"Valores\nV: {nuevo_y:.2f} kN\nL: {value:.2f} m")
        
        # Actualizar el texto del label con el formato "x={valor:.2f}"
        label_valor.config(text=f"x={float(value):.2f} m")
        
        canvas_l.draw()  
        
        
    # Asociar el evento del slider con la función de actualización
    slider_cortante.configure(command=lambda val: actualizar_marcador(float(val)))
    
    # Función para que el Slider se actualice con el valor del Entry
    def actualizar_slider_desde_entry():
        try:
        # Obtener el valor del Entry
            valor_entry = float(entry_posicion.get())
        
        # Asegurarse de que esté dentro del rango
            if 0 <= valor_entry <= base_l:
            # Actualizar el Slider y el marcador
                slider_cortante.set(valor_entry)
                actualizar_marcador(valor_entry)  # Actualizar el gráfico
            else:
                print("Valor fuera de rango.")
        except ValueError:
            print("Por favor ingrese un valor numérico válido en el Entry.")
    
    # Función que permite cambiar el valor del Entry al mover el Slider
    def actualizar_entry_desde_slider(value):
        entry_posicion.delete(0, tk.END)
        entry_posicion.insert(0, str(value))  
    
    # Asignar la función para actualizar el marcador cuando el usuario presiona Enter
    entry_posicion.bind("<Return>", lambda event: actualizar_slider_desde_entry())
    
    # Función que permite cambiar el valor del Entry al mover el Slider
    def actualizar_entry_desde_slider(value):
        entry_posicion.delete(0, tk.END)
        entry_posicion.insert(0, str(value))  # Actualizar el valor del Entry cuando el Slider cambia
    
    
    def agregar_marcador():
        """Función para agregar una nueva línea discontinua al hacer clic en el botón"""
        global ultimo_valor_borde_C 
        try:
        # Capturamos el valor de entry_posicion
            valor_entry = float(entry_posicion.get())  # Capturar el dato del Entry
        # Capturamos el valor de entry_borde_C y limpiamos cualquier texto adicional
            valor_borde_C_str = entry_borde_C.get()  # Capturamos el valor de entry_borde_C como string
            valor_borde_C = float(re.sub(r'[^0-9.]', '', valor_borde_C_str))  # Elimina todo lo que no sea número o punto decimal
            valor_borde_C = valor_borde_C + 0.05  # Sumamos 0.05 al valor obtenido de entry_borde_C
        except ValueError:
            print("Error: El valor ingresado en entry_posicion o entry_borde_C no es válido.")
            return 

        nuevo_x = valor_entry * factor_escala + desplazamiento  
        nuevo_y = Vmax * (1 - (valor_entry / base_l))  
    
    # Crear una nueva línea discontinua
        nueva_linea, = ax.plot([nuevo_x, nuevo_x], [nuevo_y * factor_escala, 0], 'k-', linewidth=1.5)
    
    # Guardar la línea en la lista
        lineas_discontinuas.append(nueva_linea)
        posiciones_x.append(valor_entry)  
        
    # Calcular la distancia entre las últimas dos líneas si hay más de una
        if len(posiciones_x) > 1:
            distancia = posiciones_x[-1] - posiciones_x[-2]
            
    
    # Posiciones en x para la cota
            x1 = posiciones_x[-2] * factor_escala + desplazamiento
            x2 = posiciones_x[-1] * factor_escala + desplazamiento
            y_cota = -17  
        
        # Línea de la cota
            linea_cota, = ax.plot([x1, x2], [y_cota, y_cota], 'r-', linewidth=1.5)
        
        # Marcas de los extremos de la cota
            marca_izq, = ax.plot([x1, x1], [y_cota - 2, y_cota + 2], 'r-', linewidth=1.5)
            marca_der, = ax.plot([x2, x2], [y_cota - 2, y_cota + 2], 'r-', linewidth=1.5)
        
        # Texto con el valor de la distancia
            texto_cota = ax.text((x1 + x2) / 2, y_cota - 3, f"{distancia:.2f}", color='black', fontsize=7, ha='center')
            textos_cotas.append(texto_cota)  # Guardamos el texto en la lista
        
            # Comprobamos si el valor de entry_borde_C ha cambiado
            if valor_borde_C != ultimo_valor_borde_C:
                ultimo_valor_borde_C = valor_borde_C  
            
            # Calculamos la posición en X de la cota adicional
                nuevo_x_borde = valor_borde_C * factor_escala + desplazamiento  
                y_cota_borde = y_cota  # Usamos la misma posición Y para la cota adicional
            
            # Línea de la cota adicional (verde y discontinua)
                linea_cota_borde, = ax.plot([nuevo_x_borde, nuevo_x_borde], [y_cota_borde, y_cota_borde + 5], 'g--', linewidth=1.5)
            
            # Marcas de los extremos de la cota adicional
                marca_izq_borde, = ax.plot([nuevo_x_borde, nuevo_x_borde], [y_cota_borde - 2, y_cota_borde + 2], 'g-', linewidth=1.5)
                marca_der_borde, = ax.plot([nuevo_x_borde, nuevo_x_borde], [y_cota_borde - 2, y_cota_borde + 2], 'g-', linewidth=1.5)
            
            # Texto con el valor de la cota adicional
                texto_cota_borde = ax.text(nuevo_x_borde, y_cota_borde - 3, f"{valor_borde_C:.2f}", color='black', fontsize=7, ha='center')
                textos_cotas.append(texto_cota_borde)  # Guardamos el texto en la lista
            
            # Guardar ambas cotas (principal y adicional) en la lista de cotas
                cotas.append((linea_cota, marca_izq, marca_der, texto_cota, linea_cota_borde, marca_izq_borde, marca_der_borde, texto_cota_borde))
            
            
            # Redibujar el canvas
            canvas_l.draw()
            
    
    def borrar_lineas_discontinuas():
        """Función para borrar todas las líneas discontinuas del gráfico."""
        global lineas_discontinuas, posiciones_x, cotas, textos_cotas
    
    # Eliminar todas las líneas discontinuas del gráfico
        for linea in lineas_discontinuas:
            linea.remove()  # Removemos cada línea del gráfico
    
    # Limpiar las listas
        lineas_discontinuas.clear()
        posiciones_x.clear()
    
    # Eliminar todas las cotas del gráfico
        for cota in cotas:
            for elemento in cota:  # Cada cota contiene la línea, las marcas y el texto
                if elemento in ax.get_children():  # Verificamos si el elemento aún está en el gráfico
                    elemento.remove()
    
    # Limpiar la lista de cotas
        cotas.clear()
    
    # Eliminar los textos de las cotas
        for texto in textos_cotas:
            if texto in ax.get_children():  # Verificamos si el texto aún está en el gráfico
                texto.remove()  # Removemos cada objeto de texto
    
    # Limpiar la lista de textos
        textos_cotas.clear()
    
    # Redibujar el canvas sin las líneas y textos
        canvas_l.draw()
    
    
    
    
    # Crear los botones con la nueva lógica
    boton_agregar_marcador = tk.Button(labelframe_estribos, image=imagen_agregar, bd=2, relief="flat",command=agregar_marcador)
    boton_agregar_marcador.place(x=180, y=10)
    
    boton_eliminar_marcador = tk.Button(labelframe_estribos, image=imagen_eliminar, bd=2, relief="flat",command=borrar_lineas_discontinuas)
    boton_eliminar_marcador.place(x=215, y=10)


def agregar_datos_treeview_cortante():
    """Obtiene los datos de los labels y los inserta en el treeview sin duplicar filas."""
    # Obtener los valores de los labels
    wu = label_seccion_Wu.cget("text") + "kN/m"
    vmax = label_Vmax_prueba.cget("text")
    vu = label_Vu.cget("text")
    vc = label_ɸVc.cget("text")
    vc_2 = label_ɸVc_2.cget("text")
    vs = Vs_resistencia.cget("text")  
    
    # Obtener el valor del label_check_Vs
    check_vs = label_check_Vs.cget("text")
    check_control = label_check_control.cget("text")

    # Verificar si ya hay una fila en el primer treeview
    items_1 = treeview_cortante_1.get_children()
    if items_1:
        # Actualizar la primera fila existente
        treeview_cortante_1.item(items_1[0], values=(wu, vmax, vu, vc, vc_2, vs))
    else:
        # Insertar una nueva fila si está vacío
        treeview_cortante_1.insert("", "end", values=(wu, vmax, vu, vc, vc_2, vs))
    
    # Actualizar información
    label_cortante_check_Vs.config(text=check_vs)  
    label_control_check.config(text=check_control)
    
    # Obtener los valores de los otros labels para el segundo Treeview
    Smax_estribos_text = Smax_estribos.cget("text")
    Av_requerida_text = label_Av_requerida.cget("text")
    num_ramas_text = label_num_ramas.cget("text")
    Vs_resistencia_req_text = Vs_resistencia_req.cget("text")

    # Verificar si ya hay una fila en el segundo treeview
    items_2 = treeview_cortante_2.get_children()
    if items_2:
        # Actualizar la primera fila existente en treeview_cortante_2
        treeview_cortante_2.item(items_2[0], values=(Smax_estribos_text, Av_requerida_text, num_ramas_text, Vs_resistencia_req_text))
    else:
        # Insertar una nueva fila si está vacío
        treeview_cortante_2.insert("", "end", values=(Smax_estribos_text, Av_requerida_text, num_ramas_text, Vs_resistencia_req_text))
    
    # Obtener el valor de Label_check_ramas y actualizar en label_cortante_check_ramas
    check_ramas = Label_check_ramas.cget("text")
    label_cortante_check_ramas.config(text=check_ramas)

    # Obtener el valor de Label_check_separacion y actualizar en label_cortante_check_separacion
    check_separacion = Label_check_separacion.cget("text")
    label_cortante_check_separacion.config(text=check_separacion)
    
    label_icon_cortante_2.config(image=icon_check_on)
    
    # Obtener los valores de los labels necesarios para treeview_cortante_3
    Vs_resistencia_req_text = Vs_resistencia_req.cget("text")
    vu_text = label_Vu.cget("text")
    label_ɸVn_text = label_ɸVn.cget("text")  # Valor de label_ɸVn
    label_Vu_ɸVn_text = label_Vu_ɸVn.cget("text")  # Valor de label_Vu_ɸVn
    label_check_capacidad = label_check_Vu_ɸVn.cget("text")

    # Verificar si ya hay una fila en el tercer treeview (treeview_cortante_3)
    items_3 = treeview_cortante_3.get_children()
    if items_3:
        # Actualizar la primera fila existente en treeview_cortante_3
        treeview_cortante_3.item(items_3[0], values=(Vs_resistencia_req_text, vu_text, label_ɸVn_text, label_Vu_ɸVn_text))
    else:
        # Insertar una nueva fila si está vacío
        treeview_cortante_3.insert("", "end", values=(Vs_resistencia_req_text, vu_text, label_ɸVn_text, label_Vu_ɸVn_text))

    # Actualizar el label_check_Vu_ɸVn
    label_cortante_capacidad_check.config(text=label_check_capacidad)
    label_icon_cortante_3.config(image=icon_check_on)


def Generar_reportes():
    # Obtener el directorio de trabajo actual (directorio donde está el script)
    current_dir = os.path.dirname(os.path.realpath(__file__))  # Directorio donde se ejecuta el script

    # Definir rutas relativas basadas en el directorio actual
    doc_template_path = os.path.join(current_dir, 'Reportes', 'Formato_reporte.docx')

    # Obtener los datos de la interfaz de usuario
    nombre_estudiante = label_estudiante.cget("text")
    nombre_modelo = label_modelo.cget("text")
    parametro_fc = label_fc.cget("text")
    parametro_Ec = label_elasticidad.cget("text")
    parametro_viga = label_seccion_cargas.cget("text")  
    parametro_altura = label_h.cget("text")  
    parametro_concreto = label_resistencia_psi.cget("text")
    parametro_Wpp = label_cargas_Wpp.cget("text")
    parametro_WD = label_cargas_WD.cget("text")
    parametro_WL = label_cargas_WL.cget("text")
    parametro_Wtotal = label_cargas_Wtotal.cget("text")
    parametro_Wu = label_seccion_Wu.cget("text")
    parametro_luz = label_seccion_luz.cget("text")
    parametro_tipo_viga = label_tipo_viga_cargas.cget("text")
    parametro_apoyos = label_reaccion.cget("text")
    parametro_Vmax = label_reaccion.cget("text")
    parametro_Mmax = label_Mmax_1.cget("text")
    parametro_Mmax_2 = label_Mmax_2.cget("text")
    parametro_cuantia_min = label_cuantia_minima.cget("text")
    parametro_cuantia_max = label_cuantia_maxima.cget("text")
    parametro_beta1 = label_beta1.cget("text")
    parametro_Rn = label_Resistencia_Rn.cget("text")
    parametro_cuantia_req = label_cuantia_requerida.cget("text")
    parametro_acero_req = label_acero_requerido.cget("text")
    parametro_Rn2 = label_Rn2.cget("text")
    parametro_C2 = label_req_C2.cget("text")
    parametro_As2 = label_As2.cget("text")
    parametro_estribo = label_estribo.cget("text")
    parametro_area_estribo = label_area_estribo.cget("text") 
    parametro_diametro_estribo = label_prueba_estribo.cget("text")
    parametro_ɸMn1 = label_ɸMn1.cget("text")
    parametro_ɸMn2 = label_ɸMn2.cget("text")
    parametro_conclusion1 = label_concluision_ɸMn.cget("text")
    parametro_conclusion2 = label_concluision_ɸMn2.cget("text")
    parametro_check = label_check.cget("text")
    parametro_No_barra= label_barra.cget("text")
    parametro_area_barra = label_area_barra.cget("text")
    parametro_Øbarras = label_Øbarras.cget("text")
    parametro_Asb1 = label_barra_flexion.cget("text")
    parametro_Asb2 = label_barra_flexion1.cget("text")
    parametro_A = label_A_1.cget("text")
    parametro_C = label_C_1.cget("text")
    parametro_D = label_D_1.cget("text")
    parametro_n = label_n_1.cget("text")
    parametro_dp = label_dp_1.cget("text")
    parametro_base_req = label_base_req.cget("text")
    parametro_base_req1 = label_base_req1.cget("text")
    parameteo_check1 = label_check_As.cget("text")
    parametro_Mcr = label_Mcr_1.cget("text")
    parametro_check_Mcr = label_Mcr_check.cget("text")
    parametro_Rn_Mcr = label_Rn_mcr.cget("text")
    parametro_Rn_Mcr_check = label_Rn_mcr_check.cget("text")
    parametro_ρreq_mcr=  label_ρreq_mcr.cget("text")
    parametro_As_c = label_area_req_mcr.cget("text")
    parametro_Ab_c = label_area_barra_mcr.cget("text")
    parametro_num_barra_mcr = label_num_barra_mcr.cget("text")
    parametro_conclusion_mcr = label_check_Mcr.cget("text")
    parametro_d_t = label_diametro_traccion.cget("text")
    parametro_Ld = label_Ld_traccion.cget("text")
    parametro_d_c = label_diametro_compresion.cget("text")
    parametro_Ldc = label_Ldc_compresion.cget("text")
    parametro_Ldh_t = label_ldh_t.cget("text")
    parametro_ldh_c = label_ldh_c.cget("text")
    parametro_ganchos = label_gancho_anclaje.cget("text")
    parametro_gancho_traccion = label_longitud_t.cget("text")
    parametro_gancho_compresion = label_longitud_c.cget("text")
    parametro_ancho_columna = label_ancho_columna.cget("text")
    
    
    # Agregar unidad "m" al parámetro base
    try:
        parametro_base = f"{float(entry_prueba_base.get()):.2f} m"  # <<base>> con formato y unidad
    except ValueError:
        parametro_base = "N/A"  # Manejo de error si el valor no es numérico

    parametro_r = label_recubrimiento.cget("text")  # <<r>>
    parametro_d = label_altura_efectiva.cget("text")  # <<d>>

    # Nuevos parámetros
    parametro_b = parametro_base  # <<b>>
    parametro_h = parametro_altura  # <<h>>
    
    parametro_info_barras_mcr = label_info_barras_mcr.cget("text")  # Obtener el texto de la etiqueta
    
    # Obtener el texto de label_info_b (nuevo parámetro)
    parametro_info_barras = label_info_b.cget("text")  # <<info_barras>> 

    # Definir la ruta de la imagen del gráfico
    parametro_grafico = os.path.join(current_dir, 'Reportes', 'imagenes_pilot', 'grafico.png')  
    parametro_grafico_final = os.path.join(current_dir, 'Reportes', 'imagenes_pilot', 'grafico_final.png')  
    
    # Cargar el documento
    try:
        doc_report = Document(doc_template_path)
    except Exception as e:
        print(f" Error al cargar el archivo: {e}")
        return  

    # Diccionario de reemplazos 
    replacements = {
        '<<fc>>': parametro_fc,
        '<<Ec>>': parametro_Ec,
        '<<Viga>>': parametro_viga,
        '<<altura>>': parametro_altura,
        '<<base>>': parametro_base,  
        '<<r>>': parametro_r,
        '<<d>>': parametro_d,
        '<<b>>': parametro_b,  
        '<<h>>': parametro_h,
        '<<concreto>>': parametro_concreto,
        '<<Wpp>>': parametro_Wpp,
        '<<WD>>': parametro_WD,
        '<<WL>>': parametro_WL,
        '<<Wtotal>>': parametro_Wtotal,
        '<<Wu>>': parametro_Wu,
        '<<Luz>>': parametro_luz,
        '<<Elemento>>': parametro_tipo_viga,
        '<<apoyo>>': parametro_apoyos,
        '<<Vmax>>': parametro_Vmax,
        '<<Mmax>>': parametro_Mmax,
        '<<Mmax1>>': parametro_Mmax_2,
        '<<cuantia>>': parametro_cuantia_min,
        '<<cuantiamax>>': parametro_cuantia_max,
        '<<beta>>': parametro_beta1,
        '<<Rn>>': parametro_Rn,
        '<<req>>': parametro_cuantia_req,
        '<<Asreq>>': parametro_acero_req,
        '<<Rn2>>': parametro_Rn2,
        '<<c2>>': parametro_C2,
        '<<As2>>': parametro_As2,
        '<<fleje>>': parametro_estribo,
        '<<dfleje>>': parametro_diametro_estribo,
        '<<Afleje>>': parametro_area_estribo,
        '<<Mn1>>': parametro_ɸMn1,
        '<<Mn2>>': parametro_ɸMn2,
        '<<V1>>': parametro_conclusion1,
        '<<V2>>': parametro_conclusion2,
        '<<check>>': parametro_check,
        '<<info_barras>>': parametro_info_barras,
        '<<barra>>': parametro_No_barra,
        '<<area>>': parametro_area_barra,
        '<<diametro_barra>>': parametro_Øbarras,
        '<<Asb1>>': parametro_Asb1,
        '<<Asb2>>': parametro_Asb2,
        '<<A>>': parametro_A,
        '<<C>>': parametro_C,
        '<<D>>': parametro_D,
        '<<n>>': parametro_n,
        '<<dp>>': parametro_dp,
        '<<base_req>>': parametro_base_req,
        '<<base_req2>>': parametro_base_req1,
        '<<check1>>': parameteo_check1,
        '<<Mcr>>': parametro_Mcr,
        '<<check2>>': parametro_check_Mcr,
        '<<Rn_mcr>>':parametro_Rn_Mcr,
        '<<check3>>': parametro_Rn_Mcr_check,
        '<<ρreq_mcr>>': parametro_ρreq_mcr,
        '<<As_c>>': parametro_As_c,
        '<<Ab_c>>': parametro_Ab_c,
        '<<B_c>>': parametro_num_barra_mcr,
        '<<check4>>': parametro_conclusion_mcr,
        '<<Øbarra>>': parametro_d_t,
        '<<Ld>>': parametro_Ld,
        '<<Øbarra_c>>': parametro_d_c,
        '<<Ldc>>': parametro_Ldc,
        '<<Ldh_t>>': parametro_Ldh_t,
        '<<Ldh_c>>': parametro_ldh_c,
        '<<gancho>>': parametro_ganchos,
        '<<longitud_t>>': parametro_gancho_traccion,
        '<<longitud_c>>': parametro_gancho_compresion,
        '<<check5>>': parametro_ancho_columna
        
    }

    # Reemplazar texto en todo el documento, no solo en las celdas de la tabla
    for paragraph in doc_report.paragraphs:
        for key, value in replacements.items():
            if key in paragraph.text:
                # Reemplazar el texto en el párrafo
                paragraph.text = paragraph.text.replace(key, value)
                
                # Aplicar la fuente Times New Roman
                for run in paragraph.runs:
                    run.font.name = 'Times New Roman'

    # Ahora reemplazar los marcadores <<JD>> dentro de las celdas de la tabla con la imagen
    for table in doc_report.tables:
        for row in table.rows:
            for cell in row.cells:
                if '<<JD>>' in cell.text:
                    # Limpiar el contenido de la celda que contiene <<JD>>
                    for paragraph in cell.paragraphs:
                        for run in paragraph.runs:
                            run.clear()  # Limpiar el contenido actual de la celda
                    
                    # Insertar la imagen en la celda donde estaba <<JD>>
                    paragraph = cell.add_paragraph()
                    paragraph.add_run().add_picture(parametro_grafico, width=Inches(2.5))  # Insertamos la imagen en la celda

                    # Aplicar la fuente Times New Roman en el nuevo run de imagen
                    for run in paragraph.runs:
                        run.font.name = 'Times New Roman'
                
                # Comprobar si la celda contiene el marcador <<esquema>> para insertar el gráfico final
                if '<<esquema>>' in cell.text:
                    # Limpiar el contenido de la celda que contiene <<esquema>>
                    for paragraph in cell.paragraphs:
                        for run in paragraph.runs:
                            run.clear()  # Limpiar el contenido actual de la celda
                    # Insertar la imagen final en la celda donde estaba <<esquema>>
                    paragraph = cell.add_paragraph()
                    paragraph.add_run().add_picture(parametro_grafico_final, width=Inches(3.5)) 
                    # Aplicar la fuente Times New Roman en el nuevo run de imagen
                    for run in paragraph.runs:
                        run.font.name = 'Times New Roman'
    
    # Reemplazar el marcador <<info_barras>> dentro de las celdas de la tabla
    for table in doc_report.tables:
        for row in table.rows:
            for cell in row.cells:
            # Comprobar si la celda contiene el marcador <<info_barras>>
                if '<<info_barras>>' in cell.text:
                # Reemplazar el marcador con el valor de parametro_info_barras
                    cell.text = cell.text.replace('<<info_barras>>', parametro_info_barras)
                
                # Aplicar la fuente Times New Roman (opcional)
                    for paragraph in cell.paragraphs:
                        for run in paragraph.runs:
                            run.font.name = 'Times New Roman'
    
    # Reemplazar el marcador <<info_barra_As>> dentro de las celdas de la tabla
    for table in doc_report.tables:
        for row in table.rows:
            for cell in row.cells:
            # Comprobar si la celda contiene el marcador <<info_barra_As>>
                if '<<info_barra_As>>' in cell.text:
                # Reemplazar el marcador con el valor de parametro_info_barras_mcr
                    cell.text = cell.text.replace('<<info_barra_As>>', parametro_info_barras_mcr)
    
                # Aplicar la fuente Times New Roman (opcional)
                    for paragraph in cell.paragraphs:
                        for run in paragraph.runs:
                            run.font.name = 'Times New Roman'
        
    # Ahora reemplazar los marcadores <<Estudiante>> y <<Modelo>> dentro de las celdas de la tabla
    for table in doc_report.tables:
        for row in table.rows:
            for cell in row.cells:
                if '<<Estudiante>>' in cell.text:
                    cell.text = cell.text.replace('<<Estudiante>>', nombre_estudiante)
                    # Aplicar la fuente Times New Roman en las celdas
                    for run in cell.paragraphs[0].runs:
                        run.font.name = 'Times New Roman'
                if '<<Modelo>>' in cell.text:
                    cell.text = cell.text.replace('<<Modelo>>', nombre_modelo)
                    # Aplicar la fuente Times New Roman en las celdas
                    for run in cell.paragraphs[0].runs:
                        run.font.name = 'Times New Roman'

    # Cuadro de diálogo para guardar el archivo
    file_path = filedialog.asksaveasfilename(
        defaultextension='.docx',
        filetypes=[('Archivos de Word', '*.docx')],
        title="Guardar el reporte"
    )

    if file_path:  # Si el usuario seleccionó un archivo y la ruta no está vacía
        try:
            doc_report.save(file_path)  # Guardar el archivo en la ubicación seleccionada
            print("✅ Reporte generado y guardado correctamente.")

            # Abrir el archivo generado automáticamente en Word
            try:
                # Usamos subprocess para abrir el archivo con la aplicación predeterminada (Word)
                subprocess.run(["start", file_path], check=True, shell=True)
                print("✅ Documento abierto correctamente.")
            except Exception as e:
                print(f" Error al abrir el archivo: {e}")
        except Exception as e:
            print(f" Error al guardar el archivo: {e}")
    else:
        print(" No se seleccionó una ubicación para guardar el archivo.")

def generar_reporte_cortante():
    # Obtener los datos de la interfaz de usuario
    nombre_estudiante_1 = label_estudiante.cget("text")                 #1
    nombre_modelo_1 = label_modelo.cget("text")                         #2
    parametro_fc_1 = label_fc.cget("text")                              #3                                                                              
    parametro_Wu_1 = label_seccion_Wu.cget("text")                      #4
    parametro_luz_1 = label_seccion_luz.cget("text")                    #5                                                                              
    parametro_Vmax_1 = label_reaccion.cget("text")                      #6
    parametro_d_1 =    label_altura_efectiva.cget("text")               #7                                                                
    parametro_estribo_1 = label_estribo.cget("text")                    #8                                                                          
    parametro_area_estribo_1 = label_area_estribo.cget("text")          #9                                                                     
    parametro_Vud_1 = label_Vu.cget("text")                             #10
    parametro_Vc_1 = label_ɸVc.cget("text")                             #11
    parametro_Vc_medios_1 = label_ɸVc_2.cget("text")                    #12
    parametro_resistencia_concreto_1 = Vs_resistencia.cget("text")      #13
    parametro_resistencia_estribos_1 = label_check_Vs.cget("text")      #14
    parametro_contro_V_1 = label_check_control.cget("text")             #15
    parametro_V_Smax_1 = Smax_estribos.cget("text")                     #16
    parametro_V_Av_1 = label_Av_requerida.cget("text")                  #17
    parametro_V_ramas_1 = label_num_ramas.cget("text")                  #18
    parametro_V_Vs_1  = Vs_resistencia_req.cget("text")                 #19
    parametro_V_check_Smax = Label_check_separacion.cget("text")        #20
    parametro_V_check_ramas = Label_check_ramas.cget("text")            #21
    parametro_V_Vn_1 = label_ɸVn.cget("text")                           #22
    parametro_V_check_Vn = label_Vu_ɸVn.cget("text")                    #23
    parametro_capacidad_Vn = label_check_Vu_ɸVn.cget("text")            #24
    
    # Diccionario de reemplazos para etiquetas en todo el documento (excepto las celdas)
    replacements_general = {
        "<<V_luz>>": parametro_luz_1,
        "<<V_fc>>": parametro_fc_1,
        "<<V_Wu>>": parametro_Wu_1,
        "<<V_vmax>>": parametro_Vmax_1,
        "<<V_d>>": parametro_d_1,
        "<<V_Estribo>>": parametro_estribo_1,
        "<<V_area_cortante>>": parametro_area_estribo_1,
        "<<V_vud>>": parametro_Vud_1,
        "<<V_vc>>": parametro_Vc_1,
        "<<V_medios>>": parametro_Vc_medios_1,
        "<<V_resistencia_concreto>>": parametro_resistencia_concreto_1,
        "<<V_resistencia_estribos>>" :parametro_resistencia_estribos_1,
        "<<V_control_concreto>>":parametro_contro_V_1,
        "<<V_Smax>>":parametro_V_Smax_1,
        "<<V_av>>": parametro_V_Av_1,
        "<<V_ramas>>":parametro_V_ramas_1,
        "<<V_vs>>": parametro_V_Vs_1,
        "<<V_check_Smax>>":parametro_V_check_Smax,
        "<<V_check_Ramas>>":parametro_V_check_ramas,
        "<<V_vn>>": parametro_V_Vn_1,
        "<<V_check_Vn>>": parametro_V_check_Vn,
        "<<V_capacidad_cortante>>": parametro_capacidad_Vn
    }

    # Diccionario de reemplazos para etiquetas dentro de las celdas de las tablas
    replacements_celdas = {
        "<<Estudiante>>": nombre_estudiante_1,
        "<<Modelo>>": nombre_modelo_1
    }

    # Rutas relativas de las imágenes
    imagen_cortante = "Reportes/imagenes_pilot/grafica_cortante.png"
    imagen_triangulo = "Reportes/imagenes_pilot/longitud_refuerzo.png"
    imagen_despiece = "Reportes/imagenes_pilot/grafico_estribos.png"

    # Ruta de la plantilla de Word
    template_path = "Reportes/Formato_cortante.docx"

    # Abrir el documento de plantilla
    doc = Document(template_path)

    # Reemplazar las etiquetas dentro de las celdas de las tablas (solo para <<Estudiante>> y <<Modelo>>)
    for table in doc.tables:
        for row in table.rows:
            for cell in row.cells:
                # Reemplazar etiquetas de texto como <<Estudiante>> y <<Modelo>> dentro de las celdas
                for key, value in replacements_celdas.items():
                    if key in cell.text:
                        cell.text = cell.text.replace(key, value)
                
                # Reemplazar la etiqueta de imagen y eliminarla (<<V_cortante>>)
                if "<<V_cortante>>" in cell.text:
                    cell.text = cell.text.replace("<<V_cortante>>", "")  # Eliminar la etiqueta
                    para = cell.paragraphs[0]  # Tomamos el primer párrafo de la celda
                    run = para.add_run()
                    run.add_picture(imagen_cortante, width=Inches(3.92), height=Inches(3.45))  # Ajusta el tamaño de la imagen según lo requerido

                # Reemplazar la etiqueta de imagen y eliminarla (<<V_triangulo>>)
                if "<<V_triangulo>>" in cell.text:
                    cell.text = cell.text.replace("<<V_triangulo>>", "")  # Eliminar la etiqueta
                    para = cell.paragraphs[0]  # Tomamos el primer párrafo de la celda
                    run = para.add_run()
                    run.add_picture(imagen_triangulo, width=Inches(4.76), height=Inches(3.12))  # Ajusta el tamaño de la imagen según lo requerido

                # Reemplazar la etiqueta de imagen y eliminarla (<<V_despiece>>)
                if "<<V_despiece>>" in cell.text:
                    cell.text = cell.text.replace("<<V_despiece>>", "")  # Eliminar la etiqueta
                    para = cell.paragraphs[0]  # Tomamos el primer párrafo de la celda
                    run = para.add_run()
                    run.add_picture(imagen_despiece, width=Inches(6.37), height=Inches(2.67))  # Ajusta el tamaño de la imagen según lo requerido

    # Reemplazar las etiquetas en el resto del documento (fuera de las celdas de las tablas)
    for para in doc.paragraphs:
        for key, value in replacements_general.items():
            if key in para.text:
                para.text = para.text.replace(key, value)

    # Abrir un cuadro de diálogo para guardar el archivo
    if check_reporte_word_1.get() == 1:  # Verificar si el Checkbutton está seleccionado
        file_path = filedialog.asksaveasfilename(defaultextension=".docx", filetypes=[("Word Documents", "*.docx")])
        if file_path:
            # Guardar el documento con el nombre proporcionado por el usuario
            doc.save(file_path)
            print(f"Reporte guardado en: {file_path}")

            # Abrir el documento Word generado después de guardarlo
            if os.name == 'nt':  # Para sistemas Windows
                subprocess.Popen(['start', file_path], shell=True)
            elif os.name == 'posix':  # Para sistemas Unix (Linux/Mac)
                subprocess.Popen(['open', file_path])
            else:
                print("No se puede abrir el archivo en este sistema operativo.")
        else:
            print("El archivo no fue guardado.")
    else:
        print("El reporte no se generará.")

# Variable para controlar si la ventana está abierta o no
ventana_abierta_pilot = False
ventana_Pilot = None  # Para hacer la ventana accesible en ambas funciones

def Abrir_ventana_Pilot_Structural():
    global ventana_abierta_pilot, ventana_Pilot  # Usamos las variables globales para mantener el estado de la ventana

    # Solo abrir la ventana si no está abierta ya
    if not ventana_abierta_pilot:
        # Crear una nueva ventana de tipo Toplevel
        ventana_Pilot = tk.Toplevel()
        
        # Configurar la ventana para que no se pueda redimensionar
        ventana_Pilot.resizable(False, False)

        # Asegurar que la ventana esté siempre en el frente
        ventana_Pilot.attributes('-topmost', True)

        # Establecer un tamaño para la ventana
        ventana_Pilot.geometry('850x580')

        # Agregar un título a la ventana
        ventana_Pilot.title("Acerca de Pilot Structural")

        # Marcar que la ventana está abierta
        ventana_abierta_pilot = True
        
        # crear contenido 
        labelframe_pilot = tk.LabelFrame(ventana_Pilot,text="")
        labelframe_pilot.place(x=10,y=10,width=830,height=550)
        
        labelframe_pilot_1 = tk.LabelFrame(labelframe_pilot,text="")
        labelframe_pilot_1.place(x=20,y=20,width=400,height=510)
        
        # Crear el Notebook
        Notebook_pilot = ttk.Notebook(labelframe_pilot_1,style="CustomNotebook.TNotebook")  
        
        # Crear una pestaña dentro del Notebook
        tab_pilot = ttk.Frame(Notebook_pilot)  
        
        # Agregar la pestaña al Notebook 
        Notebook_pilot.add(tab_pilot, text="Información")
        
        # Empaquetar el Notebook en el LabelFrame
        Notebook_pilot.pack(fill="both", expand=True)
        
        # crear canvas
        canvas_pilot = tk.Canvas(tab_pilot,bg="white",bd=2,relief="flat")
        canvas_pilot.pack(fill="both", expand=True)
        
        # Crear el Scrollbar vertical
        scrollbar_pilot = tk.Scrollbar(tab_pilot, orient="vertical",command=canvas_pilot.yview)
        scrollbar_pilot.place(x=370, y=0, width=20, height=475)
        
        # Vincular el Scrollbar vertical al Canvas
        canvas_pilot.config(yscrollcommand=scrollbar_pilot.set)
        
        frame_logo_pilot = tk.Frame(canvas_pilot,bd=2,relief="flat")
        
        # Cargar la imagen con PIL (Pillow) y redimensionarla
        image_path_pilot = "Iconos_proyecto/Pilot_Structural.png"
        img_piloto = Image.open(image_path_pilot)
        
        # Redimensionar la imagen 
        img_piloto = img_piloto.resize((250, 250), Image.Resampling.LANCZOS)  
        
        # Convertir la imagen redimensionada a PhotoImage 
        img_piloto_tk = ImageTk.PhotoImage(img_piloto)
        
        # Crear un Label con la imagen redimensionada
        label_with_image_pilot = tk.Label(frame_logo_pilot, image=img_piloto_tk)
        label_with_image_pilot.place(relx=0.5, rely=0.5, anchor="center")
        
        # Es necesario mantener una referencia a la imagen 
        label_with_image_pilot.image = img_piloto_tk
        
        # Crear un Label con todo el texto que mencionaste
        label_info_pilot = tk.Label(
        canvas_pilot,
        text="""Pilot Structural es una herramienta innovadora en el ámbito de la ingeniería civil, diseñada para revolucionar la enseñanza y comprensión de los conceptos técnicos del diseño de vigas de concreto reforzado. Este software pionero ofrece una experiencia educativa única al integrar programación en Python, lo que permite a estudiantes explorar y entender el diseño de vigas de una manera más didáctica y accesible.
        
Con un enfoque práctico y educativo, Pilot Structural no solo facilita la compresión de conceptos clave en el diseño estructural, sino que también automatiza la creación de reportes detallados y precisos, proporcionando análisis completos y cálculos de vigas de concreto reforzado. A través de la integración de datos dinámicos, gráficas interactivas y cálculos precisos, los usuarios pueden generar informes de forma rápida y eficiente.
        
Además, Pilot Structural destaca por su interfaz amigable, que permite a los usuarios, tanto estudiantes como profesionales, trabajar de manera intuitiva y sin complicaciones. Con este software, el aprendizaje y la práctica del diseño de vigas de concreto reforzado se vuelve más accesible, eficiente y, sobre todo, más comprensible.""",
        wraplength=310,  
        justify="left",  
        bg="white",  
        anchor="w"  
        )
        
        #Crear label limitaciones
        label_info_pilot_1 = tk.Label(
        canvas_pilot,
        text="Limitaciones:",
        font=("Arial", 8, "bold"),
        justify="left",  
        bg="white",  
        anchor="w"  
        )
        
        #Crear label limitaciones
        label_info_pilot_2 = tk.Label(
        canvas_pilot,
        text="""- El software solo puede realizar el análisis estructural de vigas en una única luz, sin considerar luces continuas o estructuras con más de una luz.
        
- El software se especializa exclusivamente en el diseño de vigas de concreto reforzado, por lo que no puede ser utilizado para el diseño de otros tipos de elementos estructurales como columnas, losas, o cimentaciones.

- Pilot Structural se limita al diseño de vigas de concreto reforzado para flexión y cortante. No realiza análisis o diseño para otros efectos estructurales""",
        wraplength=310,
        justify="left",  
        bg="white",  
        anchor="w"  
        )
        
        labelframe_desarrollado = tk.LabelFrame(labelframe_pilot,text="")
        labelframe_desarrollado.place(x=430,y=20,width=370,height=510)
        
        # Crear el Notebook
        Notebook_pilot_1 = ttk.Notebook(labelframe_desarrollado,style="CustomNotebook.TNotebook")  
        
        # Crear una pestaña dentro del Notebook
        tab_pilot_1 = ttk.Frame(Notebook_pilot_1)  
        
        # Agregar la pestaña al Notebook 
        Notebook_pilot_1.add(tab_pilot_1, text="Desarrollado por:")
        
        # Empaquetar el Notebook en el LabelFrame
        Notebook_pilot_1.pack(fill="both", expand=True)
        
        # crear canvas
        canvas_pilot_1 = tk.Canvas(tab_pilot_1,bg="white",bd=2,relief="flat")
        canvas_pilot_1.pack(fill="both", expand=True)
        
        # Crear el Scrollbar vertical
        scrollbar_pilot_1 = tk.Scrollbar(tab_pilot_1, orient="vertical",command=canvas_pilot_1.yview)
        scrollbar_pilot_1.place(x=340, y=0, width=20, height=475)
        
        frame_desarrollador = tk.Frame(canvas_pilot_1,bd=2,relief="flat",bg="white")
        
        # Cargar la imagen (ajustando la ruta relativa)
        ruta_desarrollo = "Iconos_proyecto/yo_ing_jd.png"
        imagen_desarrollo = Image.open(ruta_desarrollo)
        imagen_desarrollo = imagen_desarrollo.resize((250, 250))  
        imagen_tk_desarrollo = ImageTk.PhotoImage(imagen_desarrollo)
        
        # Crear un Label para mostrar la imagen dentro del Frame
        label_imagen_desarrollo = tk.Label(frame_desarrollador, image=imagen_tk_desarrollo, bg="white")
        label_imagen_desarrollo.image = imagen_tk_desarrollo  
        label_imagen_desarrollo.pack()
        
        label_desarrollador = tk.Label(canvas_pilot_1,text="Juan David Garzón Obando",font=("Arial", 12, "bold"),bg="white",
                                    justify="left",
                                    anchor="w"
                                    )
        
        label_intro = tk.Label(canvas_pilot_1,text="""Soy Ingeniero civil, mi pasion por la programación se refleja en mi habilidad para desarrollar programas especializado en el área de la ingeniería estructural. Pilot Structural es un proyecto que nace de la necesidad de crear una herramienta educativa y práctica para el diseño de vigas de concreto reforzado, con el objetivo de facilitar el aprendizaje y comprensión de los conceptos estructurales.
La innovación tecnológica me motiva a seguir aprendiendo y dando lo mejor de mí en cada proyecto. Me capacito de manera continua para mantenerme al día en la parte teórico-práctica y en el uso de softwares de modelado, análisis y diseño estructural, así como en la programación con Python para optimizar procesos y mejorar la eficiencia en el cálculo estructural.""",
                            wraplength=310,
                            justify="left",
                            bg="white",
                            anchor="w"
                            )
        
        label_contacto = tk.Label(canvas_pilot_1,text="Conocimiento en: Python, SAP2000, ETABS, AutoCAD, Revit, CypeCAD, Safe, Robot Structural, Microsoft Excel, Ofimatica.\n"
                                "Contacto: +57 302 543 2074\n"
                                "Correo: Ingenieriamaximo1@gmail.com",
                                font=("Arial", 8, "bold"),
                                bg="white",
                                wraplength=310,
                                justify="left",
                                anchor="w"
                                )
        
        label_frase_pilot = tk.Label(canvas_pilot_1,text="“El código perfecto no existe, pero quien persiste lo mejora”",
                                    justify="center",
                                    bg="white",
                                    font=("Arial", 8, "italic"),
                                    anchor="w"
                                    )
        
        # Vincular el Scrollbar vertical al Canvas
        canvas_pilot_1.config(yscrollcommand=scrollbar_pilot_1.set)
        
        canvas_pilot.create_window((185,140), window=frame_logo_pilot, width=250, height=250)
        canvas_pilot.create_window((170,450), window=label_info_pilot)
        canvas_pilot.create_window((55,670), window=label_info_pilot_1)
        canvas_pilot.create_window((170,780), window=label_info_pilot_2)
        canvas_pilot_1.create_window((170,140), window=frame_desarrollador, width=250, height=250)
        canvas_pilot_1.create_window((170,250), window=label_desarrollador)
        canvas_pilot_1.create_window((170,380), window=label_intro)
        canvas_pilot_1.create_window((170,540), window=label_contacto)
        canvas_pilot_1.create_window((170,590), window=label_frase_pilot)
        
        # Función para actualizar el área de desplazamiento del canvas
        def update_scrollregion(event=None):
            bbox = canvas_pilot.bbox("all")  # Obtener las coordenadas de todo el contenido
            if bbox:
        # Ajustar el área de desplazamiento añadiendo márgenes
                canvas_pilot.config(scrollregion=(0, 0, bbox[2] + 50, bbox[3] + 10))
        
        # Llamar a update_scrollregion para ajustar el área de desplazamiento
        canvas_pilot.bind("<Configure>", update_scrollregion)
        
        # Función para actualizar el área de desplazamiento del canvas
        def update_scrollregion(event=None):
            bbox = canvas_pilot_1.bbox("all")  # Obtener las coordenadas de todo el contenido
            if bbox:
        # Ajustar el área de desplazamiento añadiendo márgenes
                canvas_pilot_1.config(scrollregion=(0, 0, bbox[2] + 50, bbox[3] + 10))
        
        # Llamar a update_scrollregion para ajustar el área de desplazamiento
        canvas_pilot_1.bind("<Configure>", update_scrollregion)
        
        # Asignar la función de cerrar la ventana cuando se cierre
        ventana_Pilot.protocol("WM_DELETE_WINDOW", cerrar_ventana_pilot)
    else:
        pass

def cerrar_ventana_pilot():
    global ventana_abierta_pilot
    ventana_abierta_pilot = False
    ventana_Pilot.destroy()  


ventana_abierta_structural = False
ventana_structural = None  

def Abrir_ventana_Detalle_Structural():
    global ventana_abierta_structural, ventana_structural,canvas_panel_2,entry_base,entry_altura,canvas_panel_3

    # Solo abrir la ventana si no está abierta ya
    if not ventana_abierta_structural:
        # Crear una nueva ventana de tipo Toplevel
        ventana_structural = tk.Toplevel()

        # Configurar la ventana para que no se pueda redimensionar
        ventana_structural.resizable(False, False)

        # Asegurar que la ventana esté siempre en el frente
        ventana_structural.attributes('-topmost', True)

        # Establecer un tamaño para la ventana
        ventana_structural.geometry('900x550')

        # Agregar un título a la ventana
        ventana_structural.title("Panel modelado 3D")
        
        # Crear contenido 
        labelframe_panel_opciones = tk.LabelFrame(ventana_structural,text="")
        labelframe_panel_opciones.place(x=20,y=10,width=860,height=490)
        
        labelframe_panel_opciones_1 = tk.LabelFrame(labelframe_panel_opciones,text="")
        labelframe_panel_opciones_1.place(x=20,y=20,width=350,height=80)
        
        # Crear el Notebook
        Notebook_panel = ttk.Notebook(labelframe_panel_opciones_1,style="CustomNotebook.TNotebook")  
        
        # Crear una pestaña dentro del Notebook
        tab_panel = ttk.Frame(Notebook_panel)  
        
        # Agregar la pestaña al Notebook 
        Notebook_panel.add(tab_panel, text="Panel de opciones")
        
        # Empaquetar el Notebook en el LabelFrame
        Notebook_panel.pack(fill="both", expand=True)
        
        # Función para redimensionar la imagen
        def redimensionar_imagen(ruta_imagen, tamano):
        # Abrir la imagen
            imagen = Image.open(ruta_imagen)  
        # Redimensionar la imagen
            imagen = imagen.resize(tamano)  
        # Convertirla a un formato que Tkinter pueda usar
            return ImageTk.PhotoImage(imagen)
        
        # Cargar las imágenes de los iconos redimensionadas
        icon_1 = redimensionar_imagen("Iconos_proyecto/Flexion_VG.png", (35, 35))
        icon_2 = redimensionar_imagen("Iconos_proyecto/Armado_viga.png", (35, 35))
        icon_3 = redimensionar_imagen("Iconos_proyecto/3D_panel.png", (35, 35))
        
        
        boton_seccion_panel_1 = ttk.Button(tab_panel,image=icon_1,command=dibujar_seccion_transversal_viga)
        boton_seccion_panel_1.place(x=10,y=1,width=45 ,height=45)
        
        boton_seccion_panel_2 = ttk.Button(tab_panel,image=icon_2,command=dibujar_refuerzo_viga)
        boton_seccion_panel_2.place(x=80,y=1,width=45 ,height=45)
        
        boton_seccion_panel_3 = ttk.Button(tab_panel,image=icon_3,command=Dibujar_Modelo_3D)
        boton_seccion_panel_3.place(x=150,y=1,width=45 ,height=45)
        
        boton_seccion_panel_1.image = icon_1
        boton_seccion_panel_2.image = icon_2
        boton_seccion_panel_3.image = icon_3
        
        labelframe_panel_opciones_2 = tk.LabelFrame(labelframe_panel_opciones,text="")
        labelframe_panel_opciones_2.place(x=20,y=115,width=350,height=350)
        
        # Crear el Notebook
        Notebook_panel_2 = ttk.Notebook(labelframe_panel_opciones_2,style="CustomNotebook.TNotebook")  
        
        # Crear una pestaña dentro del Notebook
        tab_panel_2 = ttk.Frame(Notebook_panel_2)  
        
        # Agregar la pestaña al Notebook 
        Notebook_panel_2.add(tab_panel_2, text="Sección transversal")
        
        # Empaquetar el Notebook en el LabelFrame
        Notebook_panel_2.pack(fill="both", expand=True)
        
        canvas_panel_2 = tk.Canvas(tab_panel_2,bd=2,relief="flat",bg="white")
        canvas_panel_2.pack(fill="both", expand=True)
        
        labelframe_panel_opciones_3 = tk.LabelFrame(labelframe_panel_opciones,text="")
        labelframe_panel_opciones_3.place(x=380,y=20 ,width=455,height=445)
        
        # Crear el Notebook
        Notebook_panel_3 = ttk.Notebook(labelframe_panel_opciones_3,style="CustomNotebook.TNotebook")  
        
        # Crear una pestaña dentro del Notebook
        tab_panel_3 = ttk.Frame(Notebook_panel_3)  
        
        # Agregar la pestaña al Notebook 
        Notebook_panel_3.add(tab_panel_3, text="Modelo 3D")
        
        # Empaquetar el Notebook en el LabelFrame
        Notebook_panel_3.pack(fill="both", expand=True)
        
        canvas_panel_3 = tk.Canvas(tab_panel_3,bg="white")
        canvas_panel_3.pack(fill="both", expand=True)
        
        #Crear botones ventana
        boton_aceptar_pilot = ttk.Button(ventana_structural,text="Aceptar",command=guardar_imagen_pilot)
        boton_aceptar_pilot.place(x=300,y=510,width=100)
        
        boton_cancelar_pilot = ttk.Button(ventana_structural,text="Cancelar",command=cerrar_ventana_1)
        boton_cancelar_pilot.place(x=500,y=510,width=100)
        
        # Marcar que la ventana está abierta
        ventana_abierta_structural = True

        # Cuando la ventana se cierre, marcar que no está abierta
        ventana_structural.protocol("WM_DELETE_WINDOW", cerrar_ventana_1)

def cerrar_ventana_1():
    global ventana_abierta_structural
    ventana_abierta_structural = False
    ventana_structural.destroy()

# Variable global para controlar si la ventana está abierta o no
ventana_abierta_3D = False  
ventana_3D = None  # Variable para la ventana Toplevel

# Función para abrir la ventana 3D
def Dibujar_Modelo_3D():
    global ventana_3D, ventana_abierta_3D,entry_ancho_3D,entry_altura_3D,entry_recubrimiento_3D,entry_Luz_3D,canvas_panel_3 
    global combo_estribos,combo_num_estribo,entry_n_estribo,entry_tramos_separacion,treeview_estribos,combo_n_barra,entry_diametro_b
    global combo_n_barra_sup,entry_diametro_b_sup,entry_barra_n,entry_barra_n_sup,check_drawbar_var
    
    if not ventana_abierta_3D: 
        ventana_3D = tk.Toplevel()  
        ventana_3D.title("Modelo 3D")  
        ventana_3D.geometry('610x430')  
        ventana_3D.resizable(False, False)  
        ventana_3D.attributes('-topmost', True)  
        
        labelframe_3D = tk.LabelFrame(ventana_3D,text="")
        labelframe_3D.place(x=20,y=20,width=570,height=360)
        
        frame_3D_2 = tk.Frame(labelframe_3D,bd=2,relief="raised")
        frame_3D_2.place(x=30,y=25,width=510,height=300)
        
        # Crear el Notebook
        Notebook_3D = ttk.Notebook(frame_3D_2,style="CustomNotebook.TNotebook")  
        
        # Crear una pestaña dentro del Notebook
        tab_3D = ttk.Frame(Notebook_3D) 
        tab_3D_1 = ttk.Frame(Notebook_3D)
        tab_3D_2 = ttk.Frame(Notebook_3D)
        
        # Agregar la pestaña al Notebook 
        Notebook_3D.add(tab_3D, text="Geometría")
        Notebook_3D.add(tab_3D_1, text="Estribos")
        Notebook_3D.add(tab_3D_2, text="Barras - Longitudinal")
        
        # Empaquetar el Notebook en el LabelFrame
        Notebook_3D.pack(fill="both", expand=True)
        
        # Agregar contenigo
        labelframe_geometria = tk.LabelFrame(tab_3D, text="Geometría")
        labelframe_geometria.place(x=10,y=1,width=485,height=260)
        
        check_geometria_var = tk.BooleanVar()
        check_geometria_3D = tk.Checkbutton(labelframe_geometria, text="Ver parámetros geométricos", variable=check_geometria_var,
                                        command=Ver_parametros_viga)
        check_geometria_3D.place(x=10,y=10)
        
        labelframe_parametros_3D = tk.LabelFrame(labelframe_geometria,text="Parámetros geométricos [m]")
        labelframe_parametros_3D.place(x=10,y=40,width=200,height=190)
        
        label_ancho_3D = tk.Label(labelframe_parametros_3D,text="Ancho [b]:")
        label_ancho_3D.place(x=10,y=10)
        
        entry_ancho_3D = tk.Entry(labelframe_parametros_3D)
        entry_ancho_3D.place(x=80,y=10,width=100)
        
        label_altura_3D = tk.Label(labelframe_parametros_3D,text="Altura [h]:")
        label_altura_3D.place(x=10,y=50)
        
        entry_altura_3D = tk.Entry(labelframe_parametros_3D)
        entry_altura_3D.place(x=80,y=50,width=100)
        
        label_recubrimiento_3D = tk.Label(labelframe_parametros_3D,text="Capa [r]:")
        label_recubrimiento_3D.place(x=10,y=90)
        
        entry_recubrimiento_3D = tk.Entry(labelframe_parametros_3D)
        entry_recubrimiento_3D.place(x=80,y=90,width=100)
        
        label_Luz_3D = tk.Label(labelframe_parametros_3D,text="Longitud [L]:")
        label_Luz_3D.place(x=5,y=130)
        
        entry_Luz_3D = tk.Entry(labelframe_parametros_3D)
        entry_Luz_3D.place(x=80,y=130,width=100)
        
        frame_img_3D = tk.Frame(labelframe_geometria,bd=3,relief="ridge",bg="white")
        frame_img_3D.place(x=240,y=46,width=200,height=184)
        
        # Cargar la imagen usando Pillow
        Image_viga_3D = "Iconos_proyecto/esquema_3D.png"  
        img_viga_3D = Image.open(Image_viga_3D)  
        img_viga_3D = img_viga_3D.resize((200, 200))  
        img_viga_3D = ImageTk.PhotoImage(img_viga_3D)  
        
        # Mostrar la imagen en el frame
        label_img_3D = Label(frame_img_3D, image=img_viga_3D)  
        label_img_3D.image = img_viga_3D  
        label_img_3D.pack(fill="both", expand=True)  
        
        check_modelo_var = tk.BooleanVar()
        check_modelo_3D = tk.Checkbutton(labelframe_geometria, text="Dibujar modelo paramétrico", variable=check_modelo_var,
                                    command=actualizar_viga)
        check_modelo_3D.place(x=240,y=10)
        
        canvas_estribos_3D = tk.Canvas(tab_3D_1)
        canvas_estribos_3D.pack(fill="both", expand=True)
        
        canvas_barras_3D = tk.Canvas(tab_3D_2)
        canvas_barras_3D.pack(fill="both", expand=True)
        
        #Crear el Scrollbar vertical
        scrollbar_barras = tk.Scrollbar(tab_3D_2, orient="vertical",command=canvas_barras_3D.yview)
        scrollbar_barras.place(x=480, y=0, width=20, height=265)
        
        #Crear el Scrollbar vertical
        scrollbar_3D = tk.Scrollbar(tab_3D_1, orient="vertical",command=canvas_estribos_3D.yview)
        scrollbar_3D.place(x=480, y=0, width=20, height=265)
        
        # Vincular el Scrollbar vertical al Canvas
        canvas_barras_3D.config(yscrollcommand=scrollbar_barras.set)
        
        # Vincular el Scrollbar vertical al Canvas
        canvas_estribos_3D.config(yscrollcommand=scrollbar_3D.set)
        
        labelframe_estribos_3D = tk.LabelFrame(canvas_estribos_3D,text="Estribos")
        
        check_estribo_var = tk.BooleanVar()
        checkbutton_estribo_5 = tk.Checkbutton(labelframe_estribos_3D,text="Distancia del primer estribo / apoyo",variable=check_estribo_var,
                                            )
        checkbutton_estribo_5.place(x=10,y=10)
        
        entry_estribo_5 = tk.Entry(labelframe_estribos_3D)
        entry_estribo_5.place(x=270,y=15,width=100)
        entry_estribo_5.insert(0, "0.05")
        entry_estribo_5.config(state="disabled")
        
        labelframe_tramos = tk.LabelFrame(labelframe_estribos_3D,text="Tramos")
        labelframe_tramos.place(x=20,y=40,width=415,height=80)
        
        label_tramos = tk.Label(labelframe_tramos,text="#Tramos:")
        label_tramos.place(x=10,y=15)
        
        # Crear el Combobox con la lista de datos
        combo_estribos = ttk.Combobox(labelframe_tramos, values=[1, 2, 3])
        combo_estribos.place(x=70,y=15,width=85)
        combo_estribos.set("Seleccionar")
        
        Label_tramos_separacion = tk.Label(labelframe_tramos,text="Separación:")
        Label_tramos_separacion.place(x=180,y=15)
        
        entry_tramos_separacion = tk.Entry(labelframe_tramos)
        entry_tramos_separacion.place(x=260,y=15,width=85)
        
        labelframe_secciones = tk.LabelFrame(labelframe_estribos_3D,text="Distribución de estribos por secciones de tramos")
        labelframe_secciones.place(x=20,y=130,width=415,height=220)
        
        # Ruta de la imagen
        ruta_imagen_3D = "Iconos_proyecto/check_estribos.png"
        
        # Cargar la imagen con Pillow
        imagen_original_3D = Image.open(ruta_imagen_3D)
        
        # Redimensionar la imagen para que ocupe todo el tamaño del botón (25x25)
        imagen_redimensionada_3D = imagen_original_3D.resize((16, 16), Image.Resampling.LANCZOS)
        
        # Convertir la imagen a PhotoImage para usarla en Tkinter
        imagen_fig_3D = ImageTk.PhotoImage(imagen_redimensionada_3D)
        
        # Crear el botón y asignar la imagen
        Button_verificar = ttk.Button(labelframe_secciones, image=imagen_fig_3D,command=distribución_estribos)
        Button_verificar.place(x=360, y=8, width=25, height=25)
        
        # Mantener la referencia a la imagen para evitar que se elimine
        Button_verificar.image = imagen_fig_3D
        
        label_num_estribo = tk.Label(labelframe_secciones,text="Estribo:")
        label_num_estribo.place(x=10,y=10)
        
        combo_num_estribo = ttk.Combobox(labelframe_secciones, values=["#2","#3","#4"])
        combo_num_estribo.place(x=70,y=10,width=85)
        combo_num_estribo.set("Seleccionar")
        
        label_n_estribo = tk.Label(labelframe_secciones,text="#Estribos [n]:")
        label_n_estribo.place(x=180,y=10)
        
        entry_n_estribo = tk.Entry(labelframe_secciones)
        entry_n_estribo.place(x=260,y=10,width=85)
        
        # Crear el primer Treeview 
        treeview_estribos = ttk.Treeview(labelframe_secciones,columns=("Secciones","Tramo 1", "Tramo 2", "Tramo 3"), show="headings")
        treeview_estribos.place(x=20,y=50,width=355,height=100)
        
        # Definir los encabezados de las columnas
        treeview_estribos.heading("Secciones", text="Secciones")
        treeview_estribos.heading("Tramo 1", text="Tramo 1")
        treeview_estribos.heading("Tramo 2", text="Tramo 2")
        treeview_estribos.heading("Tramo 3", text="Tramo 3")
        
        # Modificar el ancho de las columnas
        treeview_estribos.column("Secciones", width=87, stretch=False, anchor="center")
        treeview_estribos.column("Tramo 1", width=87, stretch=False, anchor="center")
        treeview_estribos.column("Tramo 2", width=87, stretch=False, anchor="center")
        treeview_estribos.column("Tramo 3", width=87, stretch=False, anchor="center")
        
        # Insertar filas en el Treeview
        treeview_estribos.insert("", "end", values=("#Estribos", "", "", ""))
        treeview_estribos.insert("", "end", values=("#Ramas", "", "", ""))
        treeview_estribos.insert("", "end", values=("Separación (m)", "", "", ""))
        
        # Función para restaurar el tamaño de las columnas después de intentar redimensionar
        def no_resize(event):
            treeview_estribos.column("Secciones", width=87, stretch=False, anchor="center")
            treeview_estribos.column("Tramo 1", width=87, stretch=False, anchor="center")
            treeview_estribos.column("Tramo 2", width=87, stretch=False, anchor="center")
            treeview_estribos.column("Tramo 3", width=87, stretch=False, anchor="center")
        
        # Vincular el evento de ButtonRelease-1 para evitar el redimensionamiento
        treeview_estribos.bind("<ButtonRelease-1>", no_resize)
        
        check_draw_var = tk.BooleanVar()
        checkbutton_draw_estribos = tk.Checkbutton(labelframe_secciones,text="Dibujar confinamiento transversal",variable=check_draw_var,
                                    command=dibujar_confinamiento_estribos)
        checkbutton_draw_estribos.place(x=10,y=170)
        
        labelframe_barras_long = tk.LabelFrame(tab_3D_2,text="Barras - Longitudinal")
        labelframe_ref_inferior = tk.LabelFrame(labelframe_barras_long,text="Refuerzo Inferior")
        labelframe_ref_inferior.place(x=10,y=10,width=435,height=200)
        label_n_barra = tk.Label(labelframe_ref_inferior,text="#Barra:")
        label_n_barra.place(x=10,y=10)
        combo_n_barra = ttk.Combobox(labelframe_ref_inferior, values=["#2","#3","#4","#5","#6","#7","#8","#9","#10","#11","#14","#18"])
        combo_n_barra.place(x=70,y=10,width=85)
        combo_n_barra.set("Seleccionar")
        combo_n_barra.bind("<<ComboboxSelected>>", actualizacion_diametro_barras)
        label_material_barra = tk.Label(labelframe_ref_inferior,text="Material:")
        label_material_barra.place(x=180,y=10)
        combo_material = ttk.Combobox(labelframe_ref_inferior, values=["420 Mpa"])
        combo_material.place(x=240,y=10,width=85)
        combo_material.set("Seleccionar")
        label_barras_n = tk.Label(labelframe_ref_inferior,text="#Barras [n]:")
        label_barras_n.place(x=5,y=50)
        entry_barra_n = tk.Entry(labelframe_ref_inferior)
        entry_barra_n.place(x=70,y=50,width=85)
        label_diametro_b = tk.Label(labelframe_ref_inferior,text="ØBarra:")
        label_diametro_b.place(x=180,y=50)
        entry_diametro_b = tk.Entry(labelframe_ref_inferior)
        entry_diametro_b.place(x=240,y=50,width=85)
        
        #Colocar barras inferior
        var_ext_bar = tk.IntVar()
        radiobutton_ext_bar = tk.Radiobutton(labelframe_ref_inferior,text="Extender barras inferior principal",variable=var_ext_bar,value=1)
        radiobutton_ext_bar.place(x=10,y=90)
        #Colocar ganchos de 90°
        var_gancho_bar = tk.IntVar()
        radiobutton_gancho_inf = tk.Radiobutton(labelframe_ref_inferior,text="Colocar gancho de 90°",variable=var_gancho_bar,value=1)
        radiobutton_gancho_inf.place(x=10,y=130)
        
        labelframe_ref_superior = tk.LabelFrame(labelframe_barras_long,text="Refuerzo Superior")
        labelframe_ref_superior.place(x=10,y=220,width=435,height=200)
        label_n_barra_sup = tk.Label(labelframe_ref_superior,text="#Barra:")
        label_n_barra_sup.place(x=10,y=10)
        combo_n_barra_sup = ttk.Combobox(labelframe_ref_superior, values=["#2","#3","#4","#5","#6","#7","#8","#9","#10","#11","#14","#18"])
        combo_n_barra_sup.place(x=70,y=10,width=85)
        combo_n_barra_sup.set("Seleccionar")
        combo_n_barra_sup.bind("<<ComboboxSelected>>", actualizacion_diametro_barras)
        label_material_barra_sup = tk.Label(labelframe_ref_superior,text="Material:")
        label_material_barra_sup.place(x=180,y=10)
        combo_material_sup = ttk.Combobox(labelframe_ref_superior, values=["420 Mpa"])
        combo_material_sup.place(x=240,y=10,width=85)
        combo_material_sup.set("Seleccionar")
        label_barras_n_sup = tk.Label(labelframe_ref_superior,text="#Barras [n]:")
        label_barras_n_sup.place(x=5,y=50)
        entry_barra_n_sup = tk.Entry(labelframe_ref_superior)
        entry_barra_n_sup.place(x=70,y=50,width=85)
        label_diametro_b_sup = tk.Label(labelframe_ref_superior,text="ØBarra:")
        label_diametro_b_sup.place(x=180,y=50)
        entry_diametro_b_sup = tk.Entry(labelframe_ref_superior)
        entry_diametro_b_sup.place(x=240,y=50,width=85)
        
        #Colocar barras superior
        var_ext_bar_sup = tk.IntVar()
        radiobutton_ext_bar_sup = tk.Radiobutton(labelframe_ref_superior,text="Extender barras superior principal",variable=var_ext_bar_sup,value=1)
        radiobutton_ext_bar_sup.place(x=10,y=90)
        #Colocar ganchos de 90° superior
        var_gancho_bar_sup = tk.IntVar()
        radiobutton_gancho_sup = tk.Radiobutton(labelframe_ref_superior,text="Colocar gancho de 90°",variable=var_gancho_bar_sup,value=1)
        radiobutton_gancho_sup.place(x=10,y=130)
        
        check_drawbar_var = tk.BooleanVar()
        checkbutton_estribo_5 = tk.Checkbutton(labelframe_barras_long,text="Dibujar barras longitudinal",variable=check_drawbar_var,
                                command=Dibujar_barras_longitudinal)
        checkbutton_estribo_5.place(x=10,y=435)
                
        entry_barra_n.bind("<KeyRelease>", actualizar_entradas_barras)  
        entry_barra_n_sup.bind("<KeyRelease>", actualizar_entradas_barras)  
        
        boton_3D_cancelar = ttk.Button(ventana_3D,text="Cancelar",command=cerrar_ventana_3D)
        boton_3D_cancelar.place(x=240,y=390,width=100)
        
        canvas_estribos_3D.create_window((240,210), window=labelframe_estribos_3D,width=460,height=400)
        canvas_barras_3D.create_window((240,260), window=labelframe_barras_long,width=460,height=500)
        
        # Cuando se cierra la ventana, reiniciar la variable de control
        ventana_3D.protocol("WM_DELETE_WINDOW", cerrar_ventana_3D)  # Captura del evento de cierre de ventana
        
        # Función para actualizar el área de desplazamiento del canvas
        def update_scrollregion(event=None):
            bbox = canvas_barras_3D.bbox("all")  # Obtener las coordenadas de todo el contenido
            if bbox:
        # Ajustar el área de desplazamiento añadiendo márgenes
                canvas_barras_3D.config(scrollregion=(0, 0, bbox[2] + 50, bbox[3] + 10))
        
        # Llamar a update_scrollregion para ajustar el área de desplazamiento
        canvas_barras_3D.bind("<Configure>", update_scrollregion)
        
        
        # Función para actualizar el área de desplazamiento del canvas
        def update_scrollregion(event=None):
            bbox = canvas_estribos_3D.bbox("all")  # Obtener las coordenadas de todo el contenido
            if bbox:
        # Ajustar el área de desplazamiento añadiendo márgenes
                canvas_estribos_3D.config(scrollregion=(0, 0, bbox[2] + 50, bbox[3] + 10))
        
        # Llamar a update_scrollregion para ajustar el área de desplazamiento
        canvas_estribos_3D.bind("<Configure>", update_scrollregion)
        
        # Marcar la ventana como abierta
        ventana_abierta_3D = True

# Función para cerrar la ventana 3D
def cerrar_ventana_3D():
    global ventana_3D, ventana_abierta_3D
    if ventana_3D:  
        ventana_3D.destroy()  
        ventana_abierta_3D = False  
        ventana_3D = None  

def actualizacion_diametro_barras(event):
    # Mapeo de las barras y sus diámetros en milímetros
    diametros_barra = {
        "#2": 6.4,
        "#3": 9.5,
        "#4": 12.7,
        "#5": 15.9,
        "#6": 19.1,
        "#7": 22.2,
        "#8": 25.4,
        "#9": 28.7,
        "#10": 32.3,
        "#11": 35.8,
        "#14": 43.0,
        "#18": 57.3
    }
    
    # Obtener el valor seleccionado del ComboBox
    seleccion_barra = combo_n_barra.get()
    seleccion_superior = combo_n_barra_sup.get()  
    
    # Actualizar el valor del Entry con el diámetro correspondiente
    if seleccion_barra in diametros_barra:
        entry_diametro_b.delete(0, tk.END)  # Limpiar el Entry antes de actualizar
        entry_diametro_b.insert(0, f"{diametros_barra[seleccion_barra]} mm")
    # Actualizar el valor del Entry correspondiente al ComboBox superior
    if seleccion_superior in diametros_barra:
        entry_diametro_b_sup.delete(0, tk.END)  # Limpiar el Entry antes de actualizar
        entry_diametro_b_sup.insert(0, f"{diametros_barra[seleccion_superior]} mm")  

def actualizar_entradas_barras(*args):
    # Obtener los datos de los Entry
    valor_inferior = entry_barra_n.get()  # Valor de entry_barra_n
    valor_superior = entry_barra_n_sup.get()  # Valor de entry_barra_n_sup
    
    # Actualizar los valores en los Entry correspondientes
    entry_barras_inferior.delete(0, tk.END)  # Limpiar el Entry antes de actualizar
    entry_barras_inferior.insert(0, valor_inferior)  # Insertar el valor de entry_barra_n
    
    entry_barras_superior.delete(0, tk.END)  # Limpiar el Entry antes de actualizar
    entry_barras_superior.insert(0, valor_superior)  # Insertar el valor de entry_barra_n_sup

def distribución_estribos():
    # Obtener valores de los widgets
    opcion_dis_1 = combo_estribos.get()
    tipo_estribo_dis = combo_num_estribo.get()
    num_estribo_dis_1 = entry_n_estribo.get()
    separacion_dis_1 = entry_tramos_separacion.get()

    if not (opcion_dis_1 and tipo_estribo_dis and num_estribo_dis_1 and separacion_dis_1):
        return  # No hacer nada si hay campos vacíos

    opcion_dis_1 = int(opcion_dis_1)
    numero_ramas_E = 2  # Valor fijo de número de ramas

    # Obtener los identificadores de las filas existentes
    filas = treeview_estribos.get_children()
    valores_actuales = {fila: list(treeview_estribos.item(fila, "values")) for fila in filas}

    # Actualizar solo la columna seleccionada
    columna = opcion_dis_1
    valores_actuales[filas[0]][columna] = f"{num_estribo_dis_1}E{tipo_estribo_dis}"
    valores_actuales[filas[1]][columna] = numero_ramas_E
    valores_actuales[filas[2]][columna] = separacion_dis_1

    for fila, valores in valores_actuales.items():
        treeview_estribos.item(fila, values=valores)

    #  ACTUALIZAR LOS ENTRY EN labelframe_reporte 
    if opcion_dis_1 == 1:
        entry_tramo_1.delete(0, tk.END)
        entry_tramo_1.insert(0, num_estribo_dis_1)
        entry_tramo_1_S.delete(0, tk.END)
        entry_tramo_1_S.insert(0, separacion_dis_1)
    
    elif opcion_dis_1 == 2:
        entry_tramo_2.delete(0, tk.END)
        entry_tramo_2.insert(0, num_estribo_dis_1)
        entry_tramo_2_S.delete(0, tk.END)
        entry_tramo_2_S.insert(0, separacion_dis_1)
    
    elif opcion_dis_1 == 3:
        entry_tramo_3.delete(0, tk.END)
        entry_tramo_3.insert(0, num_estribo_dis_1)
        entry_tramo_3_S.delete(0, tk.END)
        entry_tramo_3_S.insert(0, separacion_dis_1)


# Función para obtener los datos y actualizar los entrys
def Ver_parametros_viga():
    # Obtener los valores de los Entry del labelframe_reporte
    base_parametro = entry_prueba_seccion_base.get()
    altura_parametro = entry_prueba_seccion_altura.get()
    recubrimiento_parametro = entry_prueba_seccion_recubrimiento.get()
    longitud_parametro = entry_prueba_longitud.get()
    
    # Actualizar los valores de los Entry correspondientes en la ventana 3D
    entry_ancho_3D.delete(0, tk.END)  # Limpiar el Entry antes de poner el nuevo valor
    entry_ancho_3D.insert(0, base_parametro)  # Actualizar con el valor de base_parametro
    
    entry_altura_3D.delete(0, tk.END)
    entry_altura_3D.insert(0, altura_parametro)  # Actualizar con el valor de altura_parametro
    
    entry_recubrimiento_3D.delete(0, tk.END)
    entry_recubrimiento_3D.insert(0, recubrimiento_parametro)  # Actualizar con el valor de recubrimiento_parametro
    
    entry_Luz_3D.delete(0, tk.END)
    entry_Luz_3D.insert(0, longitud_parametro)  # Actualizar con el valor de longitud_parametro


# Variables globales para almacenar la figura y el canvas
fig = None
ax = None
canvas = None

def dibujar_viga(base_3D, altura_3D, longitud_3D, canvas_panel_3):
    """
    Dibuja una viga con las dimensiones especificadas y muestra la figura en el canvas de Tkinter.
    """
    global fig, ax, canvas
    # Crear la figura y el eje 3D
    fig = plt.figure()
    ax = fig.add_subplot(111, projection='3d')

    color_lineas_poligono = 'grey'

    # Función para dibujar un polígono con sombreado
    def dibujar_poligono(vertices, color='grey', color_lineas='grey'):
        poligono = Poly3DCollection([vertices], color=color, edgecolor=color_lineas, alpha=0.3)
        ax.add_collection3d(poligono)

    # Definir las caras de la viga
    offset_x = base_3D / 2
    caras = [
        [[-offset_x, 0, 0], [offset_x, 0, 0], [offset_x, longitud_3D, 0], [-offset_x, longitud_3D, 0]],
        [[-offset_x, 0, altura_3D], [offset_x, 0, altura_3D], [offset_x, longitud_3D, altura_3D], [-offset_x, longitud_3D, altura_3D]],
        [[-offset_x, 0, 0], [-offset_x, 0, altura_3D], [-offset_x, longitud_3D, altura_3D], [-offset_x, longitud_3D, 0]],
        [[offset_x, 0, 0], [offset_x, 0, altura_3D], [offset_x, longitud_3D, altura_3D], [offset_x, longitud_3D, 0]]
    ]
    for cara in caras:
        dibujar_poligono(cara)

    ax.set_xlabel(f'Base ({base_3D} m)')  
    ax.set_ylabel(f'Longitud ({longitud_3D} m)')  
    ax.set_zlabel(f'Altura ({altura_3D} m)')  

    # Ajustar la proporción de la caja y los límites de los ejes
    ax.set_box_aspect([1, longitud_3D / base_3D, altura_3D / base_3D])  
    ax.set_xlim([-offset_x, offset_x])  
    ax.set_ylim([0, longitud_3D])  
    ax.set_zlim([0, altura_3D])  

    ax.set_xticks([])  
    ax.set_yticks([])  
    ax.set_zticks([])  

    # Mostrar la figura en el Canvas de Tkinter usando FigureCanvasTkAgg
    canvas = FigureCanvasTkAgg(fig, master=canvas_panel_3)
    canvas.get_tk_widget().pack(fill="both", expand=True)
    canvas.draw()

    # Cerrar la figura después de renderizarla para liberar memoria
    plt.close(fig)

# Función para obtener los valores de los Entry
def obtener_valores_entry():
    global longitud_3D, altura_3D, base_3D, tramo1, tramo2, tramo3, desfase_estribo
    # Aquí se pueden obtener los valores de los Tkinter Entry, por ejemplo:
    longitud_3D = float(entry_prueba_longitud.get())  # Obtiene el valor de longitud
    altura_3D = float(entry_prueba_seccion_altura.get())  # Obtiene el valor de altura
    base_3D = float(entry_prueba_seccion_base.get())  # Obtiene el valor de base
    tramo1 = (int(entry_tramo_1.get()), float(entry_tramo_1_S.get()))  # Obtiene los valores del tramo 1
    tramo2 = (int(entry_tramo_2.get()), float(entry_tramo_2_S.get()))  # Obtiene los valores del tramo 2
    tramo3 = (int(entry_tramo_3.get()), float(entry_tramo_3_S.get()))  # Obtiene los valores del tramo 3
    
    # Captura el valor del desfase (recubrimiento) desde el Entry
    desfase_estribo = float(entry_prueba_seccion_recubrimiento.get())

# Lista para almacenar las líneas de los estribos
estribos_lines = []

# Función para dibujar una línea 3D (esto se usa para dibujar los estribos)
def dibujar_linea(x, y, z, color='black'):
    line = ax.plot3D(x, y, z, color=color)
    return line

# Función para dibujar estribos correctamente en ambas caras y almacenar las líneas
def dibujar_estribos_ref(inicio, n_estribos, separacion, color, cara, offset_x):
    global estribos_lines
    
    for i in range(n_estribos):
        posicion = inicio + i * separacion
        if posicion > longitud_3D:
            break  # Evita dibujar fuera de la viga
        
        # Dibujar y almacenar las líneas de estribos
        if cara == 'izquierda':
            line1 = dibujar_linea([-offset_x + desfase_estribo, offset_x - desfase_estribo], [posicion, posicion], [desfase_estribo, desfase_estribo], color=color)
            line2 = dibujar_linea([-offset_x + desfase_estribo, offset_x - desfase_estribo], [posicion, posicion], [altura_3D - desfase_estribo, altura_3D - desfase_estribo], color=color)
            line3 = dibujar_linea([-offset_x + desfase_estribo, -offset_x + desfase_estribo], [posicion, posicion], [desfase_estribo, altura_3D - desfase_estribo], color=color)
            line4 = dibujar_linea([offset_x - desfase_estribo, offset_x - desfase_estribo], [posicion, posicion], [desfase_estribo, altura_3D - desfase_estribo], color=color)
        elif cara == 'derecha':
            line1 = dibujar_linea([-offset_x + desfase_estribo, offset_x - desfase_estribo], [longitud_3D - posicion, longitud_3D - posicion], [desfase_estribo, desfase_estribo], color=color)
            line2 = dibujar_linea([-offset_x + desfase_estribo, offset_x - desfase_estribo], [longitud_3D - posicion, longitud_3D - posicion], [altura_3D - desfase_estribo, altura_3D - desfase_estribo], color=color)
            line3 = dibujar_linea([-offset_x + desfase_estribo, -offset_x + desfase_estribo], [longitud_3D - posicion, longitud_3D - posicion], [desfase_estribo, altura_3D - desfase_estribo], color=color)
            line4 = dibujar_linea([offset_x - desfase_estribo, offset_x - desfase_estribo], [longitud_3D - posicion, longitud_3D - posicion], [desfase_estribo, altura_3D - desfase_estribo], color=color)
        
        # Almacenar las líneas en la lista
        estribos_lines.extend([line1, line2, line3, line4])

# Función para limpiar los estribos previos
def limpiar_estribos():
    global estribos_lines
    for line in estribos_lines:
        line[0].remove()  # Elimina cada línea almacenada
    estribos_lines = []  # Vaciar la lista de líneas

# Función para dibujar los estribos con las correcciones en ambas caras y actualizar el gráfico
def dibujar_confinamiento_estribos():
    """
    Dibuja el confinamiento transversal dentro del mismo gráfico de la viga, usando los estribos.
    """
    global ax, canvas

    if ax is None or canvas is None:
        return  # No hay gráfico para modificar
    
    # Limpiar los estribos previos sin borrar la figura 3D
    limpiar_estribos()

    # Llamamos a la función para obtener los valores actualizados de los Entry
    obtener_valores_entry()

    # Calcular inicios correctos de los tramos sin superposición
    inicio_tramo1 = 0.05
    inicio_tramo2 = inicio_tramo1 + tramo1[0] * tramo1[1]
    mitad_viga = longitud_3D / 2
    posiciones_tramo3 = np.linspace(mitad_viga - (tramo3[0] - 1) / 2 * tramo3[1],
                                    mitad_viga + (tramo3[0] - 1) / 2 * tramo3[1],
                                    tramo3[0])

    # **Asegúrate de pasar el offset_x en cada llamada**
    offset_x = base_3D / 2  # Calcula el valor de offset_x aquí
    
    # Dibujar los estribos con las correcciones en ambas caras
    dibujar_estribos_ref(inicio_tramo1, tramo1[0], tramo1[1], color='red', cara='izquierda', offset_x=offset_x)
    dibujar_estribos_ref(inicio_tramo2, tramo2[0], tramo2[1], color='darkgreen', cara='izquierda', offset_x=offset_x)
    dibujar_estribos_ref(inicio_tramo1, tramo1[0], tramo1[1], color='red', cara='derecha', offset_x=offset_x)
    dibujar_estribos_ref(inicio_tramo2, tramo2[0], tramo2[1], color='darkgreen', cara='derecha', offset_x=offset_x)

    # Dibujar estribos para el tramo 3
    for pos in posiciones_tramo3:
        dibujar_estribos_ref(pos, 1, 0, color='blue', cara='izquierda', offset_x=offset_x)
        dibujar_estribos_ref(pos, 1, 0, color='blue', cara='derecha', offset_x=offset_x)

    # Actualizar la figura
    canvas.draw()

# Lista para almacenar las líneas de las barras longitudinales
barras_lines = []

def dibujar_linea(x, y, z, color='blue', grosor=1):
    """Dibuja una línea en el gráfico 3D"""
    line = ax.plot3D(x, y, z, color=color, linewidth=grosor)
    return line

def dibujar_gancho(x, y, z, color='grey', direccion='abajo'):
    """Dibuja un gancho en un nodo específico."""
    longitud_gancho = 0.15  

    if direccion == 'abajo':
        ax.plot([x, x], [y, y], [z, z - longitud_gancho], color=color, linewidth=2)  
    elif direccion == 'arriba':
        ax.plot([x, x], [y, y], [z, z + longitud_gancho], color=color, linewidth=2)  

def Dibujar_barras_longitudinal():
    """
    Dibuja las barras longitudinales en el gráfico 3D
    cuando se activa el checkbutton correspondiente.
    """
    global ax, canvas, barras_lines
    
    if ax is None or canvas is None:
        return  # Evita errores si no hay un gráfico activo

    # Verifica si el Checkbutton está activo
    if check_drawbar_var.get() == 0:
        limpiar_barras()
        return
    
    # Obtener valores de entrada
    longitud_3D = float(entry_prueba_longitud.get())
    altura_3D = float(entry_prueba_seccion_altura.get())
    base_3D = float(entry_prueba_seccion_base.get())
    desfase_estribo = float(entry_prueba_seccion_recubrimiento.get())

    n_barras_sup = int(entry_barras_superior.get())  # Número de barras superiores
    n_barras_inf = int(entry_barras_inferior.get())  # Número de barras inferiores

    # Parámetros de separación
    limite_x_sup_inf = (base_3D / 2) - desfase_estribo
    limite_z_inf = desfase_estribo
    ajuste_sup = desfase_estribo * 0.8  # Ajuste para subir las barras superiores un poco más
    limite_z_sup = altura_3D - desfase_estribo - desfase_estribo + ajuste_sup  # Se sube un poco más

    # Calcular posiciones de las barras superiores e inferiores
    posiciones_barras_x_sup = np.linspace(-limite_x_sup_inf, limite_x_sup_inf, n_barras_sup)
    posiciones_barras_x_inf = np.linspace(-limite_x_sup_inf, limite_x_sup_inf, n_barras_inf)

    # Dibujar barras superiores (con el ajuste en altura)
    for i in range(n_barras_sup):
        x_sup = [posiciones_barras_x_sup[i], posiciones_barras_x_sup[i]]
        y = [0, longitud_3D]  # Extensión a lo largo de la viga
        z_sup = [limite_z_sup, limite_z_sup]  # Se suben un poco más
        barras_lines.append(dibujar_linea(x_sup, y, z_sup, color='black', grosor=2))
        
        # Agregar ganchos en ambas caras
        dibujar_gancho(posiciones_barras_x_sup[i], 0, limite_z_sup, color='black', direccion='abajo')  # Cara inicial
        dibujar_gancho(posiciones_barras_x_sup[i], longitud_3D, limite_z_sup, color='black', direccion='abajo')  # Cara final

        
    # Dibujar barras inferiores (sin cambios)
    for i in range(n_barras_inf):
        x_inf = [posiciones_barras_x_inf[i], posiciones_barras_x_inf[i]]
        y = [0, longitud_3D]
        z_inf = [limite_z_inf, limite_z_inf]
        barras_lines.append(dibujar_linea(x_inf, y, z_inf, color='darkred', grosor=2))
        
        # Agregar ganchos en ambas caras
        dibujar_gancho(posiciones_barras_x_inf[i], 0, limite_z_inf, color='darkred', direccion='arriba')  # Cara inicial
        dibujar_gancho(posiciones_barras_x_inf[i], longitud_3D, limite_z_inf, color='darkred', direccion='arriba')  # Cara final
        
    # Actualizar gráfico
    canvas.draw()

def limpiar_barras():
    """Elimina las barras longitudinales del gráfico"""
    global barras_lines
    for line in barras_lines:
        line[0].remove()
    barras_lines = []
    canvas.draw()


# Función para actualizar la viga con los nuevos datos
def actualizar_viga():
    try:
        # Obtener los valores de los campos de entrada
        base_3D = float(entry_ancho_3D.get())
        altura_3D = float(entry_altura_3D.get())
        longitud_3D = float(entry_Luz_3D.get())
        
        # Limpiar el canvas antes de dibujar la nueva viga
        for widget in canvas_panel_3.winfo_children():
            widget.destroy()
        
        # Llamar a la función para dibujar la viga en el canvas
        dibujar_viga(base_3D, altura_3D, longitud_3D, canvas_panel_3)

    except ValueError:
        print("Error: Ingresa valores numéricos válidos")



# Variable de control para saber si la ventana está abierta
ventana_abierta_dimension = False
ventana_dimension = None  # Esta será la referencia a la ventana, inicializada como None
fig = None
canvas_fig_rect = None

# Función para dibujar la sección transversal de la viga
def dibujar_seccion_transversal_viga():
    global ventana_abierta_dimension, ventana_dimension, entry_altura,entry_r,entry_d,canvas_panel_2,entry_base, fig, canvas_fig_rect,entry_l
    
    if ventana_abierta_dimension:  # Si la ventana ya está abierta, no se abre otra
        return

    # Crear una ventana de Toplevel 
    ventana_dimension = tk.Toplevel()
    ventana_dimension.geometry("300x300")
    ventana_dimension.title("Dimensiones de la viga")
    ventana_dimension.resizable(False, False)
    ventana_dimension.attributes('-topmost', True)
    
    # Crear contenido 
    labelframe_dimension_viga = tk.LabelFrame(ventana_dimension,text="Dimensiones [m]")
    labelframe_dimension_viga.place(x=15,y=15,width=270,height=240)
    
    label_base = tk.Label(labelframe_dimension_viga,text="Ancho:")
    label_base.place(x=30,y=10)
    
    entry_base = tk.Entry(labelframe_dimension_viga)
    entry_base.place(x=100,y=10,width=100)
    
    label_altura = tk.Label(labelframe_dimension_viga,text="Altura:")
    label_altura.place(x=30,y=50)
    
    entry_altura = tk.Entry(labelframe_dimension_viga)
    entry_altura.place(x=100,y=50,width=100)
    
    label_r_viga= tk.Label(labelframe_dimension_viga,text="recubrimiento:")
    label_r_viga.place(x=10,y=90)
    
    entry_r = tk.Entry(labelframe_dimension_viga)
    entry_r.place(x=100,y=90,width=100)
    
    label_d= tk.Label(labelframe_dimension_viga,text="Altura util:")
    label_d.place(x=10,y=130)
    
    entry_d = tk.Entry(labelframe_dimension_viga)
    entry_d.place(x=100,y=130,width=100)
    
    label_l = tk.Label(labelframe_dimension_viga,text="Longitud:")
    label_l.place(x=10,y=170)
    
    entry_l = tk.Entry(labelframe_dimension_viga)
    entry_l.place(x=100,y=170,width=100)
    
    boton_dibujar_seccion = ttk.Button(ventana_dimension,text="Dibujar",command=dibujar_rectangulo_seccion)  
    boton_dibujar_seccion.place(x=30,y=260,width=100)
    
    boton_cancelar_seccion = ttk.Button(ventana_dimension,text="Cancelar",command=cerrar_ventana_viga)  
    boton_cancelar_seccion.place(x=170,y=260,width=100)
    
    
    # Cambiar la variable de control para indicar que la ventana está abierta
    ventana_abierta_dimension = True
    
    # Evento para cerrar la ventana
    ventana_dimension.protocol("WM_DELETE_WINDOW", cerrar_ventana_viga)
    
    # Vincular las entradas de altura y recubrimiento al cálculo de la altura efectiva util
    entry_altura.bind("<KeyRelease>", calcular_altura_efectiva_util)  # Cuando se presiona una tecla en entry_altura
    entry_r.bind("<KeyRelease>", calcular_altura_efectiva_util)  # Cuando se presiona una tecla en entry_r

# Función para cuando se cierre la ventana
def cerrar_ventana_viga():
    global ventana_abierta_dimension, ventana_dimension
    ventana_abierta_dimension = False
    if ventana_dimension:
        ventana_dimension.destroy()


# Función para calcular la altura efectiva util
def calcular_altura_efectiva_util(*args):
    try:
        # Obtener los valores de altura y recubrimiento
        altura_util = float(entry_altura.get())
        recubrimiento_util = float(entry_r.get())
        
        # Calcular la altura efectiva util
        altura_efectiva_util = altura_util - recubrimiento_util
        
        # Actualizar el resultado en entry_d
        entry_d.delete(0, tk.END)  # Borrar el valor anterior
        entry_d.insert(0, f"{altura_efectiva_util:.2f}")  # Insertar el resultado con dos decimales
        
        # Actualizar el valor de recubrimiento_util en entry_prueba_seccion_recubrimiento
        entry_prueba_seccion_recubrimiento.delete(0, tk.END)  # Borrar el valor anterior
        entry_prueba_seccion_recubrimiento.insert(0, f"{recubrimiento_util:.2f}")  # Insertar el recubrimiento
        
    except ValueError:
        # En caso de que no se ingresen números válidos, limpiar el campo d
        entry_d.delete(0, tk.END)
        entry_prueba_seccion_recubrimiento.delete(0, tk.END)


def dibujar_rectangulo_seccion():
    global fig, canvas_fig_rect,combo_seccion_estribo
    
    try:
        base_rect = float(entry_base.get())
        altura_rec = float(entry_altura.get())
        
        # Obtener el dato de entry_l
        longitud_vg = entry_l.get()
        
        if longitud_vg:
            # Actualizar el entry_prueba_longitud con el valor de entry_l
            entry_prueba_longitud.delete(0, tk.END)  # Borrar el contenido actual
            entry_prueba_longitud.insert(0, longitud_vg)  # Insertar el valor de entry_l en entry_prueba_longitud
        
        if fig is not None:
            plt.close(fig)
        
        # Escalar dimensiones (metros a cm o una escala manejable)
        escala = 100  # 1 metro = 100 unidades para mejor visualización
        base_esc = base_rect * escala
        altura_esc = altura_rec * escala
        
        fig, ax = plt.subplots(figsize=(5, 5))
        
        # Dibujar el rectángulo escalado
        ax.add_patch(plt.Rectangle((0, 0), base_esc, altura_esc,edgecolor="none" ,facecolor="gray"))
        
        # Ajustar límites para mantener margen
        ax.set_xlim(-10, base_esc + 10)
        ax.set_ylim(-10, altura_esc + 10)
        
        # Mantener escala igual y ocultar ejes
        ax.set_aspect('equal')
        ax.axis('off')
        
        # Ajustar márgenes para evitar bordes
        plt.subplots_adjust(left=0, right=1, top=1, bottom=0)
        
        # Mostrar en el canvas de Tkinter
        if canvas_fig_rect is not None:
            canvas_fig_rect.get_tk_widget().destroy()

        canvas_fig_rect = FigureCanvasTkAgg(fig, master=canvas_panel_2)
        canvas_fig_rect.draw()
        canvas_fig_rect.get_tk_widget().pack(fill=tk.BOTH, expand=True)
        
        # Actualizar el Entry con el nuevo formato
        entry_prueba_seccion_estribo.delete(0, tk.END)  # Borrar el contenido actual
        entry_prueba_seccion_estribo.insert(0, f'VG {base_rect * 100:.2f} X {altura_rec * 100:.2f}')  
        
        entry_prueba_seccion_base.delete(0, tk.END)  # Borrar el contenido actual
        entry_prueba_seccion_base.insert(0, f'{base_rect}')  
        
        entry_prueba_seccion_altura.delete(0, tk.END)
        entry_prueba_seccion_altura.insert(0, f'{altura_rec}')
        
    except ValueError:
        pass

# Lista para almacenar las barras y leyendas dibujadas
barras_dibujadas = []
leyendas_dibujadas = []

def dibujar_elementos_refuerzo():
    global fig, canvas_fig_rect, entry_prueba_seccion_altura, entry_prueba_seccion_base, entry_prueba_seccion_recubrimiento, entry_numero_1, entry_numero_inferor_1, entry_fila_barra_1, entry_fila_inferior_1, entry_prueba_seccion_estribo, barras_dibujadas, leyendas_dibujadas  
    global entry_prueba_estribo_diseño
    try:
        if not entry_prueba_seccion_altura.winfo_exists():
            return
        if not entry_prueba_seccion_base.winfo_exists():
            return
        if not entry_prueba_seccion_recubrimiento.winfo_exists():
            return
        if not entry_numero_1.winfo_exists():
            return
        if not entry_numero_inferor_1.winfo_exists():
            return
        if not entry_fila_barra_1.winfo_exists():
            return
        if not entry_fila_inferior_1.winfo_exists():
            return
        if not entry_prueba_seccion_estribo.winfo_exists():
            return
        if not entry_prueba_estribo_diseño.winfo_exists():
            return

        # Obtener valores de los Entry y verificar si están vacíos
        base_text = entry_prueba_seccion_base.get().strip()
        altura_text = entry_prueba_seccion_altura.get().strip()
        offset_text = entry_prueba_seccion_recubrimiento.get().strip()
        numero_barras_text = entry_numero_1.get().strip()
        numero_barras_inferior_text = entry_numero_inferor_1.get().strip()
        fila_barra_1_text = entry_fila_barra_1.get().strip()
        fila_inferior_1_text = entry_fila_inferior_1.get().strip()
        seccion_viga_text = entry_prueba_seccion_estribo.get().strip()  
        estribo_diseño_text = entry_prueba_estribo_diseño.get().strip()

        if base_text == "" or altura_text == "" or offset_text == "" or numero_barras_text == "" or numero_barras_inferior_text == "" or fila_barra_1_text == "" or fila_inferior_1_text == "" or seccion_viga_text == "" or estribo_diseño_text == "":
            return

        # Convertir a float
        base_rect = float(base_text) * 100  # Convertir metros a cm
        altura_rect = float(altura_text) * 100
        offset = float(offset_text) * 100  # Offset en cm
        numero_barras = int(numero_barras_text)  # Número de barras superiores
        numero_barras_inferior = int(numero_barras_inferior_text)  # Número de barras inferiores

        if fig is None:
            return
        
        ax = fig.gca()

        # Eliminar las barras de refuerzo anteriores
        while barras_dibujadas:
            barras_dibujadas.pop().remove()

        # Eliminar leyendas anteriores
        while leyendas_dibujadas:
            leyenda = leyendas_dibujadas.pop()
            leyenda.remove()

        # Dibujar el rectángulo interno con offset
        ax.add_patch(plt.Rectangle((offset, offset), base_rect - 2 * offset, altura_rect - 2 * offset,
                                edgecolor="red", facecolor="none", linestyle="-", linewidth=2))

        # Parámetros de las barras de refuerzo
        radio_barra = 0.0105 * 100  
        separacion_barra = 0.250 * 100  
        
        # Coordenadas de la primera y última barra superior (bordes del rectángulo interno)
        x_inicio = offset + radio_barra
        x_final = base_rect - offset - radio_barra
        y_barras_superiores = altura_rect - offset - radio_barra  
        y_barras_inferiores = offset + radio_barra  
        
        # Función para dibujar barras de refuerzo
        def dibujar_barras(numero_barras, y_posicion):
            if numero_barras == 1:
                barra = ax.add_patch(plt.Circle((base_rect / 2, y_posicion), radius=radio_barra, color='black', label="Barra de acero"))
                barras_dibujadas.append(barra)
            elif numero_barras >= 2:
                x_positions = [x_inicio]
                if numero_barras > 2:
                    for i in range(1, numero_barras - 1):
                        x_positions.append(x_inicio + i * (x_final - x_inicio) / (numero_barras - 1))
                x_positions.append(x_final)
        
                for x in x_positions:
                    barra = ax.add_patch(plt.Circle((x, y_posicion), radius=radio_barra, color='black', label="Barra de acero"))
                    barras_dibujadas.append(barra)
        
        # Dibujar las barras superiores
        dibujar_barras(numero_barras, y_barras_superiores)
        
        # Dibujar las barras inferiores
        dibujar_barras(numero_barras_inferior, y_barras_inferiores)
        
        # Crear las leyendas con marcadores como puntos negros y añadir los valores de fila_barra_1 y fila_inferior_1
        leyenda_superior = plt.Line2D([0], [0], marker='o', color='w', markerfacecolor='black', markersize=7, label=f'Barras: {numero_barras_text}{fila_barra_1_text}')
        leyenda_inferior = plt.Line2D([0], [0], marker='o', color='w', markerfacecolor='black', markersize=7, label=f'Barras: {numero_barras_inferior_text}{fila_inferior_1_text}')
        
        # Nueva leyenda para la sección de la viga
        leyenda_seccion_viga = plt.Line2D([0], [0], marker='s', color='grey', markerfacecolor='grey', markersize=8,linestyle='None', label=f'Sección: {seccion_viga_text}')
        leyenda_estribo = plt.Line2D([0], [0], marker='s', color='r', markerfacecolor='white', markersize=8,linestyle='None', 
                            label=f'Estribo: E{estribo_diseño_text}')
        
        
        # Primera leyenda para las barras
        leyenda_1 = ax.legend(handles=[leyenda_superior, leyenda_inferior], fontsize=8, loc='upper center', ncol=2)
        ax.add_artist(leyenda_1)
        
        # Segunda leyenda para la sección de la viga
        leyenda_2 = ax.legend(handles=[leyenda_seccion_viga,leyenda_estribo], fontsize=8, loc='lower center', ncol=1)
        
        
        canvas_fig_rect.draw()  # Actualizar el gráfico

    except ValueError:
        pass

def guardar_imagen_pilot():
    ruta_carpeta = "Reportes/imagenes_pilot"
    os.makedirs(ruta_carpeta, exist_ok=True)  # Crea la carpeta si no existe

    ruta_imagen_pilot = os.path.join(ruta_carpeta, "grafico_pilot.png")
    
    # Captura el gráfico actual de Matplotlib y guárdalo
    plt.savefig(ruta_imagen_pilot, dpi=300, bbox_inches='tight')
    print(f"Imagen guardada en: {ruta_imagen_pilot}")
    
    actualizar_imagen_pilot(ruta_imagen_pilot)

def actualizar_imagen_pilot(ruta_imagen):
    # Cargar la imagen en el Label dentro del frame
    imagen_pilot_1 = Image.open(ruta_imagen)
    imagen_pilot_1 = imagen_pilot_1.resize((250, 250), Image.LANCZOS)  # Redimensionar al tamaño del frame
    imagen_tk_1 = ImageTk.PhotoImage(imagen_pilot_1)

    # Actualizar la imagen en el Label
    label_imagen.config(image=imagen_tk_1)
    label_imagen.image = imagen_tk_1  # Evita que la imagen sea eliminada por el recolector de basura


# Variable global para verificar si la ventana ya está abierta
ventana_refuerzo_abierta_1 = False

def dibujar_refuerzo_viga():
    global ventana_refuerzo_abierta_1,ventana_refuerzo_viga,treeview_armado,label_asignar_check,combo_seccion_estribo,combo_seccion_barra,Entry_doblez
    global entry_A_confi , entry_C_confi, entry_B_confi, entry_D_confi, combo_gancho_estribo, entry_G_confi, label_ok

    # Verificar si la ventana ya está abierta
    if ventana_refuerzo_abierta_1:
        return

    ventana_refuerzo_abierta_1 = True

    # Crear la ventana secundaria
    ventana_refuerzo_viga = tk.Toplevel()
    ventana_refuerzo_viga.geometry("600x310")
    ventana_refuerzo_viga.title("Refuerzo de la viga")
    ventana_refuerzo_viga.resizable(False, False)
    ventana_refuerzo_viga.attributes('-topmost', True)
    
    labelframe_armado = tk.LabelFrame(ventana_refuerzo_viga,text="")
    labelframe_armado.place(x=10,y=10,width=580,height=250)
    
    # Crear el Notebook
    Notebook_armado = ttk.Notebook(labelframe_armado,style="CustomNotebook.TNotebook")  
    
    # Crear una pestaña dentro del Notebook
    tab_armado = ttk.Frame(Notebook_armado)  
    tab_armado_1 = ttk.Frame(Notebook_armado)  
    
    # Agregar la pestaña al Notebook 
    Notebook_armado.add(tab_armado, text="Refuerzo longitudinal")
    Notebook_armado.add(tab_armado_1, text="Refuerzo transversal")
    
    # Empaquetar el Notebook en el LabelFrame
    Notebook_armado.pack(fill="both", expand=True)
    
    labelframe_asignar = tk.LabelFrame(tab_armado,text="Asignación de refuerzo")
    labelframe_asignar.place(x=10,y=10,width=460,height=150)
    
    frame_asignar_check = tk.Frame(tab_armado,bd=2,relief="sunken")
    frame_asignar_check.place(x=10,y=165,width=460,height=50)
    
    label_asignar_check = tk.Label(frame_asignar_check,text="",
                            wraplength=400,  
                            justify="left",  
                            anchor="w")
    label_asignar_check.place(x=1,y=1)
    
    boton_asignar = ttk.Button(tab_armado,text="Asignar",command=abrir_subventana_asignar)
    boton_asignar.place(x=470,y=100,width=100)
    
    # Crear el primer Treeview 
    treeview_armado = ttk.Treeview(labelframe_asignar,columns=("Refuerzo", "#Barra ", "Fila 1", "#Barra", "Fila 2"), show="headings")
    treeview_armado.place(x=10,y=15,width=440,height=100)
    
    # Definir los encabezados de las columnas
    treeview_armado.heading("Refuerzo", text="Refuerzo")
    treeview_armado.heading("#Barra ", text="#Barra")
    treeview_armado.heading("Fila 1", text="Fila 1")
    treeview_armado.heading("#Barra", text="#Barra")
    treeview_armado.heading("Fila 2", text="Fila 2")
    
    # Modificar el ancho de las columnas
    treeview_armado.column("Refuerzo", width=87, stretch=False, anchor="center")
    treeview_armado.column("#Barra ", width=87, stretch=False, anchor="center")
    treeview_armado.column("Fila 1", width=87, stretch=False, anchor="center")
    treeview_armado.column("#Barra", width=87, stretch=False, anchor="center")
    treeview_armado.column("Fila 2", width=87, stretch=False, anchor="center")
    
    labelframe_d_estribo = tk.LabelFrame(tab_armado_1,text="Dimensionamiento estribo")
    labelframe_d_estribo.place(x=10,y=10,width=250,height=200)
    
    frame_d_estribo = tk.Frame(labelframe_d_estribo,bd=2,relief="flat",bg="white")
    frame_d_estribo.pack(fill="both", expand=True)
    
    # Ruta de la imagen
    image_path_estribo = "Iconos_proyecto/Dimension_estribo.png"  
    # Cargar la imagen usando PIL (Pillow)
    img_estribo = Image.open(image_path_estribo)
    # Redimensionar la imagen
    img_estribo = img_estribo.resize((170, 170), Image.Resampling.LANCZOS)  
    # Convertir la imagen redimensionada a PhotoImage
    img_estribo_tk = ImageTk.PhotoImage(img_estribo)
    # Crear un Label con la imagen redimensionada y colocarlo en el Frame
    label_with_image_estribo = tk.Label(labelframe_d_estribo, image=img_estribo_tk,bg="white")
    label_with_image_estribo.place(relx=0.5, rely=0.5, anchor="center")
    # Es necesario mantener una referencia a la imagen para evitar que sea eliminada
    label_with_image_estribo.image = img_estribo_tk
    
    labelframe_parametros = tk.LabelFrame(tab_armado_1,text="Parametros de figurado")
    labelframe_parametros.place(x=270,y=10,width=290,height=200)
    
    labeL_seccion_estribo = tk.Label(labelframe_parametros,text="Sección:")
    labeL_seccion_estribo.place(x=10,y=10)
    
    combo_seccion_estribo = ttk.Combobox(labelframe_parametros)
    combo_seccion_estribo.place(x=60,y=10,width=88)
    
    label_seccion_barra = tk.Label(labelframe_parametros,text="#Barra:")
    label_seccion_barra.place(x=150,y=10)
    
    combo_seccion_barra = ttk.Combobox(labelframe_parametros,values=["#3","#4"])
    combo_seccion_barra.place(x=200,y=10,width=80)
    
    label_gancho_estribo = tk.Label(labelframe_parametros,text="Gancho:")
    label_gancho_estribo.place(x=10,y=35)
    
    combo_gancho_estribo = ttk.Combobox(labelframe_parametros,values=["135°"])
    combo_gancho_estribo.place(x=60,y=35,width=88)
    
    label_doblez = tk.Label(labelframe_parametros,text="Doblez:")
    label_doblez.place(x=150,y=35)
    
    Entry_doblez = tk.Entry(labelframe_parametros)
    Entry_doblez.place(x=200,y=35,width=80)
    
    labelframe_confinados = tk.LabelFrame(labelframe_parametros,text="Elementos confinados [cm]")
    labelframe_confinados.place(x=10,y=65,width=270,height=105)
    
    label_A_confi = tk.Label(labelframe_confinados,text="A:") 
    label_A_confi.place(x=10,y=10)
    
    entry_A_confi = tk.Entry(labelframe_confinados)
    entry_A_confi.place(x=30,y=10,width=50)
    
    label_B_confi = tk.Label(labelframe_confinados,text="B:") 
    label_B_confi.place(x=90,y=10)
    
    entry_B_confi = tk.Entry(labelframe_confinados)
    entry_B_confi.place(x=110,y=10,width=50)
    
    label_C_confi = tk.Label(labelframe_confinados,text="C:") 
    label_C_confi.place(x=170,y=10)
    
    entry_C_confi = tk.Entry(labelframe_confinados)
    entry_C_confi.place(x=190,y=10,width=50)
    
    label_D_confi = tk.Label(labelframe_confinados,text="D:") 
    label_D_confi.place(x=10,y=45)
    
    entry_D_confi = tk.Entry(labelframe_confinados)
    entry_D_confi.place(x=30,y=45,width=50)
    
    label_G_confi = tk.Label(labelframe_confinados,text="G:") 
    label_G_confi.place(x=90,y=45)
    
    entry_G_confi = tk.Entry(labelframe_confinados)
    entry_G_confi.place(x=110,y=45,width=50)
    
    label_ok = tk.Label(labelframe_confinados,bd=2,relief="sunken",text="")
    label_ok.place(x=180,y=45,width=80)
    
    boton_dibujar_refuerzo_viga = ttk.Button(ventana_refuerzo_viga,text="Dibujar",command=dibujar_elementos_refuerzo)
    boton_dibujar_refuerzo_viga.place(x=100,y=270,width=100)
    
    boton_aceptar_refuerzo_viga = ttk.Button(ventana_refuerzo_viga,text="Aceptar")
    boton_aceptar_refuerzo_viga .place(x=250,y=270,width=100)
    
    boton_cancelar_refuerzo_viga = ttk.Button(ventana_refuerzo_viga,text="Cancelar",command=al_cerrar)
    boton_cancelar_refuerzo_viga .place(x=400,y=270,width=100)
    
    # Función para restaurar el tamaño de las columnas después de intentar redimensionar
    def no_resize(event):
        treeview_armado.column("Refuerzo", width=87, stretch=False, anchor="center")
        treeview_armado.column("#Barra ", width=87, stretch=False, anchor="center")
        treeview_armado.column("Fila 1", width=87, stretch=False, anchor="center")
        treeview_armado.column("#Barra", width=87, stretch=False, anchor="center")
        treeview_armado.column("Fila 2", width=87, stretch=False, anchor="center")
    
    # Vincular el evento de ButtonRelease-1 para evitar el redimensionamiento
    treeview_armado.bind("<ButtonRelease-1>", no_resize)
    
    # Configurar el evento de cierre para restablecer la bandera
    ventana_refuerzo_viga.protocol("WM_DELETE_WINDOW", al_cerrar)
    combo_seccion_estribo.bind('<FocusIn>', lambda event: Dimensionamiento_estribos(event, entry_prueba_seccion_estribo, combo_seccion_estribo))
    # Asociar la función al evento de selección del Combobox
    combo_seccion_barra.bind('<<ComboboxSelected>>', lambda event: Elementos_confinados(event, combo_seccion_barra, Entry_doblez, entry_prueba_seccion_estribo,
                                                    entry_prueba_seccion_recubrimiento, entry_A_confi, entry_C_confi,entry_B_confi, entry_D_confi,entry_prueba_estribo_diseño))
    combo_gancho_estribo.bind('<<ComboboxSelected>>', lambda event: Extension_corte_estribo(event, combo_gancho_estribo, combo_seccion_barra, entry_G_confi, label_ok))


def al_cerrar():
    global ventana_refuerzo_abierta_1
    ventana_refuerzo_abierta_1 = False
    ventana_refuerzo_viga.destroy()

subventana_asignar_abierta = False

def abrir_subventana_asignar():
    global subventana_asignar_abierta,subventana_asignar,combo_agregar_barras, entry_ba_1 ,entry_ba_2,combo_agregar_refuerzo,combo_agregar_filas
    global entry_mas_barra_1 ,entry_mas_barra_2 ,entry_cantidad_barras,entry_mas_ref_1,entry_barras_1,entry_mas_ref_2,label_info_barras_ref
    global label_info_barras_inferior,treeview_armado,label_asignar_check

    # Verificar si la subventana ya está abierta
    if subventana_asignar_abierta:
        return

    subventana_asignar_abierta = True  

    # Crear la subventana
    subventana_asignar = tk.Toplevel()
    subventana_asignar.geometry("530x265")
    subventana_asignar.title("Asignar barras")
    subventana_asignar.resizable(False, False)
    subventana_asignar.attributes('-topmost', True)
    
    labelframe_asignar_datos = tk.LabelFrame(subventana_asignar,text="")
    labelframe_asignar_datos.place(x=10,y=10,width=510,height=210)
    
    label_agregar_refuerzo = tk.Label(labelframe_asignar_datos,text="Refuerzo:")
    label_agregar_refuerzo.place(x=20,y=20)
    
    # Agregar el ComboBox
    combo_agregar_refuerzo = ttk.Combobox(labelframe_asignar_datos, values=["Refuerzo superior", "Refuerzo inferior"])
    combo_agregar_refuerzo.place(x=100, y=20 ,width=120)
    
    label_agregar_barras = tk.Label(labelframe_asignar_datos,text="#Barras:")
    label_agregar_barras.place(x=240,y=20)
    
    # Agregar el ComboBox para barras
    combo_agregar_barras = ttk.Combobox(labelframe_asignar_datos, values=["#2", "#3", "#4", "#5", "#6", "#7", "#8", "#9", "#10", "#11", "#14", "#18"])
    combo_agregar_barras.place(x=300, y=20, width=50)
    
    label_agregar_filas = tk.Label(labelframe_asignar_datos,text="#Filas:")
    label_agregar_filas.place(x=380,y=20)
    
    combo_agregar_filas = ttk.Combobox(labelframe_asignar_datos, values=["1","2"])
    combo_agregar_filas.place(x=440,y=20,width=50)
    
    label_cantidad_barras = tk.Label(labelframe_asignar_datos,text="Fila 1 + Ref")
    label_cantidad_barras.place(x=20,y=80)
    
    entry_cantidad_barras = tk.Entry(labelframe_asignar_datos)
    entry_cantidad_barras.place(x=90,y=80,width=50)
    
    label_barras_1 = tk.Label(labelframe_asignar_datos,text="Fila 2 + Ref")
    label_barras_1.place(x=20,y=110)
    
    entry_barras_1 = tk.Entry(labelframe_asignar_datos)
    entry_barras_1.place(x=90,y=110,width=50)
    
    label_ba_1 = tk.Label(labelframe_asignar_datos,text="#Barras:")
    label_ba_1.place(x=150,y=80)
    
    entry_ba_1 = tk.Entry(labelframe_asignar_datos)
    entry_ba_1.place(x=200,y=80,width=50)
    
    label_mas_ref_1 = tk.Label(labelframe_asignar_datos,text="+")
    label_mas_ref_1.place(x=260,y=80)
    
    label_ba_2 = tk.Label(labelframe_asignar_datos,text="#Barras:")
    label_ba_2.place(x=150,y=110)
    
    entry_ba_2 = tk.Entry(labelframe_asignar_datos)
    entry_ba_2.place(x=200,y=110,width=50)
    
    label_mas_ref_2 = tk.Label(labelframe_asignar_datos,text="+")
    label_mas_ref_2.place(x=260,y=110)
    
    entry_mas_ref_1 = tk.Entry(labelframe_asignar_datos)
    entry_mas_ref_1.place(x=280,y=80,width=50)
    
    entry_mas_ref_2 = tk.Entry(labelframe_asignar_datos)
    entry_mas_ref_2.place(x=280,y=110,width=50)
    
    label_mas_barra_1 = tk.Label(labelframe_asignar_datos,text="#Barras:")
    label_mas_barra_1.place(x=340,y=80)
    
    entry_mas_barra_1 = tk.Entry(labelframe_asignar_datos)
    entry_mas_barra_1.place(x=390,y=80,width=50)
    
    label_mas_barra_2 = tk.Label(labelframe_asignar_datos,text="#Barras:")
    label_mas_barra_2.place(x=340,y=110)
    
    entry_mas_barra_2 = tk.Entry(labelframe_asignar_datos)
    entry_mas_barra_2.place(x=390,y=110,width=50)
    
    frame_info_barras_ref = tk.Frame(labelframe_asignar_datos,bd=2,relief="sunken")
    frame_info_barras_ref.place(x=20,y=140,width=460,height=50)
    
    label_info_barras_ref = tk.Label(frame_info_barras_ref,text="",
                            wraplength=310,  
                            justify="left",  
                            anchor="w")
    label_info_barras_ref.place(x=5,y=1)
    
    label_info_barras_inferior = tk.Label(frame_info_barras_ref,text="",
                            wraplength=310,  
                            justify="left",  
                            anchor="w")
    label_info_barras_inferior.place(x=5,y=20)
    
    boton_aceptar_ref = ttk.Button(subventana_asignar,text="Aceptar",command=actualizar_info_barras)
    boton_aceptar_ref.place(x=90,y=230,width=100)
    
    boton_asignar_ref = ttk.Button(subventana_asignar,text="Asignar",command=asignar_datos_treeview)
    boton_asignar_ref.place(x=220,y=230,width=100)
    
    boton_cancelar_ref = ttk.Button(subventana_asignar,text="Cancelar",command=cerrar_subventana_armado)
    boton_cancelar_ref.place(x=350,y=230,width=100)
        
    # Configurar el evento de cierre para restablecer la bandera
    subventana_asignar.protocol("WM_DELETE_WINDOW", cerrar_subventana_armado)
    
    entry_ba_1.bind("<Button-1>", lambda event: actualizar_entry_1(event, entry_ba_1))
    entry_ba_2.bind("<Button-1>", lambda event: actualizar_entry_1(event, entry_ba_2))
    entry_mas_barra_1.bind("<Button-1>", lambda event: actualizar_entry_1(event, entry_mas_barra_1))
    entry_mas_barra_2.bind("<Button-1>", lambda event: actualizar_entry_1(event, entry_mas_barra_2))

# Función para actualizar la información de barras y los Entry en labelframe_reporte
def actualizar_info_barras():
    # Obtener el valor seleccionado en los ComboBoxes
    refuerzo_r = combo_agregar_refuerzo.get()
    filas_r = combo_agregar_filas.get()

    # Inicializar un string vacío para almacenar el mensaje
    mensaje_r = ""

    # Verificar si estamos en la fila 1
    if filas_r == "1":
        # Obtener los valores de los Entry relacionados con la fila 1
        cantidad_barras_r = entry_cantidad_barras.get()
        barras_1_r = entry_ba_1.get()
        mas_ref_1_r = entry_mas_ref_1.get()
        mas_barra_1_r = entry_mas_barra_1.get()

        # Si solo hay datos en entry_cantidad_barras y entry_ba_1
        if cantidad_barras_r and barras_1_r:
            mensaje_r = f"{refuerzo_r}: Se escoge para la fila ({filas_r}) {cantidad_barras_r}{barras_1_r}"

        # Si también hay datos en entry_mas_ref_1 y entry_mas_barra_1
        if mas_ref_1_r and mas_barra_1_r:
            mensaje_r = f"{refuerzo_r}: Se escoge para la fila ({filas_r}) {cantidad_barras_r}{barras_1_r} + {mas_ref_1_r}{mas_barra_1_r}"

        # Actualizar los Entry en labelframe_reporte para refuerzo superior o inferior
        if refuerzo_r == "Refuerzo superior":
            entry_numero_1.delete(0, tk.END)
            entry_numero_1.insert(0, cantidad_barras_r)  

            entry_fila_barra_1.delete(0, tk.END)
            entry_fila_barra_1.insert(0, barras_1_r)  

            entry_numero_2.delete(0, tk.END)
            entry_numero_2.insert(0, mas_ref_1_r)  

            entry_fila_barra_2.delete(0, tk.END)
            entry_fila_barra_2.insert(0, mas_barra_1_r)  

        # Actualizamos el label_info_barras_ref para refuerzo superior o inferior
        if refuerzo_r == "Refuerzo superior":
            label_info_barras_ref.config(text=mensaje_r)

        elif refuerzo_r == "Refuerzo inferior":
            label_info_barras_inferior.config(text=mensaje_r)

        # **Nueva parte**: Actualizar los Entry de Refuerzo inferior también cuando es fila 1
        if refuerzo_r == "Refuerzo inferior":
            entry_fila_inferior_1.delete(0, tk.END)
            entry_fila_inferior_1.insert(0, barras_1_r)  

            entry_fila_inferior_2.delete(0, tk.END)
            entry_fila_inferior_2.insert(0, mas_barra_1_r)  

            entry_numero_inferor_1.delete(0, tk.END)
            entry_numero_inferor_1.insert(0, cantidad_barras_r) 

            entry_numero_inferor_2.delete(0, tk.END)
            entry_numero_inferor_2.insert(0, mas_ref_1_r)  

    # Verificar si estamos en la fila 2
    elif filas_r == "2":
        # Obtener los valores de los Entry relacionados con la fila 2
        barras_2_r = entry_barras_1.get()
        ba_2_r = entry_ba_2.get()
        mas_ref_2_r = entry_mas_ref_2.get()
        mas_barra_2_r = entry_mas_barra_2.get()

        # Si solo hay datos en entry_barras_1 y entry_ba_2
        if barras_2_r and ba_2_r:
            mensaje_r = f"{refuerzo_r}: Se escoge para la fila ({filas_r}) {barras_2_r}{ba_2_r}"

        # Si también hay datos en entry_mas_ref_2 y entry_mas_barra_2
        if mas_ref_2_r and mas_barra_2_r:
            mensaje_r = f"{refuerzo_r}: Se escoge para la fila ({filas_r}) {barras_2_r}{ba_2_r} + {mas_ref_2_r}{mas_barra_2_r}"

        # Actualizar los Entry en labelframe_reporte para refuerzo superior o inferior
        if refuerzo_r == "Refuerzo superior":
            entry_numero2_superior.delete(0, tk.END)
            entry_numero2_superior.insert(0, barras_2_r)  # Actualizamos barras_2_r

            entry_fila2_superior.delete(0, tk.END)
            entry_fila2_superior.insert(0, ba_2_r)  # Actualizamos ba_2_r

            entry_numero2_combinar.delete(0, tk.END)
            entry_numero2_combinar.insert(0, mas_ref_2_r)  # Actualizamos mas_ref_2_r

            entry_fila2_combinar.delete(0, tk.END)
            entry_fila2_combinar.insert(0, mas_barra_2_r)  # Actualizamos mas_barra_2_r

        # Actualizamos el label_info_barras_ref para refuerzo superior
        if refuerzo_r == "Refuerzo superior":
            label_info_barras_ref.config(text=mensaje_r)

        # Actualizamos el label_info_barras_inferior para refuerzo inferior
        elif refuerzo_r == "Refuerzo inferior":
            label_info_barras_inferior.config(text=mensaje_r)
        
        #**Nueva parte**: Actualizar los Entry de Refuerzo inferior también cuando es fila 2
        if refuerzo_r == "Refuerzo inferior":
            entry_fila2_inferior.delete(0, tk.END)
            entry_fila2_inferior.insert(0, ba_2_r)  

            entry_numero1_inferor.delete(0, tk.END)
            entry_numero1_inferor.insert(0, barras_2_r)  

            entry_inferior2_combinar.delete(0, tk.END)
            entry_inferior2_combinar.insert(0, mas_barra_2_r) 

            entry_numero1_combinar.delete(0, tk.END)
            entry_numero1_combinar.insert(0, mas_ref_2_r)


def asignar_datos_treeview():
    # Obtener el valor seleccionado en los ComboBoxes
    refuerzo_r = combo_agregar_refuerzo.get()  # "Refuerzo superior" o "Refuerzo inferior"
    filas_r = combo_agregar_filas.get()  # "1" o "2"

    # Asegurarse de que las filas 0 y 1 existan
    if len(treeview_armado.get_children()) == 0:  # Si no hay filas en el treeview, insertar las filas iniciales
        treeview_armado.insert("", "end", values=("Superior", "", "", "", ""))
        treeview_armado.insert("", "end", values=("Inferior", "", "", "", ""))

    # Verificar si la fila seleccionada es la 1
    if filas_r == "1":
        if refuerzo_r == "Refuerzo superior":
            # Obtener los valores de los Entry relacionados con Refuerzo superior y Fila 1
            barras_1_r = entry_fila_barra_1.get()
            cantidad_barras_r = entry_numero_1.get()
            barras_2_r = entry_fila_barra_2.get()
            cantidad_barras_2_r = entry_numero_2.get()

            # Buscar la fila "Superior" (fila 0)
            hijos_treeview = treeview_armado.get_children()
            if len(hijos_treeview) > 0:  # Verificar que la fila "Superior" existe
                fila_encontrada = False
                current_values = treeview_armado.item(hijos_treeview[0])["values"]  # Acceder a la fila "Superior"
                
                # Si la fila "Superior" tiene datos en la segunda columna (barras), actualizarla
                if current_values[0] == "Superior":
                    # Si ya tiene un valor en la columna de barras, actualízalo
                    treeview_armado.item(hijos_treeview[0], values=("Superior", f"{barras_1_r} {barras_2_r}", f"{cantidad_barras_r}{barras_1_r} {cantidad_barras_2_r}{barras_2_r}", "", ""))
                    fila_encontrada = True

                if not fila_encontrada:
                    print("Error: No se encontró la fila correspondiente para Refuerzo superior y Fila 1.")
                
        elif refuerzo_r == "Refuerzo inferior":
            # Obtener los valores de los Entry relacionados con Refuerzo inferior y Fila 1
            barras_1_inferior = entry_fila_inferior_1.get()
            cantidad_barras_inferior = entry_numero_inferor_1.get()
            barras_2_inferior = entry_fila_inferior_2.get()
            cantidad_barras_2_inferior = entry_numero_inferor_2.get()

            # Buscar la fila "Inferior" (fila 1)
            hijos_treeview = treeview_armado.get_children()
            if len(hijos_treeview) > 1:  # Verificar que la fila "Inferior" existe
                fila_encontrada = False
                current_values = treeview_armado.item(hijos_treeview[1])["values"]  # Acceder a la fila "Inferior"
                
                # Si la fila "Inferior" tiene datos en la segunda columna (barras), actualizarla
                if current_values[0] == "Inferior":
                    # Si ya tiene un valor en la columna de barras, actualízalo
                    treeview_armado.item(hijos_treeview[1], values=("Inferior", f"{barras_1_inferior} {barras_2_inferior}", f"{cantidad_barras_inferior}{barras_1_inferior} {cantidad_barras_2_inferior}{barras_2_inferior}", "", ""))
                    fila_encontrada = True

                if not fila_encontrada:
                    print("Error: No se encontró la fila correspondiente para Refuerzo inferior y Fila 1.")
                
            # Actualizar el mensaje en el label después de actualizar 
            label_asignar_check.config(text="¡Muy bien! Has completado esta fase con éxito. Ahora, por favor, continúa con la configuración del refuerzo transversal para asegurar que todo esté correctamente ajustado")

# Función para actualizar el Entry cuando se hace clic
def actualizar_entry_1(event, entry_asociacion):
    # Obtener el valor seleccionado en el ComboBox
    valor_seleccionado_1 = combo_agregar_barras.get()
    
    # Borrar cualquier texto existente y establecer el valor en el Entry correspondiente
    entry_asociacion.delete(0, tk.END)
    entry_asociacion.insert(0, valor_seleccionado_1)

def Dimensionamiento_estribos(event, entry_prueba_seccion_estribo, combo_seccion_estribo):
    # Obtener el valor del Entry
    dato_entry = entry_prueba_seccion_estribo.get()
    
    # Actualizar el Combobox con el valor del Entry
    combo_seccion_estribo['values'] = (dato_entry,)
    
    # Establecer el valor en el Combobox
    combo_seccion_estribo.set(dato_entry)

def Elementos_confinados(event, combo_seccion_barra, Entry_doblez, entry_prueba_seccion_estribo, entry_prueba_seccion_recubrimiento,
                        entry_A_confi, entry_C_confi, entry_B_confi, entry_D_confi,entry_prueba_estribo_diseño):
    # Obtener la selección del Combobox
    seleccion = combo_seccion_barra.get()
    
    # Definir los diámetros según la selección
    if seleccion == "#3":
        diametro_barra_3 = 9.5
        doblez_diametro = 4 * diametro_barra_3
    elif seleccion == "#4":
        diametro_barra_4 = 12.7
        doblez_diametro = 4 * diametro_barra_4
    else:
        return
    
    # Calcular el resultado y convertirlo a centímetros
    resultado_doblez = doblez_diametro / 10
    
    # Actualizar el Entry con el resultado formateado
    Entry_doblez.delete(0, tk.END)  
    Entry_doblez.insert(0, f'{resultado_doblez} cm')
    
    # Actualizar el Entry de "prueba estribo diseño" con la selección del Combobox
    entry_prueba_estribo_diseño.delete(0, tk.END)
    entry_prueba_estribo_diseño.insert(0, seleccion)

    # Obtener los valores del entry_prueba_seccion_estribo (Ejemplo: "VG 40.0 X 50.0")
    texto_estribo_1 = entry_prueba_seccion_estribo.get()
    
    # Filtrar los números de la cadena de texto y extraer A_estribo y C_estribo (ahora incluye flotantes)
    numeros_1 = [float(s) for s in texto_estribo_1.split() if s.replace('.', '', 1).isdigit()]
    
    # Verificar si se encontraron al menos dos números
    if len(numeros_1) >= 2:
        A_estribo = numeros_1[0]  # Primer número
        C_estribo = numeros_1[1]  # Segundo número
    else:
        # Si no se encuentran dos números, actualizar los Entry como vacío
        entry_A_confi.delete(0, tk.END)
        entry_C_confi.delete(0, tk.END)
        return
    
    # Obtener el valor de recubrimiento (en cm)
    try:
        Recu_estribo = float(entry_prueba_seccion_recubrimiento.get())
    except ValueError:
        # Si el valor de recubrimiento no es válido, no hacer nada
        return
    
    # Calcular las dimensiones del estribo
    ancho_dimension_estribo = A_estribo - 2 * Recu_estribo * 100  # Convertir recubrimiento de metros a centímetros
    altura_dimension_estribo = C_estribo - 2 * Recu_estribo * 100
    
    # Actualizar los resultados en los Entry correspondientes con "cm"
    entry_A_confi.delete(0, tk.END)
    entry_A_confi.insert(0, f"{ancho_dimension_estribo} cm")
    
    entry_C_confi.delete(0, tk.END)
    entry_C_confi.insert(0, f"{altura_dimension_estribo} cm")
    
    # Actualizar los nuevos Entry (entry_B_confi y entry_D_confi)
    entry_B_confi.delete(0, tk.END)
    entry_B_confi.insert(0, f"{ancho_dimension_estribo} cm")
    
    entry_D_confi.delete(0, tk.END)
    entry_D_confi.insert(0, f"{altura_dimension_estribo} cm")

def Extension_corte_estribo(event, combo_gancho_estribo, combo_seccion_barra, entry_G_confi,label_ok):
    # Verificar si el valor seleccionado en el combo_gancho_estribo es "135°"
    if combo_gancho_estribo.get() == "135°":
        # Obtener la selección del combo_seccion_barra
        seleccion = combo_seccion_barra.get()
        
        # Definir los diámetros según la selección del combo_seccion_barra
        if seleccion == "#3":
            corte_diametro_3 = 9.5
            corte_estribo = 6 * corte_diametro_3
        elif seleccion == "#4":
            corte_diametro_4 = 12.7
            corte_estribo = 6 * corte_diametro_4
        else:
            # Si no hay una selección válida, no hacer nada
            return
        
        # Verificar si el resultado es menor que 75, en cuyo caso se asigna 75
        if corte_estribo < 75:
            corte_estribo = 75
        # Dividir el resultado entre 10
        corte_estribo = corte_estribo / 10
        
        # Mostrar el resultado en el entry_G_confi correspondiente
        entry_G_confi.delete(0, tk.END)  
        entry_G_confi.insert(0, f"{corte_estribo:.2f} cm")  
        # Actualizar el label_ok con "Ok!" 
        label_ok.config(text="OK!", fg="green")  

def cerrar_subventana_armado():
    global subventana_asignar_abierta
    subventana_asignar.destroy()
    subventana_asignar_abierta = False



frame_ventana_flexion= tk.Frame(ventana,bd=10,relief="ridge",bg="white")
frame_ventana_flexion.place(x=838,y=35,width=660,height=737)

frame_interno = tk.Frame(frame_ventana_flexion, bd=2, relief="flat")
frame_interno.pack(fill="both", expand=True)


# Crear el estilo para personalizar las pestañas
style = ttk.Style()

# Estilo para el Notebook
style.configure("CustomNotebook.TNotebook", 
                background="lightgray",  
                tabmargins=[0, 0, 0, 0])  

# Estilo para las pestañas
style.configure("CustomNotebook.TNotebook.Tab", 
                background="white",   
                foreground="black",   
                padding=[10, 2],      
                font=("Arial", 9))    

# Estilo para la pestaña seleccionada
style.map("CustomNotebook.TNotebook.Tab", 
            background=[("selected", "lightgray")],  
            foreground=[("selected", "black")])      

# Crear el Notebook dentro de frame_interno con el estilo personalizado
notebook_flexion = ttk.Notebook(frame_interno, style="CustomNotebook.TNotebook")


# Crear las pestañas del Notebook
tab1_flexion = tk.Frame(notebook_flexion)  
tab2_cortante = tk.Frame(notebook_flexion)  

# Agregar las pestañas al Notebook
notebook_flexion.add(tab1_flexion, text="Diseño flexión")  
notebook_flexion.add(tab2_cortante, text="Diseño cortante")  

frame_ventana_flexion = tk.Frame(tab1_flexion,bd=2,relief="raise")
frame_ventana_flexion.place(x=20,y=20,width=590,height=500)

frame_interno_1 = tk.Frame(tab1_flexion, bd=2, relief="raise")
frame_interno_1.place(x=20,y=530,width=590,height=150)

# Crear el Notebook dentro del Frame
notebook_reporte = ttk.Notebook(frame_interno_1,style="CustomNotebook.TNotebook")
notebook_reporte.pack(fill="both", expand=True)

# Crear la pestaña
tab_reporte = tk.Frame(notebook_reporte)  # Pestaña vacía
notebook_reporte.add(tab_reporte, text="Reporte de resultados")

labelframe_reporte = tk.LabelFrame(tab_reporte,text="Resultados de diseño flexión")
labelframe_reporte.place(x=10,y=10,width=560,height=100)

frame_reporte = tk.Frame(labelframe_reporte,bd=2,relief="flat")
frame_reporte.place(x=10,y=10,width=30,height=30)

frame_reporte_pdf = tk.Frame(labelframe_reporte,bd=2,relief="flat")
frame_reporte_pdf.place(x=10,y=45,width=30,height=30)

# Cargar la imagen con el nombre 'image_report'
image_report = Image.open("Iconos_proyecto/Doc_word.png")
image_report_pdf = Image.open("Iconos_proyecto/Doc_pdf.png")
# Redimensionar la imagen si es necesario (ajustarlo al tamaño del frame)
image_doc = image_report.resize((30, 30))  
image_pdf = image_report_pdf.resize((30, 30))
# Convertir la imagen a un formato que Tkinter pueda usar
photo_report = ImageTk.PhotoImage(image_doc)
photo_report_pdf = ImageTk.PhotoImage(image_pdf)
# Insertar la imagen en el frame usando un Label
label_report = tk.Label(frame_reporte, image=photo_report)
label_report.pack()
label_report_pdf = tk.Label(frame_reporte_pdf, image= photo_report_pdf)
label_report_pdf.pack()
# Mantener una referencia a la imagen 
label_report.image = photo_report
label_report_pdf.image = photo_report_pdf

# Crear las variables para los checkbuttons
check_reporte_word = tk.BooleanVar()
check_reporte_pdf = tk.BooleanVar()
# Crear los checkbuttons
checkbutton_word = tk.Checkbutton(labelframe_reporte, text="Generar reporte de resultados - formato Word", variable=check_reporte_word,command=Generar_reportes)
checkbutton_word.place(x=50,y=10)
checkbutton_pdf = tk.Checkbutton(labelframe_reporte, text="Generar reporte de resultados - formato Pdf", variable=check_reporte_pdf)
checkbutton_pdf.place(x=50,y=45)
checkbutton_pdf.config(state="disabled")

'*****************************Resultados diseño cortante***********************************'

frame_ventana_cortante = tk.Frame(tab2_cortante,bd=2,relief="raise")
frame_ventana_cortante.place(x=20,y=20,width=590,height=500)

frame_interno_2 = tk.Frame(tab2_cortante, bd=2, relief="raise")
frame_interno_2.place(x=20,y=530,width=590,height=150)

# Crear el Notebook dentro del Frame
notebook_reporte_1 = ttk.Notebook(frame_interno_2,style="CustomNotebook.TNotebook")
notebook_reporte_1.pack(fill="both", expand=True)

# Crear la pestaña
tab_reporte_1 = tk.Frame(notebook_reporte_1)  # Pestaña vacía
notebook_reporte_1.add(tab_reporte_1, text="Reporte de resultados")

labelframe_reporte_1 = tk.LabelFrame(tab_reporte_1,text="Resultados de diseño cortante")
labelframe_reporte_1.place(x=10,y=10,width=560,height=100)

frame_reporte_1 = tk.Frame(labelframe_reporte_1,bd=2,relief="flat")
frame_reporte_1.place(x=10,y=10,width=30,height=30)

frame_reporte_pdf_1 = tk.Frame(labelframe_reporte_1,bd=2,relief="flat")
frame_reporte_pdf_1.place(x=10,y=45,width=30,height=30)

# Cargar la imagen con el nombre 'image_report'
image_report_1 = Image.open("Iconos_proyecto/Doc_word.png")
image_report_pdf_1 = Image.open("Iconos_proyecto/Doc_pdf.png")
# Redimensionar la imagen si es necesario (ajustarlo al tamaño del frame)
image_doc_1 = image_report_1.resize((30, 30))  
image_pdf_1 = image_report_pdf_1.resize((30, 30))
# Convertir la imagen a un formato que Tkinter pueda usar
photo_report_1 = ImageTk.PhotoImage(image_doc_1)
photo_report_pdf_1 = ImageTk.PhotoImage(image_pdf_1)
# Insertar la imagen en el frame usando un Label
label_report_1 = tk.Label(frame_reporte_1, image=photo_report_1)
label_report_1.pack()
label_report_pdf_1 = tk.Label(frame_reporte_pdf_1, image= photo_report_pdf_1)
label_report_pdf_1.pack()
# Mantener una referencia a la imagen 
label_report_1.image = photo_report_1
label_report_pdf_1.image = photo_report_pdf_1

# Crear las variables para los checkbuttons
check_reporte_word_1 = tk.BooleanVar()
check_reporte_pdf_1 = tk.BooleanVar()
# Crear los checkbuttons
checkbutton_word_1 = tk.Checkbutton(labelframe_reporte_1, text="Generar reporte de resultados - formato Word", variable=check_reporte_word_1,command=generar_reporte_cortante)
checkbutton_word_1.place(x=50,y=10)
checkbutton_pdf_1 = tk.Checkbutton(labelframe_reporte_1, text="Generar reporte de resultados - formato Pdf", variable=check_reporte_pdf_1)
checkbutton_pdf_1.place(x=50,y=45)
checkbutton_pdf_1.config(state="disabled")

#entrys de prueba para refuerzo superior fila 1
entry_fila_barra_1 = tk.Entry(labelframe_reporte)
#entry_fila_barra_1.place(x=1,y=1,width=50)
entry_fila_barra_2 = tk.Entry(labelframe_reporte) # combinar numero de barras de refuerzo 
#entry_fila_barra_2.place(x=100,y=1,width=50)
# entrys de cantidad para cantidad superior fila 1
entry_numero_1 = tk.Entry(labelframe_reporte)
#entry_numero_1.place(x=1,y=20,width=50)
entry_numero_2 = tk.Entry(labelframe_reporte)    # combinar cantidad de barras de refuerzo   
#entry_numero_2.place(x=100,y=20,width=50)

#entrys de prueba para refuerzo inferior fila 1
entry_fila_inferior_1 = tk.Entry(labelframe_reporte)
#entry_fila_inferior_1.place(x=200,y=1,width=100)
entry_fila_inferior_2= tk.Entry(labelframe_reporte) # combinar numero de barras de refuerzo
#entry_fila_inferior_2.place(x=300,y=1,width=100)
# entrys de cantidad para cantidad superior fila 1
entry_numero_inferor_1 = tk.Entry(labelframe_reporte)
#entry_numero_inferor_1.place(x=200,y=20,width=100)
entry_numero_inferor_2 = tk.Entry(labelframe_reporte) # combinar cantidad de barras de refuerzo
#entry_numero_inferor_2.place(x=300,y=20,width=100)

#entrys de prueba para refuerzo superior fila 2
entry_fila2_superior = tk.Entry(labelframe_reporte)
#entry_fila2_superior.place(x=1,y=1,width=50)
entry_fila2_combinar = tk.Entry(labelframe_reporte) # combinar numero de barras de refuerzo 
#entry_fila2_combinar.place(x=100,y=1,width=50)
# entrys de cantidad para cantidad superior fila 2
entry_numero2_superior = tk.Entry(labelframe_reporte)
#entry_numero2_superior.place(x=1,y=20,width=50)
entry_numero2_combinar = tk.Entry(labelframe_reporte)    # combinar cantidad de barras de refuerzo   
#entry_numero2_combinar.place(x=100,y=20,width=50)

#entrys de prueba para refuerzo inferior fila 2
entry_fila2_inferior = tk.Entry(labelframe_reporte)
#entry_fila2_inferior.place(x=200,y=1,width=100)
entry_inferior2_combinar= tk.Entry(labelframe_reporte) # combinar numero de barras de refuerzo
#entry_inferior2_combinar.place(x=300,y=1,width=100)
# entrys de cantidad para cantidad superior fila 1
entry_numero1_inferor = tk.Entry(labelframe_reporte)
#entry_numero1_inferor.place(x=200,y=20,width=100)
entry_numero1_combinar = tk.Entry(labelframe_reporte) # combinar cantidad de barras de refuerzo
#entry_numero1_combinar.place(x=300,y=20,width=100)

entry_prueba_seccion_estribo = tk.Entry(labelframe_reporte)
#entry_prueba_seccion_estribo.place(x=300,y=20,width=100)
entry_prueba_seccion_recubrimiento = tk.Entry(labelframe_reporte)
#entry_prueba_seccion_recubrimiento.place(x=300,y=20,width=100)
entry_prueba_seccion_base = tk.Entry(labelframe_reporte)
#entry_prueba_seccion_base.place(x=300,y=20,width=100)
entry_prueba_seccion_altura = tk.Entry(labelframe_reporte)
#entry_prueba_seccion_altura.place(x=300,y=20,width=100)
entry_prueba_estribo_diseño = tk.Entry(labelframe_reporte)
#entry_prueba_estribo_diseño.place(x=300,y=20,width=100)
entry_prueba_longitud = tk.Entry(labelframe_reporte)
#entry_prueba_longitud.place(x=300,y=20,width=100)

#TRAMO 1 
entry_tramo_1 = tk.Entry(labelframe_reporte)
#entry_tramo_1.place(x=100,y=1,width=100)
entry_tramo_1_S =tk.Entry(labelframe_reporte)
#entry_tramo_1_S.place(x=100,y=40,width=100)

#TRAMO 2 
entry_tramo_2 = tk.Entry(labelframe_reporte)
#entry_tramo_2.place(x=200,y=1,width=100)
entry_tramo_2_S =tk.Entry(labelframe_reporte)
#entry_tramo_2_S.place(x=200,y=40,width=100)

#TRAMO 3 
entry_tramo_3 = tk.Entry(labelframe_reporte)
#entry_tramo_3.place(x=300,y=1,width=100)
entry_tramo_3_S =tk.Entry(labelframe_reporte)
#entry_tramo_3_S.place(x=300,y=40,width=100)

#BARRAS SUPERIOR
entry_barras_superior = tk.Entry(labelframe_reporte)
#entry_barras_superior.place(x=100,y=1,width=100)

#BARRAS INFERIOR
entry_barras_inferior = tk.Entry(labelframe_reporte)
#entry_barras_inferior.place(x=100,y=40,width=100)

# Crear labels de pruebas
# label para el valor profundidad "d"
label_profundidad_prueba = tk.Label(frame_interno_1,bg="red")
#label_profundidad_prueba.place(x=1,y=1,width=100)

# label para el valor de "b"
label_b_prueba = tk.Label(frame_interno_1,bg="red")
#label_b_prueba.place(x=100,y=1,width=100)

# Label para el valor de "Vmax"
label_Vmax_prueba = tk.Label(frame_interno_1,bg="red")
#label_Vmax_prueba.place(x=200,y=1,width=100)

# Crear un Canvas y agregarlo al LabelFrame
canvas_flexion = tk.Canvas(frame_ventana_flexion)
canvas_flexion.pack(fill="both", expand=True)

# label para el dato de nombre de estudiante 
label_estudiante = tk.Label(labelframe_reporte,text="",bg="red")
#label_estudiante.place(x=10,y=1,width=100)

# label para el dato de nombre de modelo
label_modelo = tk.Label(labelframe_reporte,text="",bg="green")
#label_modelo.place(x=10,y=20,width=100)

# label para el dato de modulo de elasticidad del concreto
label_elasticidad = tk.Label(labelframe_reporte,text="",bg="blue")
#label_elasticidad.place(x=10,y=40,width=100)

# label para el dato de resistencia a compresion del concreto
label_fc = tk.Label(labelframe_reporte,text="",bg="grey")
#label_fc.place(x=10,y=1,width=100)

# Label para el dato de altura de la viga
label_h= tk.Label(labelframe_reporte,text="",bg="orange")
#label_h.place(x=10,y=40,width=100)

# Label para el dato del recubrimiento de la viga 
label_recubrimiento = tk.Label(labelframe_reporte,text="",bg="yellow")
#label_recubrimiento.place(x=10,y=10,width=100)

# Label para el dato de la altura efectiva
label_altura_efectiva = tk.Label(labelframe_reporte,text="",bg="white")
#label_altura_efectiva.place(x=10,y=40,width=100)

# Label para el dato de la resistencia concreto
label_resistencia_psi = tk.Label(labelframe_reporte,text="",bg="green")
#label_resistencia_psi.place(x=10,y=20,width=100)

# Label para el dato de Wpp
label_cargas_Wpp = tk.Label(labelframe_reporte,text="",bg="red")
#label_cargas_Wpp.place(x=10,y=1,width=100)

# Label para el dato de WD
label_cargas_WD = tk.Label(labelframe_reporte,text="",bg="blue")
#label_cargas_WD.place(x=120,y=1,width=100)

# Label para el dato de WL
label_cargas_WL = tk.Label(labelframe_reporte,text="",bg="yellow")
#label_cargas_WL.place(x=230,y=1,width=100)

# Label para el dato de Wtotal
label_cargas_Wtotal = tk.Label(labelframe_reporte,text="",bg="orange")
#label_cargas_Wtotal.place(x=340,y=1,width=100)

# Label para la reaccion apoyo A y B
label_reaccion = tk.Label(labelframe_reporte,text="",bg="red")
#label_reaccion.place(x=10,y=20,width=100)

# Label para el dato Mmax[-]
label_Mmax_1 = tk.Label(labelframe_reporte,text="",bg="red")
#label_Mmax_1.place(x=10,y=1,width=100)

# Label para el dato Mmax[+]
label_Mmax_2 = tk.Label(labelframe_reporte,text="",bg="blue")
#label_Mmax_2.place(x=110,y=1,width=100)

# Label para el dato cuantia minima
label_cuantia_minima = tk.Label(labelframe_reporte,text="",bg="green")
#label_cuantia_minima.place(x=10,y=1,width=100)

# Label para el dato cuantia maxima
label_cuantia_maxima = tk.Label(labelframe_reporte,text="",bg="grey")
#label_cuantia_maxima.place(x=10,y=20,width=100)

# Label para el dato beta1
label_beta1 = tk.Label(labelframe_reporte,text="",bg="red")
#label_beta1.place(x=10,y=40,width=100)

# Label para el dato Rn
label_Resistencia_Rn = tk.Label(labelframe_reporte,text="",bg="blue")
#label_Resistencia_Rn.place(x=10,y=1,width=100)

# label para el dato cuantia requerida
label_cuantia_requerida = tk.Label(labelframe_reporte,text="",bg="green")
#label_cuantia_requerida.place(x=10,y=20,width=100)

# label para el dato acero requerido
label_acero_requerido = tk.Label(labelframe_reporte,text="",bg="yellow")
#label_acero_requerido.place(x=10,y=40,width=100)

# label para el dato de Rn2 
label_Rn2 = tk.Label(labelframe_reporte,text="",bg="white")
#label_Rn2.place(x=10,y=1,width=100)

# label para el dato req C2
label_req_C2 = tk.Label(labelframe_reporte,text="",bg="red")
#label_req_C2.place(x=10,y=20,width=100)

# label para el dato As2
label_As2 = tk.Label(labelframe_reporte,text="",bg="blue")
#label_As2.place(x=10,y=40,width=100)

# Label para el dato estribo 
label_estribo = tk.Label(labelframe_reporte,text="",bg="green")
#label_estribo.place(x=10,y=10,width=100)

#label para el dato de area estribo
label_area_estribo = tk.Label(labelframe_reporte,text="",bg="orange")
#label_area_estribo.place(x=10,y=50,width=100)

#label para el dato de ɸMn1
label_ɸMn1 = tk.Label(labelframe_reporte,text="",bg="orange")
#label_ɸMn1.place(x=10,y=50,width=100)

#label para el dato de ɸMn2
label_ɸMn2 = tk.Label(labelframe_reporte,text="",bg="blue")
#label_ɸMn2.place(x=10,y=10,width=100)

#label para el dato si cumple o no cumple
label_concluision_ɸMn = tk.Label(labelframe_reporte,text="",bg="green")
#label_concluision_ɸMn.place(x=100,y=1,width=100)

#label para el dato si cumple o no cumple
label_concluision_ɸMn2 = tk.Label(labelframe_reporte,text="",bg="red")
#label_concluision_ɸMn2.place(x=100,y=20,width=100)

# Label para el dato No.barra
label_barra = tk.Label(labelframe_reporte,text="",bg="yellow")
#label_barra.place(x=1,y=1,width=100)

# Label para el dato info_barra
label_info_b = tk.Label(labelframe_reporte,text="",bg="red")
#label_info_b.place(x=1,y=20,width=100)

# label para el dato area barra
label_area_barra = tk.Label(labelframe_reporte,text="",bg="blue")
#label_area_barra.place(x=1,y=50,width=100)

# label para el dato diametro barra
label_Øbarras = tk.Label(labelframe_reporte,text="",bg="green")
#label_Øbarras.place(x=110,y=50,width=100)

# label para el dato barra flexion
label_barra_flexion = tk.Label(labelframe_reporte,text="",bg="orange")
#label_barra_flexion.place(x=1,y=10,width=100)

# label para el dato de barra flexion1
label_barra_flexion1 = tk.Label(labelframe_reporte,text="",bg="yellow")
#label_barra_flexion1.place(x=1,y=50,width=100)

# Label parametro_A_1
label_A_1 = tk.Label(labelframe_reporte,text="",bg="red")
#label_A_1.place(x=1,y=1,width=100)

# Label parametro_C_1
label_C_1 = tk.Label(labelframe_reporte,text="",bg="green")
#label_C_1.place(x=1,y=50,width=100)

# label parametro_D_1
label_D_1 = tk.Label(labelframe_reporte,text="",bg="orange")
#label_D_1.place(x=100,y=1,width=100)

# label parametro_n_1
label_n_1 = tk.Label(labelframe_reporte,text="",bg="yellow")
#label_n_1.place(x=100,y=20,width=100)

# label paremetro dp_1
label_dp_1 = tk.Label(labelframe_reporte,text="",bg="white")
#label_dp_1.place(x=100,y=50,width=100)

# label base requerida
label_base_req = tk.Label(labelframe_reporte,text="",bg="red")
#label_base_req.place(x=1,y=1,width=100)

# label base requerida1
label_base_req1 = tk.Label(labelframe_reporte,text="",bg="blue")
#label_base_req1.place(x=1,y=20,width=100)

# label Mcr
label_Mcr_1 = tk.Label(labelframe_reporte,text="",bg="green")
#label_Mcr_1.place(x=1,y=1,width=100)

# label Mcr_check
label_Mcr_check = tk.Label(labelframe_reporte,text="",bg="yellow")
#label_Mcr_check.place(x=1,y=20,width=100)

# label Rn_mcr 
label_Rn_mcr = tk.Label(labelframe_reporte,text="",bg="orange")
#label_Rn_mcr.place(x=1,y=50,width=100)

# label Rn_mcr_check
label_Rn_mcr_check = tk.Label(labelframe_reporte,text="",bg="white")
#label_Rn_mcr_check.place(x=120,y=50,width=100)

# label ρreq_mcr
label_ρreq_mcr = tk.Label(labelframe_reporte,text="",bg="red")
#label_ρreq_mcr.place(x=200,y=50,width=100)

# label info_barras_mcr
label_info_barras_mcr = tk.Label(labelframe_reporte,text="",bg="blue")
#label_info_barras_mcr.place(x=1,y=1,width=100)

# label area_req_mcr
label_area_req_mcr = tk.Label(labelframe_reporte,text="",bg="yellow")
#label_area_req_mcr.place(x=1,y=30,width=100)

# label area_barra_mcr
label_area_barra_mcr = tk.Label(labelframe_reporte,text="",bg="green")
#label_area_barra_mcr.place(x=1,y=50,width=100)

# label num_barra_mcr
label_num_barra_mcr = tk.Label(labelframe_reporte,text="",bg="orange")
#label_num_barra_mcr.place(x=110,y=50,width=100)

# label diametro_traccion
label_diametro_traccion = tk.Label(labelframe_reporte,text="",bg="red")
#label_diametro_traccion.place(x=1,y=1,width=100)

# label Ld_traccion
label_Ld_traccion = tk.Label(labelframe_reporte,text="",bg="blue")
#label_Ld_traccion.place(x=1,y=30,width=100)

# label diametro_compresion
label_diametro_compresion = tk.Label(labelframe_reporte,text="",bg="green")
#label_diametro_compresion.place(x=1,y=55,width=100)

# label diametro Ldc 
label_Ldc_compresion = tk.Label(labelframe_reporte,text="",bg="yellow")
#label_Ldc_compresion.place(x=110,y=55,width=100)

# label ldh_t
label_ldh_t = tk.Label(labelframe_reporte,text="",bg="white")
#label_ldh_t.place(x=220,y=55,width=100)

# label ldh_c 
label_ldh_c = tk.Label(labelframe_reporte,text="",bg="grey")
#label_ldh_c.place(x=330,y=55,width=100)

# label gancho 
label_gancho_anclaje = tk.Label(labelframe_reporte,text="",bg="pink")
#label_gancho_anclaje.place(x=440,y=55,width=100)

# label longitud_t
label_longitud_t = tk.Label(labelframe_reporte,text="",bg="red")
#label_longitud_t.place(x=1,y=1,width=100)

# label longitud_c
label_longitud_c = tk.Label(labelframe_reporte,text="",bg="blue")
#label_longitud_c.place(x=1,y=20,width=100)

# Label ancho_columna
label_ancho_columna = tk.Label(labelframe_reporte,text="",bg="green")
#label_ancho_columna.place(x=1,y=50,width=100)

# numero de ramas
label_num_ramas = tk.Label(labelframe_reporte,text="",bg="red")
#label_num_ramas.place(x=1,y=1,width=100)

# Smax_estribos
Smax_estribos = tk.Label(labelframe_reporte,text="",bg="blue")
#Smax_estribos.place(x=100,y=1,width=100)

# Av_area requerida 
label_Av_requerida = tk.Label(labelframe_reporte,text="",bg="red")
#label_Av_requerida.place(x=210,y=1,width=100)

# Vs_resistencia_req
Vs_resistencia_req = tk.Label(labelframe_reporte,text="",bg="green")
#Vs_resistencia_req.place(x=320,y=1,width=100)

# label_Vu
label_Vu = tk.Label(labelframe_reporte,text="",bg="blue")
#label_Vu.place(x=1,y=20,width=100)

# label_ɸVc
label_ɸVc = tk.Label(labelframe_reporte,text="",bg="green")
#label_ɸVc.place(x=110,y=20,width=100)

# label_ɸVc/2 
label_ɸVc_2 = tk.Label(labelframe_reporte,text="",bg="yellow")
#label_ɸVc_2.place(x=220,y=20,width=100)

# entry_base_triangulo
entry_base_triangulo = tk.Entry(labelframe_reporte)
#entry_base_triangulo.place(x=100,y=20,width=100)

#entry_S
entry_S = tk.Entry(labelframe_reporte)
#entry_S.place(x=10,y=10)

# label Vs_resistencia
Vs_resistencia = tk.Label(labelframe_reporte,text="",bg="yellow")
#Vs_resistencia.place(x=220,y=20,width=100)

# labe_check_Vs 
label_check_Vs = tk.Label(labelframe_reporte,text="",bg="red")
#label_check_Vs.place(x=220,y=20,width=100)

# label_check_control
label_check_control = tk.Label(labelframe_reporte,text="",bg="blue")
#label_check_control.place(x=100,y=20,width=100)

# Label_check_ramas
Label_check_ramas = tk.Label(labelframe_reporte,text="",bg="blue")
#Label_check_ramas.place(x=100,y=20,width=100)

# Label_check_separacion
Label_check_separacion = tk.Label(labelframe_reporte,text="",bg="red")
#Label_check_separacion.place(x=220,y=20,width=100)

#label_ɸVn 
label_ɸVn = tk.Label(labelframe_reporte,text="",bg="red")
#label_ɸVn.place(x=100,y=20,width=100)

#label_Vu_ɸVn
label_Vu_ɸVn = tk.Label(labelframe_reporte,text="",bg="green")
#label_Vu_ɸVn.place(x=210,y=20,width=100)

#label_check_Vu_ɸVn
label_check_Vu_ɸVn= tk.Label(labelframe_reporte,text="",bg="blue")
#label_check_Vu_ɸVn.place(x=100,y=20,width=100)

# Crear un Canvas y agregarlo al LabelFrame
canvas_cortante_1 = tk.Canvas(frame_ventana_cortante)
canvas_cortante_1.pack(fill="both", expand=True)

# Crear un Scrollbar vertical
scrollbar_y_1 = tk.Scrollbar(frame_ventana_cortante, orient="vertical", command=canvas_cortante_1.yview)
scrollbar_y_1.place(x=565,y=1,width=20,height=495)

# Vincular el Scrollbar vertical al Canvas
canvas_cortante_1.config(yscrollcommand=scrollbar_y_1.set)

# Añadir contenido al Canvas_cortante
labelframe_cortante_verificar = tk.LabelFrame(canvas_cortante_1,text="Análisis de resistencia a cortante [V]")
labelframe_cortante_check = tk.LabelFrame(canvas_cortante_1,text="Verificación resistencia a cortante del concreto [ɸVc]")
label_cortante_check_Vs = tk.Label(labelframe_cortante_check,text="",justify="left",anchor="center",wraplength=400)
label_cortante_check_Vs.place(x=10,y=15)
labelframe_control_tamaño = tk.LabelFrame(canvas_cortante_1,text="Control del tamaño de la sección del concreto [VG]")
label_control_check = tk.Label(labelframe_control_tamaño,text="",justify="left",anchor="center",wraplength=400)
label_control_check.place(x=10,y=15)
labelframe_cortante_separacion = tk.LabelFrame(canvas_cortante_1,text="Separación máxima y resistencia de estribos [S]")
labelframe_cortante_check_separacion = tk.LabelFrame(canvas_cortante_1,text="Análisis de la resistencia de estribos en función de su separación")
label_cortante_check_separacion = tk.Label(labelframe_cortante_check_separacion,text="",justify="left",anchor="center",wraplength=400)
label_cortante_check_separacion.place(x=10,y=40)
label_cortante_check_ramas = tk.Label(labelframe_cortante_check_separacion,text="",justify="left",anchor="center",wraplength=400)
label_cortante_check_ramas.place(x=10,y=1)
labelframe_cortante_capacidad = tk.LabelFrame(canvas_cortante_1,text="Análisis comparativo por capacidad de resistencia a cortante [ɸVn]")
labelframe_cortante_capacidad_check = tk.LabelFrame(canvas_cortante_1,text="Verificación capacidad de resistencia a cortante [ɸVn]")
label_cortante_capacidad_check = tk.Label(labelframe_cortante_capacidad_check,text="",justify="left",anchor="center",wraplength=400)
label_cortante_capacidad_check.place(x=10,y=15)


# Crear un Scrollbar vertical
scrollbar_y = tk.Scrollbar(frame_ventana_flexion, orient="vertical", command=canvas_flexion.yview)
scrollbar_y.place(x=565,y=1,width=20,height=495)

# Vincular el Scrollbar vertical al Canvas
canvas_flexion.config(yscrollcommand=scrollbar_y.set)

# Añadir contenido al Canvas_flexion 
labelframe_flexion_verificar = tk.LabelFrame(canvas_flexion,text="Análisis comparativo de diseño flexión")
labelframe_flexion_check = tk.LabelFrame(canvas_flexion,text="Verificación de diseño flexión")
label_check = tk.Label(labelframe_flexion_check, text="", fg="black", font=("Arial", 8, "bold"), justify="center", anchor="center",wraplength=400 )
label_check.pack(padx=10, pady=10, fill="both", expand=True)
labelframe_As= tk.LabelFrame(canvas_flexion,text="Análisis del momento último por el acero requerido [As]")
labelframe_As_check = tk.LabelFrame(canvas_flexion,text="Resultados de Ancho y Acero Asignado [As]")
label_check_As= tk.Label(labelframe_As_check,text="",justify="center",anchor="center",wraplength=400)
label_check_As.place(x=10,y=10)
label_check_info = tk.Label(labelframe_As_check,text="",justify="center",anchor="center",wraplength=500)
label_check_info.place(x=10,y=40)
labelframe_flexion_Mcr = tk.LabelFrame(canvas_flexion,text="Análisis de Mcr y refuerzo de acero [As']")
labelframe_check_Mcr = tk.LabelFrame(canvas_flexion,text="Resultados zona de compresión [As']")
label_check_Mcr= tk.Label(labelframe_check_Mcr,text="",justify="left",anchor="center",wraplength=400)
label_check_Mcr.place(x=10,y=10)
label_check_desarrollo = tk.Label(labelframe_check_Mcr,text="")
label_check_desarrollo.place(x=10,y=50)
labelframe_Ld_traccion = tk.LabelFrame(canvas_flexion,text="Análisis de longitud de desarrollo mínimo a tracción [Ld]")
labelframe_ld_compresion = tk.LabelFrame(canvas_flexion,text="Análisis de longitud de desarrollo mínimo a compresión [Ldc]")
labelframe_ganchos_ldh = tk.LabelFrame(canvas_flexion,text="Análisis de longitud de desarrollo mínimo con ganchos [Ldh]")
labelframe_ganchos_check = tk.LabelFrame(canvas_flexion,text="")
label_ganchos_check = tk.Label(labelframe_ganchos_check,text="",justify="center",anchor="center",wraplength=405)
label_ganchos_check.place(x=10,y=17)

frame_check_on = tk.Frame(labelframe_As_check,bd=2,relief="flat")
frame_check_on.place(x=450,y=10,width=50,height=50)
label_icon = tk.Label(frame_check_on)
label_icon.place(relwidth=1, relheight=1)

frame_check_on_Mcr = tk.Frame(labelframe_check_Mcr,bd=2,relief="flat")
frame_check_on_Mcr.place(x=450,y=10,width=50,height=50)
label_icon_Mcr = tk.Label(frame_check_on_Mcr)
label_icon_Mcr.place(relwidth=1, relheight=1)

frame_check_on_Ld = tk.Frame(labelframe_ganchos_check,bd=2,relief="flat")
frame_check_on_Ld.place(x=450,y=15,width=50,height=50)
label_icon_Ld = tk.Label(frame_check_on_Ld )
label_icon_Ld.place(relwidth=1, relheight=1)

frame_check_on_cortante = tk.Frame(labelframe_cortante_check ,bd=2,relief="flat")
frame_check_on_cortante.place(x=450,y=15,width=50,height=50)
label_icon_cortante = tk.Label(frame_check_on_cortante)
label_icon_cortante.place(relwidth=1, relheight=1)

frame_check_on_cortante_1 = tk.Frame(labelframe_control_tamaño ,bd=2,relief="flat")
frame_check_on_cortante_1.place(x=450,y=15,width=50,height=50)
label_icon_cortante_1 = tk.Label(frame_check_on_cortante_1)
label_icon_cortante_1.place(relwidth=1, relheight=1)

frame_check_on_cortante_2 = tk.Frame(labelframe_cortante_check_separacion,bd=2,relief="flat")
frame_check_on_cortante_2.place(x=450,y=15,width=50,height=50)
label_icon_cortante_2 = tk.Label(frame_check_on_cortante_2)
label_icon_cortante_2.place(relwidth=1, relheight=1)

frame_check_on_cortante_3 = tk.Frame(labelframe_cortante_capacidad_check,bd=2,relief="flat")
frame_check_on_cortante_3.place(x=450,y=15,width=50,height=50)
label_icon_cortante_3 = tk.Label(frame_check_on_cortante_3)
label_icon_cortante_3.place(relwidth=1, relheight=1)



# Redimensionar la imagen al tamaño del frame (20x20)
image_on = Image.open("Iconos_proyecto/on_on_on.png")
image_on = image_on.resize((30, 30), Image.Resampling.LANCZOS)  
icon_check_on = ImageTk.PhotoImage(image_on)

image_off = Image.open("Iconos_proyecto/off_off_off.png")
image_off = image_off.resize((30, 30), Image.Resampling.LANCZOS)  
icon_check_off = ImageTk.PhotoImage(image_off)

"***************************************TREEVIEW PRIMERO***********************************************"
# Crear el primer Treeview 
treeview_flexion = ttk.Treeview(labelframe_flexion_verificar, columns=("Mmax_Mmin", "Mu_kNm", "Cuantia", "ϕMn_kNm", "Mu ≤ ϕMn"), show="headings")
treeview_flexion.place(x=10,y=20,width=500,height=100)
# Crear el primer Treeview de cortante
treeview_cortante_1 = ttk.Treeview(labelframe_cortante_verificar, columns=("Wu", "Vmax", "Vu", "ϕVc", "ϕVc/2","Vs"), show="headings")
treeview_cortante_1.place(x=10,y=20,width=500,height=100)

# Establecer los encabezados de las columnas
treeview_flexion.heading("Mmax_Mmin", text="Mmax / Mmin")
treeview_flexion.heading("Mu_kNm", text="Mu [kNm]")
treeview_flexion.heading("Cuantia", text="Cuantia")
treeview_flexion.heading("ϕMn_kNm", text="ɸMn [kNm]")
treeview_flexion.heading("Mu ≤ ϕMn", text="Mu ≤ ɸMn")
treeview_cortante_1.heading("Wu",text="Wu")
treeview_cortante_1.heading("Vmax",text="Vmax")
treeview_cortante_1.heading("Vu",text="Vu")
treeview_cortante_1.heading("ϕVc",text="ϕVc")
treeview_cortante_1.heading("ϕVc/2",text="ϕVc/2")
treeview_cortante_1.heading("Vs",text="Vs")

# Modificar el ancho de las columnas
treeview_flexion.column("Mmax_Mmin", width=100, stretch=False, anchor="center")
treeview_flexion.column("Mu_kNm", width=100, stretch=False, anchor="center")
treeview_flexion.column("Cuantia", width=100, stretch=False, anchor="center")
treeview_flexion.column("ϕMn_kNm", width=100, stretch=False, anchor="center")
treeview_flexion.column("Mu ≤ ϕMn", width=100, stretch=False, anchor="center")
treeview_cortante_1.column("Wu", width=83, stretch=False, anchor="center")
treeview_cortante_1.column("Vmax", width=83, stretch=False, anchor="center")
treeview_cortante_1.column("Vu", width=83, stretch=False, anchor="center")
treeview_cortante_1.column("ϕVc", width=83, stretch=False, anchor="center")
treeview_cortante_1.column("ϕVc/2", width=83, stretch=False, anchor="center")
treeview_cortante_1.column("Vs", width=83, stretch=False, anchor="center")

# Definir algunas filas de ejemplo
treeview_flexion.insert("", "end", values=("Mu[-]", "", "", "", ""))
treeview_flexion.insert("", "end", values=("Mu[+]", "", "", "", ""))
treeview_flexion.insert("", "end", values=("Mu[-]", "", "", "", ""))
treeview_cortante_1.insert("", "end", values=("", "", "", "", "",""))

#Contenido Canvas_Flexion
label_flexion_a = tk.Label(canvas_flexion,text="")
#Contenido canvas_cortante_1
label_cortante_a = tk.Label(canvas_cortante_1,text="")

# Función para restaurar el tamaño de las columnas después de intentar redimensionar
def no_resize(event):
    
    for col in treeview_cortante_1["columns"]:
        treeview_cortante_1.column(col, width=83)  

# Vincular el evento de ButtonRelease-1 para evitar el redimensionamiento
treeview_cortante_1.bind("<ButtonRelease-1>", no_resize)

# Función para restaurar el tamaño de las columnas después de intentar redimensionar
def no_resize(event):
    
    for col in treeview_flexion["columns"]:
        treeview_flexion.column(col, width=100)  

# Vincular el evento de ButtonRelease-1 para evitar el redimensionamiento
treeview_flexion.bind("<ButtonRelease-1>", no_resize)

"***************************************TREEVIEW SEGUNDO***********************************************"
# Crear el segundo Treeview 
treeview_refuerzo = ttk.Treeview(labelframe_As, columns=("Mu_kNm", "As_mm2", "#Barra", "Base_requerida"), show="headings")
treeview_refuerzo.place(x=10,y=20,width=500,height=100)
# Crear el segundo Treeview cortante
treeview_cortante_2 = ttk.Treeview(labelframe_cortante_separacion,columns=("Smax", "Av", "#Ramas", "Vs"), show="headings")
treeview_cortante_2.place(x=10,y=20,width=500,height=100)

# Definir los encabezados de las columnas
treeview_refuerzo.heading("#1", text="Mu [kNm]")
treeview_refuerzo.heading("#2", text="As [mm²]")
treeview_refuerzo.heading("#3", text="#Barra")
treeview_refuerzo.heading("#4", text="Base requerida")
treeview_cortante_2.heading("Smax", text="Smax")
treeview_cortante_2.heading("Av", text="Av")
treeview_cortante_2.heading("#Ramas", text="#Ramas")
treeview_cortante_2.heading("Vs", text="Vs")


# Modificar el ancho de las columnas
treeview_refuerzo.column("#1", width=100, stretch=False, anchor="center")
treeview_refuerzo.column("#2", width=100, stretch=False, anchor="center")
treeview_refuerzo.column("#3", width=100, stretch=False, anchor="center")
treeview_refuerzo.column("#4", width=195, stretch=False, anchor="center")
treeview_cortante_2.column("Smax", width=124, stretch=False, anchor="center")
treeview_cortante_2.column("Av", width=124, stretch=False, anchor="center")
treeview_cortante_2.column("#Ramas", width=124, stretch=False, anchor="center")
treeview_cortante_2.column("Vs", width=124, stretch=False, anchor="center")

# Agregar las filas con la información
treeview_refuerzo.insert("", "end", values=("", "", "", ""))
treeview_refuerzo.insert("", "end",  values=("", "", "", ""))
treeview_refuerzo.insert("", "end",  values=("", "", "", ""))
treeview_cortante_2.insert("", "end",  values=("", "", "", ""))

# Función para restaurar el tamaño de la columna 4 después de intentar redimensionar
def no_resize(event):
    # Restaurar el tamaño original solo de la columna 4
    treeview_cortante_2.column("Smax", width=124, stretch=False, anchor="center")
    treeview_cortante_2.column("Av", width=124, stretch=False, anchor="center")
    treeview_cortante_2.column("#Ramas", width=124, stretch=False, anchor="center")
    treeview_cortante_2.column("Vs", width=124, stretch=False, anchor="center")

# Vincular el evento de ButtonRelease-1 para evitar el redimensionamiento
treeview_cortante_2.bind("<ButtonRelease-1>", no_resize)

# Función para restaurar el tamaño de la columna 4 después de intentar redimensionar
def no_resize(event):
    # Restaurar el tamaño original solo de la columna 4
    treeview_refuerzo.column("#1", width=100, stretch=False, anchor="center")
    treeview_refuerzo.column("#2", width=100, stretch=False, anchor="center")
    treeview_refuerzo.column("#3", width=100, stretch=False, anchor="center")
    treeview_refuerzo.column("#4", width=195, stretch=False, anchor="center")


# Vincular el evento de ButtonRelease-1 para evitar el redimensionamiento
treeview_refuerzo.bind("<ButtonRelease-1>", no_resize)

"***************************************TREEVIEW TERCERO***********************************************"
# Crear el Tercero Treeview
treeview_Mcr = ttk.Treeview(labelframe_flexion_Mcr, columns=("Viga", "Mcr", "𝞀min", "As'", "#Barras"), show="headings")
treeview_Mcr.place(x=10, y=20, width=500, height=100)
# Crear el Tercero Treeview cortante
treeview_cortante_3 = ttk.Treeview(labelframe_cortante_capacidad, columns=("Vs", "Vu", "ϕVn", "Vu≤ϕVn"), show="headings")
treeview_cortante_3.place(x=10, y=20, width=500, height=100)

# Definir los encabezados de las columnas
treeview_Mcr.heading("Viga", text="Viga")
treeview_Mcr.heading("Mcr", text="Mcr [kNm]")
treeview_Mcr.heading("𝞀min", text="𝞀min")
treeview_Mcr.heading("As'", text="As' [mm²]")
treeview_Mcr.heading("#Barras", text="#Barra")
treeview_cortante_3.heading("Vs", text="Vs")
treeview_cortante_3.heading("Vu", text="Vu")
treeview_cortante_3.heading("ϕVn", text="ϕVn")
treeview_cortante_3.heading("Vu≤ϕVn", text="Vu≤ϕVn")

# Modificar el ancho de las columnas
treeview_Mcr.column("Viga", width=100, stretch=False, anchor="center")
treeview_Mcr.column("Mcr", width=100, stretch=False, anchor="center")
treeview_Mcr.column("𝞀min", width=100, stretch=False, anchor="center")
treeview_Mcr.column("As'", width=100, stretch=False, anchor="center")
treeview_Mcr.column("#Barras",width=100, stretch=False, anchor="center")
treeview_cortante_3.column("Vs",width=124, stretch=False, anchor="center")
treeview_cortante_3.column("Vu",width=124, stretch=False, anchor="center")
treeview_cortante_3.column("ϕVn",width=124, stretch=False, anchor="center")
treeview_cortante_3.column("Vu≤ϕVn",width=124, stretch=False, anchor="center")

# Insertar filas en el Treeview
treeview_Mcr.insert("", "end", values=("", "", "", "", ""))
treeview_Mcr.insert("", "end", values=("", "", "", "", ""))
treeview_Mcr.insert("", "end", values=("", "", "", "", ""))
treeview_cortante_3.insert("", "end", values=("", "", "", ""))

def no_resize(event):
    treeview_cortante_3.column("Vs", width=124, stretch=False, anchor="center")
    treeview_cortante_3.column("Vu", width=124, stretch=False, anchor="center")
    treeview_cortante_3.column("ϕVn", width=124, stretch=False, anchor="center")
    treeview_cortante_3.column("Vu≤ϕVn", width=124, stretch=False, anchor="center")

# Vincular el evento de ButtonRelease-1 para evitar el redimensionamiento
treeview_cortante_3.bind("<ButtonRelease-1>", no_resize)

# Función para restaurar el tamaño de la columna 4 después de intentar redimensionar
def no_resize(event):
    treeview_Mcr.column("Viga", width=100, stretch=False, anchor="center")
    treeview_Mcr.column("Mcr", width=100, stretch=False, anchor="center")
    treeview_Mcr.column("𝞀min", width=100, stretch=False, anchor="center")
    treeview_Mcr.column("As'", width=100, stretch=False, anchor="center")
    treeview_Mcr.column("#Barras",width=100, stretch=False, anchor="center")

# Vincular el evento de ButtonRelease-1 para evitar el redimensionamiento
treeview_Mcr.bind("<ButtonRelease-1>", no_resize)

"***************************************TREEVIEW CUARTO***********************************************"
# Crear el cuarto Treeview
treeview_Ld_1 = ttk.Treeview(labelframe_Ld_traccion, columns=("As", "Barra", "ØBarra","Ld"), show="headings")
treeview_Ld_1.place(x=10, y=20, width=500, height=100)

# Definir los encabezados de las columnas
treeview_Ld_1.heading("As", text="As")
treeview_Ld_1.heading("Barra", text="#Barra")
treeview_Ld_1.heading("ØBarra", text="ØBarra [mm]")
treeview_Ld_1.heading("Ld", text="Ld [cm]")

# Modificar el ancho de las columnas
treeview_Ld_1.column("As", width=124, stretch=False, anchor="center")
treeview_Ld_1.column("Barra", width=124, stretch=False, anchor="center")
treeview_Ld_1.column("ØBarra", width=124, stretch=False, anchor="center")
treeview_Ld_1.column("Ld", width=125, stretch=False, anchor="center")

# Insertar filas iniciales en el Treeview con identificadores únicos
fila1_id = treeview_Ld_1.insert("", "end", values=("As[-]", "", "", ""))
fila2_id = treeview_Ld_1.insert("", "end", values=("As[+]", "", "", ""))
fila3_id = treeview_Ld_1.insert("", "end", values=("As[-]", "", "", ""))

# Función para restaurar el tamaño de las columnas después de intentar redimensionar
def no_resize(event):
    treeview_Ld_1.column("As", width=124, stretch=False, anchor="center")
    treeview_Ld_1.column("Barra", width=124, stretch=False, anchor="center")
    treeview_Ld_1.column("ØBarra", width=124, stretch=False, anchor="center")
    treeview_Ld_1.column("Ld", width=124, stretch=False, anchor="center")

# Vincular el evento de ButtonRelease-1 para evitar el redimensionamiento
treeview_Ld_1.bind("<ButtonRelease-1>", no_resize)

"***************************************TREEVIEW QUINTO***********************************************"
# Crear el quinto Treeview
treeview_Ldc = ttk.Treeview(labelframe_ld_compresion, columns=("As", "Barra", "ØBarra","Ldc"), show="headings")
treeview_Ldc.place(x=10, y=20, width=500, height=100)

# Definir los encabezados de las columnas
treeview_Ldc.heading("As", text="As")
treeview_Ldc.heading("Barra", text="#Barra")
treeview_Ldc.heading("ØBarra", text="ØBarra [mm]")
treeview_Ldc.heading("Ldc", text="Ldc [cm]")

# Modificar el ancho de las columnas
treeview_Ldc.column("As", width=124, stretch=False, anchor="center")
treeview_Ldc.column("Barra", width=124, stretch=False, anchor="center")
treeview_Ldc.column("ØBarra", width=124, stretch=False, anchor="center")
treeview_Ldc.column("Ldc", width=124, stretch=False, anchor="center")

# Insertar filas iniciales en el Treeview con identificadores únicos
fila1_ldc = treeview_Ldc.insert("", "end", values=("As'", "", "", ""))

# Función para restaurar el tamaño de las columnas después de intentar redimensionar
def no_resize(event):
    treeview_Ldc.column("As", width=124, stretch=False, anchor="center")
    treeview_Ldc.column("Barra", width=124, stretch=False, anchor="center")
    treeview_Ldc.column("ØBarra", width=124, stretch=False, anchor="center")
    treeview_Ldc.column("Ldc", width=124, stretch=False, anchor="center")

# Vincular el evento de ButtonRelease-1 para evitar el redimensionamiento
treeview_Ldc.bind("<ButtonRelease-1>", no_resize)

"***************************************TREEVIEW SEXTO***********************************************"
# Crear el sexto Treeview
treeview_ganchos_Ldh = ttk.Treeview(labelframe_ganchos_ldh, columns=("Zona", "Barras", "Ldh","Gancho","Longitud"), show="headings")
treeview_ganchos_Ldh.place(x=10, y=20, width=500, height=100)

# Definir los encabezados de las columnas
treeview_ganchos_Ldh.heading("Zona", text="Zona")
treeview_ganchos_Ldh.heading("Barras", text="#Barra")
treeview_ganchos_Ldh.heading("Ldh", text="Ldh [cm]")
treeview_ganchos_Ldh.heading("Gancho", text="Gancho")
treeview_ganchos_Ldh.heading("Longitud", text="Longitud [cm]")

# Modificar el ancho de las columnas
treeview_ganchos_Ldh.column("Zona", width=99, stretch=False, anchor="center")
treeview_ganchos_Ldh.column("Barras", width=99, stretch=False, anchor="center")
treeview_ganchos_Ldh.column("Ldh", width=99, stretch=False, anchor="center")
treeview_ganchos_Ldh.column("Gancho", width=99, stretch=False, anchor="center")
treeview_ganchos_Ldh.column("Longitud", width=99, stretch=False, anchor="center")

# Insertar filas iniciales en el Treeview con identificadores únicos
fila_gancho_1 = treeview_ganchos_Ldh.insert("", "end", values=("Tracción", "", "", "", ""))
fila_gancho_2 = treeview_ganchos_Ldh.insert("", "end", values=("Compresión", "", "", "", ""))

# Función para restaurar el tamaño de las columnas después de intentar redimensionar
def no_resize(event):
    treeview_ganchos_Ldh.column("Zona", width=99, stretch=False, anchor="center")
    treeview_ganchos_Ldh.column("Barras", width=99, stretch=False, anchor="center")
    treeview_ganchos_Ldh.column("Ldh", width=99, stretch=False, anchor="center")
    treeview_ganchos_Ldh.column("Gancho", width=99, stretch=False, anchor="center")
    treeview_ganchos_Ldh.column("Longitud", width=99, stretch=False, anchor="center")

# Vincular el evento de ButtonRelease-1 para evitar el redimensionamiento
treeview_ganchos_Ldh.bind("<ButtonRelease-1>", no_resize)

# Propiedad para insertar contenido en el canvas_flexion
canvas_flexion.create_window(100,300,window=label_flexion_a)
canvas_flexion.create_window(375,120,window=labelframe_flexion_verificar,width=525,height=170)
canvas_flexion.create_window(375,270,window=labelframe_flexion_check,width=525,height=100)
canvas_flexion.create_window(375,420,window=labelframe_As,width=525,height=170)
canvas_flexion.create_window(375,570,window=labelframe_As_check,width=525,height=100)
canvas_flexion.create_window(375,720,window=labelframe_flexion_Mcr,width=525,height=170)
canvas_flexion.create_window(375,870,window=labelframe_check_Mcr,width=525,height=100)
canvas_flexion.create_window(375,1020,window=labelframe_Ld_traccion,width=525,height=170)
canvas_flexion.create_window(375,1200,window=labelframe_ld_compresion,width=525,height=170)
canvas_flexion.create_window(375,1380,window=labelframe_ganchos_ldh,width=525,height=170)
canvas_flexion.create_window(375,1530,window=labelframe_ganchos_check,width=525,height=100)

# Propiedad par insertar contenido en el canvas_cortante_1
canvas_cortante_1.create_window(100,300,window=label_cortante_a)
canvas_cortante_1.create_window(375,120,window=labelframe_cortante_verificar,width=525,height=170)
canvas_cortante_1.create_window(375,270,window=labelframe_cortante_check,width=525,height=100)
canvas_cortante_1.create_window(375,380,window=labelframe_control_tamaño,width=525,height=100)
canvas_cortante_1.create_window(375,530,window=labelframe_cortante_separacion,width=525,height=170)
canvas_cortante_1.create_window(375,680,window=labelframe_cortante_check_separacion,width=525,height=100)
canvas_cortante_1.create_window(375,830,window=labelframe_cortante_capacidad,width=525,height=170)
canvas_cortante_1.create_window(375,980,window=labelframe_cortante_capacidad_check,width=525,height=100)

# Ajustar el tamaño del canvas y el área de desplazamiento
def update_scrollregion(event=None):
    bbox = canvas_cortante_1.bbox("all")  
    if bbox:
        # Añadir un margen adicional de 100 píxeles a las coordenadas del área
        canvas_cortante_1.config(scrollregion=(0, 0, bbox[2] + 500, bbox[3] + 50))

# Llamar a update_scrollregion para ajustar el área de desplazamiento
canvas_cortante_1.bind("<Configure>", update_scrollregion)

# Hacer que el contenido del canvas sea desplazable
canvas_cortante_1.config(scrollregion=canvas_cortante_1.bbox("all"))

# Ajustar el tamaño del canvas y el área de desplazamiento
def update_scrollregion(event=None):
    bbox = canvas_flexion.bbox("all")  
    if bbox:
        # Añadir un margen adicional de 100 píxeles a las coordenadas del área
        canvas_flexion.config(scrollregion=(0, 0, bbox[2] + 500, bbox[3] + 50))

# Llamar a update_scrollregion para ajustar el área de desplazamiento
canvas_flexion.bind("<Configure>", update_scrollregion)

# Hacer que el contenido del canvas sea desplazable
canvas_flexion.config(scrollregion=canvas_flexion.bbox("all"))

# Empacar el Notebook dentro de frame_interno
notebook_flexion.pack(fill="both", expand=True)  

# Función para actualizar cuando se cambia el valor en entry_flexion_recubrimiento
def actualizar_profundidad(event):
    # Llamar a actualizar_dimensiones para recalcular Altura_d cuando recubrimiento cambie
    actualizar_dimensiones(event)

# Variable para controlar el estado de los radiobuttons (marca inicial)
estado_estribo = tk.StringVar()

# Función para actualizar el label del estribo y el área
def actualizar_label_estribo(valor):
    # Actualizar el texto en el label_prueba_estribo
    label_prueba_estribo.config(text=f"{valor} mm")
    
    # Cambiar el valor de la variable para asegurar que solo uno esté seleccionado
    estado_estribo.set(valor)
    
    # Determinar el tipo de estribo y el área correspondiente
    if valor == 9.5:
        tipo_estribo = "E#3"
        area_estribo = 71  # Área para E#3
    elif valor == 12.7:
        tipo_estribo = "E#4"
        area_estribo = 129  # Área para E#4
    else:
        tipo_estribo = "Desconocido"
        area_estribo = 0

    # Actualizar los labels con el tipo de estribo y el área
    label_estribo.config(text=f"{tipo_estribo}")
    label_area_estribo.config(text=f"{area_estribo} mm²")

label_prueba_estribo= tk.Label(ventana,text="",bg="red")
#label_prueba_estribo.place(x=500,y=680,width=100)

frame_ventana_viga_1 = tk.Frame(ventana, bd=10, relief="ridge", bg="white")
frame_ventana_viga_1.place(x=437, y=405, width=400, height=370)

# Crear un Label dentro del frame para mostrar la imagen
label_imagen = tk.Label(frame_ventana_viga_1, bg="white")
label_imagen.pack(fill="both", expand=True)

label_titulo_viga_1 =  tk.Label(frame_ventana_viga_1,text="Detalle armado de viga",bd=2,relief="raise")
label_titulo_viga_1.place(x=1,y=1,width=380,height=35)

label_subtitulo_viga_1 = tk.Frame(frame_ventana_viga_1,bd=2,relief="raise")
label_subtitulo_viga_1.place(x=1,y=315,width=380,height=35)


# Menú "Definir" con opciones
menu_seccion_transversal = tk.Menu(menu_definir, tearoff=0)
menu_definir.add_command(label="Materiales", image=icono_materiales, compound="left",command=abrir_ventana_materiales)
menu_seccion_transversal.add_command(label="Propiedades geométricas de la sección", image=icono_seccion_viga, compound="left",command=abrir_ventana_seccion_transversal)
menu_definir.add_cascade(label="Sección transversal", menu=menu_seccion_transversal, image=icono_seccion_transversal, compound="left")
menu_bar.add_cascade(label="Definir", menu=menu_definir)

# Menú "Asignar"
menu_asignar = tk.Menu(menu_bar, tearoff=0)
menu_bar.add_cascade(label="Asignar", menu=menu_asignar)
menu_asignar.add_command(label="Apoyos",image=icono_asignar_apoyos,compound="left",command=abrir_ventana_apoyos)
menu_asignar.add_command(label="Cargas",image=icono_asignar_cargas,compound="left",command=abrir_ventana_cargas)

# Menú "Gráficos"
menu_graficos = tk.Menu(menu_bar, tearoff=0)
menu_bar.add_cascade(label="Gráficos", menu=menu_graficos)
menu_graficos.add_command(label="Diagramas V & M",image=icono_graficos,compound="left",command=abrir_ventana_graficos)
menu_graficos.add_command(label="Panel de modelado",image=icono_model_3D,compound="left",command=Abrir_ventana_Detalle_Structural)

# Menú "Diseño Flexión"
menu_diseño_flexion = tk.Menu(menu_bar, tearoff=0)
menu_bar.add_cascade(label="Diseño Flexión", menu=menu_diseño_flexion)
# Crear un submenú para "Concreto reforzado" y agregar la opción "Cálculos previos"
submenu_calculos = tk.Menu(menu_diseño_flexion, tearoff=0)
submenu_calculos.add_command(label="Cálculos previos",image=icono_calculos,compound="left",command=abrir_ventana_flexion)
# Agregar "Concreto reforzado" con el submenú "Cálculos previos"
menu_diseño_flexion.add_cascade(label="Concreto reforzado", image=icono_flexion, compound="left", menu=submenu_calculos)
menu_diseño_flexion.add_cascade(label="Barras de refuerzo",image=icono_barras,compound="left",command=abrir_ventana_barras_refuerzo) 
menu_diseño_flexion.add_cascade(label="Calcular Mcr",image=icono_VG_AS,compound="left",command=abrir_ventana_Mcr)
menu_diseño_flexion.add_cascade(label="Longitud desarrollo",image=icono_longitud_desarrollo,compound="left",command=abrir_ventana_longitud_desarrollo)

# Menú "Diseño Cortante"
menu_diseño_cortante = tk.Menu(menu_bar, tearoff=0)
menu_bar.add_cascade(label="Diseño Cortante", menu=menu_diseño_cortante)
menu_diseño_cortante.add_command(label="Diseño cortante",image=icono_cortante,compound="left",command=abrir_ventana_cortante)

# Menú "Reportes"
menu_resportes_docs = tk.Menu(menu_bar, tearoff=0)
menu_bar.add_cascade(label="Reportes", menu=menu_resportes_docs)
menu_resportes_docs.add_command(label="Reporte - Diseño flexión",image=icono_Doc_word,compound="left",command=Generar_reportes)
menu_resportes_docs.add_command(label="Reporte - Diseño Cortante",image=icono_Doc_word_cortante,compound="left",command=generar_reporte_cortante)

# Menú "Acerca del programa Pilot Structural"
menu_acerca_pilot = tk.Menu(menu_bar,tearoff=0)
menu_bar.add_cascade(label="Acerca de Pilot Structural", menu=menu_acerca_pilot)
menu_acerca_pilot.add_command(label="Sobre el programa",image=icono_pilot_structural,compound="left",command=Abrir_ventana_Pilot_Structural)

# Mostrar la barra de menús
ventana.config(menu=menu_bar)

# ----------------------------
# Crear la barra de herramientas (Toolbar)
# ----------------------------

# Crear un frame para la barra de herramientas
toolbar = tk.Frame(ventana, bd=2, relief=tk.RAISED)
# Añadir la barra de herramientas a la ventana
toolbar.pack(side=tk.TOP, fill=tk.X)

# Crear un frame para la barra de herramientas izquierda
toolbar_1 = tk.Frame(ventana, bd=2, relief=tk.RAISED)  # Barra de herramientas con un ancho fijo
toolbar_1.place(x=1,y=35,width=35,height=738)

# Crear un frame para la barra de herramientas derecha
toolbar_2 = tk.Frame(ventana, bd=2, relief=tk.RAISED)  # Barra de herramientas con un ancho fijo
toolbar_2.place(x=1500,y=35,width=35,height=738)

# Crear los botones de la barra de herramientas toolbar
boton_nuevo_modelo = tk.Button(toolbar, image=icono_modelo_nuevo, compound="top",command=lambda: abrir_ventana_nueva())
boton_nuevo_modelo.pack(side=tk.LEFT, padx=2, pady=2)
boton_abrir_archivo = tk.Button(toolbar,image=icono_abrir_archivo,compound="top",command=abrir_archivo)
boton_abrir_archivo.pack(side=tk.LEFT, padx=2, pady=2)
boton_guardar    = tk.Button(toolbar,image=icono_guardar,compound="top",command=guardar_archivo)
boton_guardar.pack(side=tk.LEFT, padx=2, pady=2)
boton_materiales = tk.Button(toolbar, image=icono_materiales, compound="top",command=abrir_ventana_materiales)
boton_materiales.pack(side=tk.LEFT, padx=2, pady=2)
boton_seccion_viga = tk.Button(toolbar, image=icono_seccion_viga, compound="top",command=abrir_ventana_seccion_transversal)
boton_seccion_viga.pack(side=tk.LEFT, padx=2, pady=2)
boton_apoyos = tk.Button(toolbar,image=icono_asignar_apoyos,compound="top",command=abrir_ventana_apoyos)
boton_apoyos.pack(side=tk.LEFT,padx=2,pady=2)
boton_cargas = tk.Button(toolbar,image=icono_asignar_cargas,compound="top",command=abrir_ventana_cargas)
boton_cargas.pack(side=tk.LEFT,padx=2,pady=2)
boton_graficas= tk.Button(toolbar,image=icono_graficos,compound="top",command=abrir_ventana_graficos)
boton_graficas.pack(side=tk.LEFT,padx=2,pady=2)
# Crear los botones de la barra de herramientas toolbar_1
boton_calculos_previos = tk.Button(toolbar_1,image=icono_calculos,compound="top",command=abrir_ventana_flexion)
boton_calculos_previos.pack(side=tk.TOP, padx=2, pady=2, anchor="n")
boton_barras_refuerzo = tk.Button(toolbar_1,image=icono_barras,compound="top",command=abrir_ventana_barras_refuerzo)
boton_barras_refuerzo.pack(side=tk.TOP, padx=2, pady=2, anchor="n")
boton_calculo_Mcr  = tk.Button(toolbar_1,image=icono_VG_AS,compound="top",command=abrir_ventana_Mcr)
boton_calculo_Mcr.pack(side=tk.TOP,padx=2,pady=2,anchor="n")
boton_ld= tk.Button(toolbar_1,image=icono_longitud_desarrollo,compound="top",command=abrir_ventana_longitud_desarrollo)
boton_ld.pack(side=tk.TOP,padx=2,pady=2,anchor="n")
boton_cortante = tk.Button(toolbar_1,image=icono_cortante,compound="top",command=abrir_ventana_cortante)
boton_cortante.pack(side=tk.TOP,padx=2,pady=2,anchor="n")
# Crear los botones de la barra de herramientas toolbar_2
boton_info_programa = tk.Button(toolbar_2,image=icono_pilot_structural,compound="top",command=Abrir_ventana_Pilot_Structural)
boton_info_programa.pack(side=tk.TOP,padx=2,pady=2,anchor="n")
boton_doc_word = tk.Button(toolbar_2,image=icono_Doc_word,compound="top",command=Generar_reportes)
boton_doc_word.pack(side=tk.TOP,padx=2,pady=2,anchor="n")
boton_doc_word_cortante = tk.Button(toolbar_2,image=icono_Doc_word_cortante,compound="top",command=generar_reporte_cortante)
boton_doc_word_cortante.pack(side=tk.TOP,padx=2,pady=2,anchor="n")
boton_model_3D = tk.Button(toolbar_2,image=icono_model_3D,compound="top",command=Abrir_ventana_Detalle_Structural)
boton_model_3D.pack(side=tk.TOP,padx=2,pady=2,anchor="n")

# Ocultar la ventana principal mientras se muestra el splash
ventana.withdraw()

# Mostrar el splash screen antes de la ventana principal
mostrar_splash()

# Mostrar la ventana
ventana.mainloop()
