# Importaciones estándar
import math
import os
import re

# Importaciones de tkinter
import tkinter as tk
from tkinter import ttk, messagebox, filedialog,Toplevel
from tkinter import Scale, Frame, Entry, Label, NORMAL, DISABLED, END, HORIZONTAL
from tkinter import StringVar, PhotoImage
import time
import requests
import platform
from datetime import datetime
from pytz import timezone


# Importaciones de bibliotecas de terceros
from PIL import Image, ImageTk,ImageDraw
import numpy as np
import pandas as pd
import matplotlib.pyplot as plt
from matplotlib.backends.backend_pdf import PdfPages
from matplotlib.ticker import MaxNLocator
from matplotlib.backends.backend_tkagg import FigureCanvasTkAgg,NavigationToolbar2Tk
from matplotlib.figure import Figure
import matplotlib.patches as patches
from mpl_toolkits.mplot3d.art3d import Poly3DCollection
from mpl_toolkits.mplot3d import Axes3D
from matplotlib.lines import Line2D

# Importaciones para generar documentos PDF y manejar archivos
from reportlab.lib.pagesizes import letter
from reportlab.pdfgen import canvas
from reportlab.lib.units import inch
from PyPDF2 import PdfWriter, PdfReader
from fpdf import FPDF

# Importación de la librería de documentos de Word
from docx import Document
from docx.shared import Inches





"*******************************************************************************************************************************"
"Autor: Juan David Garzón Obando.              Programa: Ingeniería civil         Universidad: Universidad Piloto de Colombia"

"Proyecto: Desarrollo de un programa didáctico en Python para el análisis estructural y diseño de vigas de concreto reforzado"

"*****************************************************************************************************************************"
"*************************************************ANÁLISIS ESTRUCTURAL********************************************************"
"*****************************************************************************************************************************"

import tkinter as tk


# Variable global para controlar si la subventana ya está abierta
Ventana_Nuevo = None


# Crear la ventana principal
ventana = tk.Tk()

# Maximizar la ventana al iniciar
ventana.state('zoomed')

# Configuración de título
ventana.title("PILOT STRUCTURAL")

# Cargar y redimensionar el ícono usando PIL
ruta_icono = "Iconos_proyecto/Icono_P.png"
imagen = Image.open(ruta_icono)
imagen = imagen.resize((32, 32))  
icono = ImageTk.PhotoImage(imagen)

# Establecer el ícono de la ventana
ventana.iconphoto(True, icono)

# Establecer el tamaño mínimo de la ventana
ventana.minsize(800, 600)


# Crear la barra de menús
menu_bar = tk.Menu(ventana)

# Definir iconos
icono_guardar = None  # Aquí deberías poner la ruta de tu icono de guardar
icono_abrir_archivo = None  # Aquí deberías poner la ruta de tu icono de abrir archivo

# Definir funciones de guardar y abrir
def guardar_archivo():
    # Definir el tipo de archivo a guardar 
    archivo = filedialog.asksaveasfilename(defaultextension=".pilot", 
                                            filetypes=[("Archivos de Pilot", "*.pilot"), ("Todos los archivos", "*.*")])
    if archivo:
        try:
            # Guardar el contenido del archivo
            with open(archivo, 'w') as f:
                # Aquí debes guardar el contenido relevante de tu aplicación
                f.write("Contenido de la aplicación...")
            messagebox.showinfo("Guardado", f"Archivo guardado exitosamente: {archivo}")
        except Exception as e:
            messagebox.showerror("Error", f"No se pudo guardar el archivo: {e}")

def abrir_archivo():
    # Definir los tipos de archivo que se pueden abrir (por ejemplo .miapp)
    archivo = filedialog.askopenfilename(filetypes=[("Archivos de Pilot", "*.pilot"), ("Todos los archivos", "*.*")])
    if archivo:
        try:
            # Abrir y leer el contenido del archivo
            with open(archivo, 'r') as f:
                contenido = f.read()
                # Aquí deberías cargar el contenido en tu aplicación
                print(contenido)  # Por ejemplo, mostrar el contenido en la consola
            messagebox.showinfo("Archivo abierto", f"Archivo abierto exitosamente: {archivo}")
        except Exception as e:
            messagebox.showerror("Error", f"No se pudo abrir el archivo: {e}")
            


# Parámetros de la viga empotrada
base_viga = 0.40
altura_viga = 0.40
longitud_viga = 1
base_columna = 0.5
altura_columna = 1
longitud_columna = -0.2
desfase_estribo = 0.05

# Parámetros de la viga apoyada
base_viga_apoyada = 0.40
altura_viga_apoyada = 0.40
longitud_viga_apoyada = 1
base_piramide = -0.2
altura_piramdie = -0.5
longitud_piramide = -0.2
desfase_estribo = 0.05

# Función que se ejecuta al hacer clic en el botón
def on_boton_aplicar_click(label_contenido_1, label_prueba):
    # Obtener el texto actual del label
    tipo_viga = label_prueba.cget("text")
    
    # Comprobamos si el texto de `label_prueba` tiene el valor esperado
    if tipo_viga not in ["Viga apoyada", "Viga empotrada"]:
        print("Texto en label_prueba no válido.")
        return
    
    # Eliminar solo los gráficos (por ejemplo, si hay un Canvas donde se dibujan los gráficos)
    for widget in label_contenido_1.winfo_children():
        if isinstance(widget, tk.Canvas):  # Asegúrate de destruir solo el Canvas
            widget.destroy()

    # Si el label es "Viga apoyada"
    if tipo_viga == "Viga apoyada":
        # Mostrar gráfico de viga apoyada con sus parámetros
            mostrar_grafico_viga_apoyada(
            base_viga_apoyada, 
            altura_viga_apoyada, 
            longitud_viga_apoyada, 
            base_piramide, 
            altura_piramdie, 
            longitud_piramide, 
            desfase_estribo
        )
    
    # Si el label es "Viga empotrada"
    elif tipo_viga == "Viga empotrada":
        # Mostrar gráfico de viga empotrada con sus parámetros
        mostrar_grafico_viga_empotrada(
            base_viga, 
            altura_viga, 
            longitud_viga, 
            base_columna, 
            altura_columna, 
            longitud_columna, 
            desfase_estribo
        )

# Grafico 3D viga empotrada
def dibujar_viga_empotrada(base, altura, longitud, posicion_x, posicion_y, color, ax):
    """
    Dibuja un cuboide con las dimensiones especificadas y posición inicial.
    """
    # Definir las caras del cuboide
    vertices = {
        'cara_inferior': [
            [posicion_x - base/2, posicion_x + base/2, posicion_x + base/2, posicion_x - base/2],
            [posicion_y, posicion_y, posicion_y + longitud, posicion_y + longitud],
            [0, 0, 0, 0]
        ],
        'cara_superior': [
            [posicion_x - base/2, posicion_x + base/2, posicion_x + base/2, posicion_x - base/2],
            [posicion_y, posicion_y, posicion_y + longitud, posicion_y + longitud],
            [altura, altura, altura, altura]
        ],
        'cara_frontal': [
            [posicion_x - base/2, posicion_x + base/2, posicion_x + base/2, posicion_x - base/2],
            [posicion_y, posicion_y, posicion_y, posicion_y],
            [0, 0, altura, altura]
        ],
        'cara_trasera': [
            [posicion_x - base/2, posicion_x + base/2, posicion_x + base/2, posicion_x - base/2],
            [posicion_y + longitud, posicion_y + longitud, posicion_y + longitud, posicion_y + longitud],
            [0, 0, altura, altura]
        ],
        'cara_izquierda': [
            [posicion_x - base/2, posicion_x - base/2, posicion_x - base/2, posicion_x - base/2],
            [posicion_y, posicion_y + longitud, posicion_y + longitud, posicion_y],
            [0, 0, altura, altura]
        ],
        'cara_derecha': [
            [posicion_x + base/2, posicion_x + base/2, posicion_x + base/2, posicion_x + base/2],
            [posicion_y, posicion_y + longitud, posicion_y + longitud, posicion_y],
            [0, 0, altura, altura]
        ]
    }
    
    # Dibujar cada cara del cuboide
    for cara, coordenadas in vertices.items():
        puntos = np.array(coordenadas).T  # Transponer para formato adecuado
        poligono = Poly3DCollection([puntos], color=color, edgecolor='black', alpha=0.3)
        ax.add_collection3d(poligono)

def dibujar_viga_y_columnas(base_viga, altura_viga, longitud_viga, base_columna, altura_columna, longitud_columna, desfase_estribo):
    """
    Dibuja una viga con columnas en sus extremos.
    """
    fig = plt.figure(facecolor="white",dpi=100)
    ax = fig.add_subplot(111, projection='3d')

    # Dibuja la viga
    dibujar_viga_empotrada(base_viga, altura_viga, longitud_viga, 0.5, 0, 'grey', ax)
    
    # Dibuja las columnas en los extremos de la viga
    posicion_extremo_inicial = -longitud_columna  # Columna en el extremo inicial de la viga
    posicion_extremo_final = longitud_viga        # Columna en el extremo final de la viga
    
    dibujar_viga_empotrada(base_columna, altura_columna, longitud_columna, 0.5, posicion_extremo_inicial, 'blue', ax)  # Columna inicial
    dibujar_viga_empotrada(base_columna, altura_columna, longitud_columna, 0.5, posicion_extremo_final, 'blue', ax)    # Columna final

    # Ocultar etiquetas y ticks de los ejes sin afectar el dibujo 3D
    ax.set_xticklabels([])
    ax.set_yticklabels([])
    ax.set_zticklabels([])
    ax.set_xticks([])
    ax.set_yticks([])
    ax.set_zticks([])
    ax.set_box_aspect([1, 3, -1])
    ax.set_facecolor('white')
    ax.w_xaxis.pane.fill = False
    ax.w_yaxis.pane.fill = False
    ax.w_zaxis.pane.fill = False
    # Cambiar el color de las líneas del gráfico
    ax.xaxis.pane.set_edgecolor('white')
    ax.yaxis.pane.set_edgecolor('white')
    ax.zaxis.pane.set_edgecolor('white')

    return fig, ax

def mostrar_grafico_viga_empotrada(base_viga, altura_viga, longitud_viga, base_columna, altura_columna, longitud_columna, desfase_estribo):
    
    # Convertir la figura de matplotlib a un canvas de Tkinter
    frame = tk.Frame(ventana,bd=10,relief="ridge")
    frame.place(x=36,y=35,width=400,height=370)
    
    # Crear la figura y el gráfico
    fig, ax = dibujar_viga_y_columnas(base_viga, altura_viga, longitud_viga, base_columna, altura_columna, longitud_columna, desfase_estribo)

    # Integrar con Tkinter
    canvas = FigureCanvasTkAgg(fig, master=frame)
    canvas_widget = canvas.get_tk_widget()
    canvas_widget.config(bg='white')  # Fondo negro para el widget Canvas
    canvas_widget.pack(fill=tk.BOTH, expand=True)
    
    # Crear un frame para el gráfico y la barra de herramientas
    frame_1 = tk.Frame(canvas_widget ,bd=2, relief="raise")
    frame_1.place(x=0, y=315, width=380 ,height=35)
    
    label_titulo = tk.Label(canvas_widget ,text="Modelo 3D - Viga empotrada",bd=2,relief="raise")
    label_titulo.place(x=1,y=1,width=380,height=35)
    
    
    # Añadir la barra de herramientas de navegación
    toolbar_opciones = NavigationToolbar2Tk(canvas, frame_1)
    toolbar_opciones.update()
    toolbar_opciones.pack(side=tk.BOTTOM, fill=tk.X)


# Función para dibujar la viga apoyada
def dibujar_viga_apoyada(base, altura, longitud, posicion_x, posicion_y, color, ax):
    """
    Dibuja un cuboide con las dimensiones especificadas y posición inicial.
    """
    vertices = {
        'cara_inferior': [
            [posicion_x - base/2, posicion_x + base/2, posicion_x + base/2, posicion_x - base/2],
            [posicion_y, posicion_y, posicion_y + longitud, posicion_y + longitud],
            [0, 0, 0, 0]
        ],
        'cara_superior': [
            [posicion_x - base/2, posicion_x + base/2, posicion_x + base/2, posicion_x - base/2],
            [posicion_y, posicion_y, posicion_y + longitud, posicion_y + longitud],
            [altura, altura, altura, altura]
        ],
        'cara_frontal': [
            [posicion_x - base/2, posicion_x + base/2, posicion_x + base/2, posicion_x - base/2],
            [posicion_y, posicion_y, posicion_y, posicion_y],
            [0, 0, altura, altura]
        ],
        'cara_trasera': [
            [posicion_x - base/2, posicion_x + base/2, posicion_x + base/2, posicion_x - base/2],
            [posicion_y + longitud, posicion_y + longitud, posicion_y + longitud, posicion_y + longitud],
            [0, 0, altura, altura]
        ],
        'cara_izquierda': [
            [posicion_x - base/2, posicion_x - base/2, posicion_x - base/2, posicion_x - base/2],
            [posicion_y, posicion_y + longitud, posicion_y + longitud, posicion_y],
            [0, 0, altura, altura]
        ],
        'cara_derecha': [
            [posicion_x + base/2, posicion_x + base/2, posicion_x + base/2, posicion_x + base/2],
            [posicion_y, posicion_y + longitud, posicion_y + longitud, posicion_y],
            [0, 0, altura, altura]
        ]
    }
    
    for cara, coordenadas in vertices.items():
        puntos = np.array(coordenadas).T
        poligono = Poly3DCollection([puntos], color=color, edgecolor='black', alpha=0.3)
        ax.add_collection3d(poligono)

# Función para dibujar las piramides 
def dibujar_piramide(base, altura, posicion_x, posicion_y, color, ax):
    """
    Dibuja una pirámide invertida con base cuadrada.
    """
    # Definir los vértices de la pirámide invertida
    vertices = [
        [posicion_x - base / 2, posicion_y, altura],  # Esquina inferior izquierda de la base
        [posicion_x + base / 2, posicion_y, altura],  # Esquina inferior derecha de la base
        [posicion_x + base / 2, posicion_y + base, altura],  # Esquina superior derecha de la base
        [posicion_x - base / 2, posicion_y + base, altura],  # Esquina superior izquierda de la base
        [posicion_x, posicion_y + base / 2, 0]  # Vértice superior (punta de la pirámide)
    ]
    
    # Definir las caras de la pirámide
    caras = [
        [vertices[0], vertices[1], vertices[4]],  # Cara frontal
        [vertices[1], vertices[2], vertices[4]],  # Cara derecha
        [vertices[2], vertices[3], vertices[4]],  # Cara trasera
        [vertices[3], vertices[0], vertices[4]],  # Cara izquierda
        [vertices[0], vertices[1], vertices[2], vertices[3]]  # Base
    ]
    
    # Dibujar cada cara de la pirámide
    for cara in caras:
        poligono = Poly3DCollection([cara], color=color, edgecolor='black', alpha=0.3)
        ax.add_collection3d(poligono)


# Función principal para dibujar la viga y las pirámides
def dibujar_viga_y_piramides(base_viga_apoyada, altura_viga_apoyada, longitud_viga_apoyada, base_piramide, altura_piramdie, longitud_piramide, desfase_estribo):
    fig = plt.figure(facecolor="white", dpi=100)
    ax = fig.add_subplot(111, projection='3d')

    # Dibujar la viga
    dibujar_viga_apoyada(base_viga_apoyada, altura_viga_apoyada, longitud_viga_apoyada, 0.5, 0, 'grey', ax)
    
    # Dibujar pirámides en los extremos de la viga
    posicion_extremo_inicial = -longitud_piramide
    posicion_extremo_final = longitud_viga_apoyada
    
    dibujar_piramide(base_piramide, altura_piramdie, 0.5, posicion_extremo_inicial, 'blue', ax)  # Pirámide inicial
    dibujar_piramide(base_piramide, altura_piramdie, 0.5, posicion_extremo_final, 'blue', ax)    # Pirámide final

    ax.set_xticklabels([])
    ax.set_yticklabels([])
    ax.set_zticklabels([])
    ax.set_xticks([])
    ax.set_yticks([])
    ax.set_zticks([])
    ax.set_box_aspect([1, 3, 1])
    ax.set_facecolor('white')
    ax.w_xaxis.pane.fill = False
    ax.w_yaxis.pane.fill = False
    ax.w_zaxis.pane.fill = False
    ax.xaxis.pane.set_edgecolor('white')
    ax.yaxis.pane.set_edgecolor('white')
    ax.zaxis.pane.set_edgecolor('white')

    return fig, ax

# Función para mostrar el gráfico en una ventana Tkinter
def mostrar_grafico_viga_apoyada(base_viga_apoyada, altura_viga_apoyada, longitud_viga_apoyada, base_piramide, altura_piramdie, longitud_piramide, desfase_estribo):
    frame = tk.Frame(ventana, bd=10, relief="ridge")
    frame.place(x=36, y=35, width=400, height=370)
    
    fig, ax = dibujar_viga_y_piramides(base_viga_apoyada, altura_viga_apoyada, longitud_viga_apoyada, base_piramide, altura_piramdie, longitud_piramide, desfase_estribo)

    canvas = FigureCanvasTkAgg(fig, master=frame)
    canvas_widget = canvas.get_tk_widget()
    canvas_widget.config(bg='white')
    canvas_widget.pack(fill=tk.BOTH, expand=True)
    
    frame_1 = tk.Frame(canvas_widget, bd=2, relief="raise")
    frame_1.place(x=0, y=315, width=380, height=35)
    
    label_titulo = tk.Label(canvas_widget ,text="Modelo 3D - Viga apoyada",bd=2,relief="raise")
    label_titulo.place(x=1,y=1,width=380,height=35)
    
    toolbar_opciones = NavigationToolbar2Tk(canvas, frame_1)
    toolbar_opciones.update()
    toolbar_opciones.pack(side=tk.BOTTOM, fill=tk.X)


frame_ventana = tk.Frame(ventana, bd=10, relief="ridge",bg="white")
frame_ventana.place(x=36, y=35, width=400, height=370)


frame_1 = tk.Frame(frame_ventana, bd=2, relief="raise")
frame_1.place(x=0, y=315, width=380, height=35)

label_titulo = tk.Label(frame_ventana ,text="Modelo Viga 3D",bd=2,relief="raise")
label_titulo.place(x=1,y=1,width=380,height=35)



# Cargar las imágenes para los menús
imagen_original0 = Image.open("Iconos_proyecto/Nuevo_Modelo.png")
imagen_original_abrir=Image.open("Iconos_proyecto/Abrir_archivo.png")
imagen_original_guardar=Image.open("Iconos_proyecto/Disco-guardar.png")
imagen_original_salir= Image.open("Iconos_proyecto/Cerrar-sesion.png")
imagen_original = Image.open("Iconos_proyecto/Materiales.png")
imagen_original1 = Image.open("Iconos_proyecto/Sección transversal.png")
imagen_original2 = Image.open("Iconos_proyecto/Seccion Viga.png")
imagen_original3= Image.open("Iconos_proyecto/apoyo simple.png")
imagen_original4= Image.open("Iconos_proyecto/Cargas.png")
imagen_original5= Image.open("Iconos_proyecto/Grafico_V_M.png")
imagen_original6= Image.open("Iconos_proyecto/Flexion_VG.png")
imagen_original7= Image.open("Iconos_proyecto/Calculos_previos.png")


# Redimensionar las imágenes (ajustar el tamaño según sea necesario)
imagen_redimensionada0 = imagen_original0.resize((20, 20))
imagen_redimensionada_abrir = imagen_original_abrir.resize((20, 20))
imagen_redimensionada_guardar= imagen_original_guardar.resize((20,20))
imagen_redimensionada_salir= imagen_original_salir.resize((20,20))
imagen_redimensionada = imagen_original.resize((20, 20))
imagen_redimensionada1 = imagen_original1.resize((20, 20))
imagen_redimensionada2 = imagen_original2.resize((20, 20))
imagen_redimensionada3 = imagen_original3.resize((20,20))
imagen_redimensionada4 = imagen_original4.resize((20,20))
imagen_redimensionada5 = imagen_original5.resize((20,20))
imagen_redimensionada6 = imagen_original6.resize((20,20))
imagen_redimensionada7 = imagen_original7.resize((20,20))


# Convertir las imágenes redimensionadas a un formato compatible con Tkinter
icono_modelo_nuevo = ImageTk.PhotoImage(imagen_redimensionada0)
icono_abrir_archivo = ImageTk.PhotoImage(imagen_redimensionada_abrir)
icono_guardar      =  ImageTk.PhotoImage(imagen_redimensionada_guardar)
icono_salir        =  ImageTk.PhotoImage(imagen_redimensionada_salir)
icono_materiales = ImageTk.PhotoImage(imagen_redimensionada)
icono_seccion_transversal = ImageTk.PhotoImage(imagen_redimensionada1)
icono_seccion_viga = ImageTk.PhotoImage(imagen_redimensionada2)
icono_asignar_apoyos = ImageTk.PhotoImage(imagen_redimensionada3)
icono_asignar_cargas = ImageTk.PhotoImage(imagen_redimensionada4)
icono_graficos = ImageTk.PhotoImage(imagen_redimensionada5)
icono_flexion =  ImageTk.PhotoImage(imagen_redimensionada6)
icono_calculos = ImageTk.PhotoImage(imagen_redimensionada7)

# Menú "Definir"
menu_definir = tk.Menu(menu_bar, tearoff=0)

# Menú "Archivo"
menu_archivo = tk.Menu(menu_bar, tearoff=0)
menu_archivo.add_command(label="Nuevo", image=icono_modelo_nuevo, compound="left",command=lambda: abrir_ventana_nueva())
menu_archivo.add_command(label="Abrir",image=icono_abrir_archivo,compound="left", command=abrir_archivo)
menu_archivo.add_command(label="Guardar",image=icono_guardar,compound="left",command=guardar_archivo)
menu_archivo.add_separator()
menu_archivo.add_command(label="Salir", command=ventana.quit,image=icono_salir,compound="left")
menu_bar.add_cascade(label="Archivo", menu=menu_archivo)

# Declarar checkbutton_1 como una variable global
checkbutton_1 = None
checkbutton_2 = None
checkbutton_3 = None
checkbutton_4 = None

# Clase para manejar la reproducción del GIF
class GIFPlayer:
    def __init__(self, master, gif_path, canvas, width, height):
        self.master = master
        self.canvas = canvas
        self.gif_path = gif_path
        self.width = width
        self.height = height
        
        # Verificar si el archivo existe antes de intentar cargarlo
        if not os.path.exists(gif_path):
            print(f"El archivo {gif_path} no existe.")
            return

        try:
            self.image = Image.open(gif_path)
        except Exception as e:
            print(f"Error al abrir el archivo GIF: {e}")
            return
        
        self.frames = self.load_frames()
        if not self.frames:
            print("No se pudieron cargar los fotogramas del GIF.")
            return
        
        self.current_frame = 0
        self.canvas_id = self.canvas.create_image(0, 0, anchor="nw", image=self.frames[self.current_frame])
        self.update_frame()

    def load_frames(self):
        """Carga los fotogramas del GIF"""
        frames = []
        try:
            while True:
                # Escalar cada fotograma del GIF al tamaño del Canvas
                frame = self.image.copy()
                frame = frame.resize((self.width, self.height), Image.Resampling.LANCZOS)
                frame = ImageTk.PhotoImage(frame)
                frames.append(frame)
                self.image.seek(self.image.tell() + 1)
        except EOFError:
            pass
        except Exception as e:
            print(f"Error al cargar los fotogramas del GIF: {e}")
        return frames

    def update_frame(self):
        """Actualizar el fotograma a mostrar"""
        self.current_frame = (self.current_frame + 1) % len(self.frames)
        self.canvas.itemconfig(self.canvas_id, image=self.frames[self.current_frame])
        # Llamar a update_frame nuevamente para crear la animación continua
        self.master.after(100, self.update_frame)

# Función para manejar el evento de selección en el Combobox
def on_combobox_select(event, canvas_viga, label_mensaje_ayuda,label_prueba):
    selected_option = combobox.get().strip()  # Eliminar cualquier espacio extra

    # Lógica para actualizar el mensaje según la opción seleccionada
    if selected_option == "Viga empotrada":
        gif_path = r"C:\Users\User\Desktop\Programa\Iconos_proyecto\animacion.gif"
        mensaje = "Has seleccionado la viga empotrada.\nPara el modelo sigue aplicando las otras configuraciones.\nPara completar el modelo."
    elif selected_option == "Viga apoyada":
        gif_path = r"C:\Users\User\Desktop\Programa\Iconos_proyecto\viga_apoyada.gif"
        mensaje = "Has seleccionado la viga apoyada.\nPara el modelo sigue aplicando las otras configuraciones.\nPara completar el modelo."
    else:
        print("Opción no válida")
        return

    # Actualiza el texto del label de mensaje de ayuda
    label_mensaje_ayuda.config(text=mensaje)
    
    # Actualiza el texto en label_prueba con la opción seleccionada
    label_prueba.config(text=f"{selected_option}")

    # Verificar si el archivo GIF existe y mostrarlo en el canvas
    if os.path.exists(gif_path):
        if canvas_viga is not None:
            gif_player = GIFPlayer(master=Ventana_Nuevo, gif_path=gif_path, canvas=canvas_viga, width=190, height=170)
        else:
            print("Error: canvas_viga es None.")
    else:
        print(f"El archivo {gif_path} no existe.")

# Declarar label_prueba como variable global
label_prueba = None
subventana_abierta= None


# Ruta de la carpeta base_datos
carpeta_base_datos = "base_datos"
archivo_datos = os.path.join(carpeta_base_datos, "datos_modelo.txt")

# Crear la carpeta base_datos si no existe
if not os.path.exists(carpeta_base_datos):
    os.makedirs(carpeta_base_datos)

def guardar_datos():
    """Guarda los datos de los widgets en un archivo de texto."""
    nombre_modelo = entry_nombre_modelo.get().strip()
    datos = {
        "nombre_usuario": entry_nombre_usuario.get(),
        "nombre_modelo": nombre_modelo,
        "detalles_modelo": text_detalles_modelo.get("1.0", tk.END).strip(),
        "combo_concreto": combo_concreto.get(),
        "combo_acero": combo_acero.get()
        
        
    }
    with open(archivo_datos, "w") as archivo:
        for clave, valor in datos.items():
            archivo.write(f"{clave}:{valor}\n")
    # Actualizar el título de la subventana
    if nombre_modelo:
        Ventana_Nuevo.title(f"Nuevo Modelo - {nombre_modelo}")
    
    Ventana_Nuevo.destroy()
    

def cargar_datos():
    """Carga los datos desde un archivo de texto si existe."""
    datos = {}
    try:
        with open(archivo_datos, "r") as archivo:
            for linea in archivo:
                clave, valor = linea.strip().split(":", 1)
                datos[clave] = valor
    except FileNotFoundError:
        pass
    return datos


# Función que se ejecuta cuando se selecciona "Nuevo" o se hace clic en el botón
def abrir_ventana_nueva():
    global Ventana_Nuevo,checkbutton_1,checkbutton_2,checkbutton_3,checkbutton_4 , gif_player, combobox, label_prueba,spinbox,checkbutton_5,combo
    global subventana_abierta
    global entry_nombre_usuario, entry_ruta_archivo, entry_nombre_modelo, text_detalles_modelo
    global combo_concreto, entry_descripcion_concreto, combo_acero, entry_descripcion_acero

    # Verificar si la subventana ya está abierta
    if Ventana_Nuevo is None or not Ventana_Nuevo.winfo_exists():
        # Crear una nueva subventana (Toplevel)
        Ventana_Nuevo = Toplevel(ventana)
        Ventana_Nuevo.title("Nuevo Modelo")
        Ventana_Nuevo.geometry("800x470")  # Tamaño de la subventana
        
        # Cargar datos para establecer el título
        datos_cargados = cargar_datos()
        nombre_modelo = datos_cargados.get("nombre_modelo", "")
        Ventana_Nuevo.title(f"Nuevo Modelo - {nombre_modelo}" if nombre_modelo else "Nuevo Modelo")

        
        # Establecer un tamaño fijo y prevenir redimensionar
        Ventana_Nuevo.resizable(False, False)
        
        # Asegurarse de que la subventana esté siempre por encima de la ventana principal
        Ventana_Nuevo.attributes('-topmost', True)
        
        
        # Crear LabelFrame en la nueva ventana
        label_Nuevo = tk.LabelFrame(Ventana_Nuevo, text="Configuraciones previas")
        label_Nuevo.place(x=10,y=10,width=200,height=400)
        
        # Crear el Treeview dentro del LabelFrame
        treeview = ttk.Treeview(label_Nuevo)
        treeview.place(x=10,y=10,width=170,height=300)
        
        # Función para redimensionar imágenes
        def cargar_icono(ruta, tamaño):
            imagen = Image.open(ruta)  # Abrir la imagen
            imagen = imagen.resize(tamaño, Image.ANTIALIAS)  # Redimensionar
            return ImageTk.PhotoImage(imagen)
        
        # Cargar las imágenes para los íconos
        icon_general = tk.PhotoImage(file="Iconos_proyecto/boton-circular.png")  
        icon_unidades = tk.PhotoImage(file="Iconos_proyecto/boton-circular.png")  
        icon_materiales = tk.PhotoImage(file="Iconos_proyecto/boton-circular.png")
        icon_modelo = tk.PhotoImage(file="Iconos_proyecto/boton_triangulo.png")
        icono_concreto_acero = tk.PhotoImage(file="Iconos_proyecto/Concreto_Acero.png")
        
        # Mantener las imágenes en una variable para evitar que se eliminen por el recolector de basura
        treeview.icons = {
        'general': icon_general,
        'unidades': icon_unidades,
        'materiales': icon_materiales,
        'nuevo modelo':icon_modelo
        }
        
        # Agregar elementos al Treeview con jerarquía
        # Opción principal
        opcion1 = treeview.insert('', 'end', 'opcion1', text='General',image=icon_general)
        opcion2 = treeview.insert('', 'end', 'opcion2', text='Unidades / Esfuerzos',image=icon_unidades)
        opcion3 = treeview.insert('', 'end', 'opcion3', text='Materiales',image=icon_materiales)

        # Sub-elementos dentro de la Opción 1
        treeview.insert(opcion1, 'end', 'subopcion1_1', text='Nuevo Modelo',image=icon_modelo)
        treeview.insert(opcion1, 'end', 'subopcion1_2', text='Estilo de Modelo',image=icon_modelo)

        # Sub-elementos dentro de la Opción 2
        treeview.insert(opcion2, 'end', 'subopcion2_1', text='Esfuerzos',image=icon_modelo)
        # Sub-elementos dentro de la Opción 3
        subopcion3_1 = treeview.insert(opcion3, 'end', 'subopcion3_1', text="Concreto / Acero", image=icon_modelo)
        
        # Seleccionar la opción "General" (sin expandir)
        treeview.selection_set(opcion1)
        
        
        # Función para bloquear la interacción con "opcion3" pero dejar ver el subnodo
        def bloquear_opcion3(event):
            seleccion = treeview.identify_row(event.y)  # Identificar qué fila se clicó
        
            if seleccion == "opcion3":  # Si el clic es sobre "Materiales"
                treeview.item(opcion3, open=True)  # Expande el nodo de "Materiales"
                treeview.selection_set(subopcion3_1)  # Forza la selección del subelemento
                treeview.focus(subopcion3_1)  # Mueve el foco al subelemento
                return "break"  # Detiene la acción predeterminada de Treeview (evita que se seleccione "Opción 3")
        
        # Vincular un evento de clic para bloquear el acceso a "opcion3"
        treeview.bind("<Button-1>", bloquear_opcion3)
        
        # Inicializar la variable que indica si la subventana está abierta
        subventana_abierta = False
        
        
        # Función que abre la subventana si no está abierta
        def abrir_subventana():
            global subventana_abierta,boton_agregar
            if not subventana_abierta:  # Solo abre la subventana si no está abierta
                subventana_abierta = True  # Marcar como abierta
                subventana = Toplevel()  # Crear la subventana
                subventana.title("Configuración del material")  # Título de la subventana
                subventana.geometry("394x280")  # Tamaño de la subventana
        
        # Hacer que la subventana esté siempre en el primer plano
                subventana.attributes('-topmost', True)
        
        # Evitar que la subventana sea redimensionable
                subventana.resizable(False, False)
                
        # Crear contenido dentro de la subventana
                label_frame_concreto = tk.LabelFrame(subventana, text="Concreto [f'c]")
                label_frame_concreto.place(x=10,y=10,width=375,height=100)
                label_materiales_concreto = tk.Label(label_frame_concreto,text="Materiales:")
                label_materiales_concreto.place(x=40,y=15)
                label_materiales_descripcion_C = tk.Label(label_frame_concreto,text="Descripción:")
                label_materiales_descripcion_C.place(x=40,y=45)
                entry_materiales_C= tk.Entry(label_frame_concreto)
                entry_materiales_C.place(x=140,y=45,width=143)
                label_frame_acero = tk.LabelFrame(subventana,text="Acero [fy]")
                label_frame_acero.place(x=10,y=120,width=375,height=100)
                label_materiales_acero = tk.Label(label_frame_acero,text="Materiales:")
                label_materiales_acero.place(x=40,y=15)
                label_materiales_descripcion_A = tk.Label(label_frame_acero,text="Descripción:")
                label_materiales_descripcion_A.place(x=40,y=45)
                entry_materiales_A= tk.Entry(label_frame_acero)
                entry_materiales_A.place(x=140,y=45,width=143)
                boton_agregar = tk.Button(subventana,text="Agregar", command=lambda: agregar_datos(entry_materiales_C, entry_materiales_A, combo_materiales_fc, combo_materiales_fy))
                boton_agregar.place(x=140,y=235,width=100)
                
                # Guardamos la referencia de la subventana
                abrir_subventana.subventana = subventana
                
        # Crear un Combobox para f'c
                combo_materiales_fc = ttk.Combobox(label_frame_concreto, values=[
                "f'c = 17.5 MPa", 
                "f'c = 21 MPa", 
                "f'c = 24.5 MPa", 
                "f'c = 28 MPa", 
                "f'c = 35 MPa", 
                "f'c = 42 MPa"
                ], state="readonly")  # `readonly` para evitar edición manual
                combo_materiales_fc.set("Concreto")  # Valor por defecto
                combo_materiales_fc.place(x=140,y=15)
                
        # Función que actualiza el Entry de descripción de concreto según la selección en el ComboBox
                def actualizar_descripcion_concreto():
                    seleccion_fc = combo_materiales_fc.get()
                    if seleccion_fc == "f'c = 17.5 MPa":
                        entry_materiales_C.delete(0, tk.END)  # Eliminar texto actual
                        entry_materiales_C.insert(0, "Concreto 2500 Psi")
                    elif seleccion_fc == "f'c = 21 MPa":
                        entry_materiales_C.delete(0, tk.END)
                        entry_materiales_C.insert(0, "Concreto 3000 Psi")
                    elif seleccion_fc == "f'c = 24.5 MPa":
                        entry_materiales_C.delete(0, tk.END)
                        entry_materiales_C.insert(0, "Concreto 3500 Psi")
                    elif seleccion_fc == "f'c = 28 MPa":
                        entry_materiales_C.delete(0, tk.END)
                        entry_materiales_C.insert(0, "Concreto 4000 Psi")
                    elif seleccion_fc == "f'c = 35 MPa":
                        entry_materiales_C.delete(0, tk.END)
                        entry_materiales_C.insert(0, "Concreto 5000 Psi")
                    elif seleccion_fc == "f'c = 42 MPa":
                        entry_materiales_C.delete(0, tk.END)
                        entry_materiales_C.insert(0, "Concreto 6000 Psi")
                
                # Vincular el evento de cambio en el Combobox de f'c
                combo_materiales_fc.bind("<<ComboboxSelected>>", lambda event: actualizar_descripcion_concreto())
                
        # Crear un Combobox para fy
                combo_materiales_fy = ttk.Combobox(label_frame_acero, values=[
                "fy = 240 MPa", 
                "fy = 420 MPa"
                ], state="readonly")  # `readonly` para evitar edición manual
                combo_materiales_fy.set("Acero")  # Valor por defecto
                combo_materiales_fy.place(x=140,y=15)
        
        # Función que actualiza el Entry de descripción de acero según la selección en el ComboBox
                def actualizar_descripcion_acero():
                    seleccion_fy = combo_materiales_fy.get()
                    if seleccion_fy == "fy = 240 MPa":
                        entry_materiales_A.delete(0, tk.END)  # Eliminar texto actual
                        entry_materiales_A.insert(0, "Resistencia media")
                    elif seleccion_fy == "fy = 420 MPa":
                        entry_materiales_A.delete(0, tk.END)
                        entry_materiales_A.insert(0, "Resistencia alta")
                        
                # Vincular el evento de cambio en el Combobox de fy
                combo_materiales_fy.bind("<<ComboboxSelected>>", lambda event: actualizar_descripcion_acero())
                
        # Función que se llama al hacer clic en el botón "Agregar"
                def agregar_datos(entry_materiales_C, entry_materiales_A, combo_materiales_fc, combo_materiales_fy):
        # Copiar todos los valores de los ComboBox en los respectivos ComboBox de la ventana principal
                    valores_fc = combo_materiales_fc['values']  
                    valores_fy = combo_materiales_fy['values']  

        # Actualizar el ComboBox de la ventana principal con los valores
                    combo_concreto['values'] = valores_fc
                    combo_acero['values'] = valores_fy

        # Si es necesario, se puede seleccionar el primer valor por defecto
                    combo_concreto.set(valores_fc[0])
                    combo_acero.set(valores_fy[0])
                
                # Cerrar la subventana después de agregar los datos
                    subventana.destroy()
                
        # Vincular el evento de cierre de la subventana
                subventana.protocol("WM_DELETE_WINDOW", lambda: cerrar_subventana(subventana))
                
                def actualizar_descripcion_principal():
                    descripcion_concreto = {
                    "f'c = 17.5 MPa": "Concreto 2500 Psi",
                    "f'c = 21 MPa": "Concreto 3000 Psi",
                    "f'c = 24.5 MPa": "Concreto 3500 Psi",
                    "f'c = 28 MPa": "Concreto 4000 Psi",
                    "f'c = 35 MPa": "Concreto 5000 Psi",
                    "f'c = 42 MPa": "Concreto 6000 Psi"
                }
                    entry_descripcion_concreto.delete(0, tk.END)
                    entry_descripcion_concreto.insert(0, descripcion_concreto.get(combo_concreto.get(), ""))
            
                combo_concreto.bind("<<ComboboxSelected>>", lambda event: actualizar_descripcion_principal())
            
                def actualizar_descripcion_acero_principal():
                    descripcion_acero = {
                    "fy = 240 MPa": "Resistencia media",
                    "fy = 420 MPa": "Resistencia alta"
                    }
                    entry_descripcion_acero.delete(0, tk.END)
                    entry_descripcion_acero.insert(0, descripcion_acero.get(combo_acero.get(), ""))
                
                # Vincular evento de cambio en combo_acero
                combo_acero.bind("<<ComboboxSelected>>", lambda event: actualizar_descripcion_acero_principal())
                
        
        # Función para cerrar la subventana y restablecer la variable global
        def cerrar_subventana(subventana):
            global subventana_abierta
            subventana.destroy()  # Cierra la subventana
            subventana_abierta = False  # Restablece el estado para permitir abrirla nuevamente
        
        
        # Función que actualizará la información en el lado derecho
        def mostrar_informacion(event):
            global combos,subventana_abierta
            # Obtener el ítem seleccionado
            item = treeview.selection()
            if item:
                # Aquí puedes ajustar la información según la selección
                info = f"{treeview.item(item)['text']}"
                label_info.config(text=info)
                
                
                
                
                # Mostrar el campo "Nombre de Usuario" si la opción seleccionada es 'General'
                if treeview.item(item)['text'] == 'General':
                    label_nombre_usuario.place(x=40, y=50)
                    entry_nombre_usuario.place(x=170, y=50, width=168)
                    label_fecha_entrada.place(x=350,y=50)
                    entry_fecha_entrada.place(x=400,y=50,width=70)
                    labelFrame_archivo_abrir.place(x=40,y=100,width=480,height=80)
                    label_ruta_archivo.place(x=10,y=10)
                    entry_ruta_archivo.place(x=110,y=10,width=300)
                    labelFrame_archivo_información.place(x=40,y=190, width=480, height=80)
                    label_ruta_usuario.place(x=10,y=10)
                    entry_ruta_usuario.place(x=110,y=10,width=300)
                    labelFrame_opciones.place(x=40,y=280, width=480, height=80)
                    checkbutton_1.place(x=10,y=10)
                    

                    # Ocultar otros widgets si no es la opción correcta
                    label_nombre_modelo.place_forget()
                    label_descripcion_modelo.place_forget()
                    entry_nombre_modelo.place_forget()
                    text_detalles_modelo.place_forget()
                    labelFrame_complementos.place_forget()
                    checkbutton_2.place_forget()
                    checkbutton_3.place_forget()
                    checkbutton_4.place_forget()
                    labelFrame_estilo.place_forget()
                    canvas_viga.place_forget()
                    labelFrame_contenido.place_forget()
                    combobox.place_forget()
                    label_tipo_viga.place_forget()
                    label_mensaje_ayuda.place_forget()
                    label_contenido_1.place_forget()
                    label_mensaje_ayuda_1.place_forget()
                    boton_aplicar.place_forget()
                    label_prueba.place_forget()
                    label_formato.place_forget()
                    formato_decimal.place_forget()
                    slider_1.place_forget()
                    label_mensaje_formato.place_forget()
                    label_formato_unidades.place_forget()
                    label_unidades_1.place_forget()
                    label_unidades_2.place_forget()
                    label_unidades_3.place_forget()
                    label_unidades_4.place_forget()
                    combo1.place_forget()
                    combo2.place_forget()
                    combo3.place_forget()
                    combo4.place_forget()
                    checkbutton_5.place_forget()
                    labelFrame_Esfuerzos.place_forget()
                    label_longitud.place_forget()
                    label_fuerza.place_forget()
                    label_Momento.place_forget()
                    label_Tension.place_forget()
                    longitud_1.place_forget()
                    Fuerza_1.place_forget()
                    entry_momento.place_forget()
                    entry_tension.place_forget()
                    checkbutton_6.place_forget()
                    labelFrame_Nota.place_forget()
                    label_mensaje_nota.place_forget()
                    labelFrame_Materiales.place_forget()
                    label_concreto.place_forget()
                    label_descripcion_concreto.place_forget()
                    label_acero.place_forget()
                    label_descripcion_acero.place_forget()
                    combo_concreto.place_forget()
                    entry_descripcion_concreto.place_forget()
                    combo_acero.place_forget()
                    entry_descripcion_acero.place_forget()
                    labelFrame_boton.place_forget()
                    label_configuracion.place_forget()
                    
                    
                    
                    # Mostrar el campo "Nombre del modelo" si la opción seleccionada es 'Nuevo Modelo'
                elif treeview.item(item)['text'] == 'Nuevo Modelo':
                    label_nombre_modelo.place(x=40, y=50)
                    label_descripcion_modelo.place(x=40, y=100)
                    entry_nombre_modelo.place(x=170, y=50, width=320)
                    text_detalles_modelo.place(x=40, y=140, width=450, height=100)
                    labelFrame_complementos.place(x=40,y=250,width=450,height=100)
                    checkbutton_2.place(x=10,y=10)
                    checkbutton_3.place(x=230,y=10)
                    checkbutton_4.place(x=10,y=50)

                    # Ocultar otros widgets si no es la opción correcta
                    label_nombre_usuario.place_forget()
                    entry_nombre_usuario.place_forget()
                    label_fecha_entrada.place_forget()
                    entry_fecha_entrada.place_forget()
                    labelFrame_archivo_abrir.place_forget()
                    label_ruta_archivo.place_forget()
                    entry_ruta_archivo.place_forget()
                    labelFrame_archivo_información.place_forget()
                    label_ruta_usuario.place_forget()
                    entry_ruta_usuario.place_forget()
                    labelFrame_opciones.place_forget()
                    checkbutton_1.place_forget()
                    labelFrame_estilo.place_forget()
                    canvas_viga.place_forget()
                    labelFrame_contenido.place_forget()
                    combobox.place_forget()
                    label_tipo_viga.place_forget()
                    label_mensaje_ayuda.place_forget()
                    label_contenido_1.place_forget()
                    label_mensaje_ayuda_1.place_forget()
                    boton_aplicar.place_forget()
                    label_prueba.place_forget()
                    label_formato.place_forget()
                    formato_decimal.place_forget()
                    slider_1.place_forget()
                    label_mensaje_formato.place_forget()
                    label_formato_unidades.place_forget()
                    label_unidades_1.place_forget()
                    label_unidades_2.place_forget()
                    label_unidades_3.place_forget()
                    label_unidades_4.place_forget()
                    combo1.place_forget()
                    combo2.place_forget()
                    combo3.place_forget()
                    combo4.place_forget()
                    checkbutton_5.place_forget()
                    labelFrame_Esfuerzos.place_forget()
                    label_longitud.place_forget()
                    label_fuerza.place_forget()
                    label_Momento.place_forget()
                    label_Tension.place_forget()
                    longitud_1.place_forget()
                    Fuerza_1.place_forget()
                    entry_momento.place_forget()
                    entry_tension.place_forget()
                    checkbutton_6.place_forget()
                    labelFrame_Nota.place_forget()
                    label_mensaje_nota.place_forget()
                    labelFrame_Materiales.place_forget()
                    label_concreto.place_forget()
                    label_descripcion_concreto.place_forget()
                    label_acero.place_forget()
                    label_descripcion_acero.place_forget()
                    combo_concreto.place_forget()
                    entry_descripcion_concreto.place_forget()
                    combo_acero.place_forget()
                    entry_descripcion_acero.place_forget()
                    labelFrame_boton.place_forget()
                    label_configuracion.place_forget()
                    
                    
                    
                    
                    
                # Mostrar el LabelFrame vacío para 'Estilo de Modelo'
                elif treeview.item(item)['text'] == 'Estilo de Modelo':
                    labelFrame_estilo.place(x=30, y=50, width=200, height=200) 
                    canvas_viga.place(x=2,y=2,width=190,height=170)
                    labelFrame_contenido.place(x=250,y=50,width=280, height=200)
                    combobox.place(x=100,y=20)
                    label_tipo_viga.place(x=20,y=20)
                    label_mensaje_ayuda.place(x=20,y=60,width=230,height=100)
                    label_contenido_1.place(x=30,y=260,width=501,height=100)
                    label_mensaje_ayuda_1.place(x=10,y=10)
                    boton_aplicar.place(x=200,y=40,width=100)
                    #label_prueba.place(x=50,y=40,width=150)
                    
                # Ocultar otros widgets si no es la opción correcta
                    label_nombre_modelo.place_forget()
                    label_descripcion_modelo.place_forget()
                    entry_nombre_modelo.place_forget()
                    text_detalles_modelo.place_forget()
                    labelFrame_complementos.place_forget()
                    checkbutton_2.place_forget()
                    checkbutton_3.place_forget()
                    checkbutton_4.place_forget()
                    label_nombre_usuario.place_forget()
                    entry_nombre_usuario.place_forget()
                    label_fecha_entrada.place_forget()
                    entry_fecha_entrada.place_forget()
                    labelFrame_archivo_abrir.place_forget()
                    label_ruta_archivo.place_forget()
                    entry_ruta_archivo.place_forget()
                    labelFrame_archivo_información.place_forget()
                    label_ruta_usuario.place_forget()
                    entry_ruta_usuario.place_forget()
                    labelFrame_opciones.place_forget()
                    checkbutton_1.place_forget()
                    label_formato.place_forget()
                    formato_decimal.place_forget()
                    slider_1.place_forget()
                    label_mensaje_formato.place_forget()
                    label_formato_unidades.place_forget()
                    label_unidades_1.place_forget()
                    label_unidades_2.place_forget()
                    label_unidades_3.place_forget()
                    label_unidades_4.place_forget()
                    combo1.place_forget()
                    combo2.place_forget()
                    combo3.place_forget()
                    combo4.place_forget()
                    checkbutton_5.place_forget()
                    labelFrame_Esfuerzos.place_forget()
                    label_longitud.place_forget()
                    label_fuerza.place_forget()
                    label_Momento.place_forget()
                    label_Tension.place_forget()
                    longitud_1.place_forget()
                    Fuerza_1.place_forget()
                    entry_momento.place_forget()
                    entry_tension.place_forget()
                    checkbutton_6.place_forget()
                    labelFrame_Nota.place_forget()
                    label_mensaje_nota.place_forget()
                    labelFrame_Materiales.place_forget()
                    label_concreto.place_forget()
                    label_descripcion_concreto.place_forget()
                    label_acero.place_forget()
                    label_descripcion_acero.place_forget()
                    combo_concreto.place_forget()
                    entry_descripcion_concreto.place_forget()
                    combo_acero.place_forget()
                    entry_descripcion_acero.place_forget()
                    labelFrame_boton.place_forget()
                    label_configuracion.place_forget()
                    
                    
                    
                # Mostrar el contenido para 'Unidades / Fuerzas'
                elif treeview.item(item)['text'] == 'Unidades / Esfuerzos':
                    label_formato.place(x=50,y=60,width=460,height=100)
                    formato_decimal.place(x=20,y=30)
                    slider_1.place(x=250,y=10)
                    label_mensaje_formato.place(x=20,y=60)
                    label_formato_unidades.place(x=50,y=180,width=460,height=180)
                    label_unidades_1.place(x=20,y=10)
                    label_unidades_2.place(x=20,y=40)
                    label_unidades_3.place(x=20,y=70)
                    label_unidades_4.place(x=20,y=100)
                    combo1.place(x=220,y=10)
                    combo2.place(x=220,y=40)
                    combo3.place(x=220,y=70)
                    combo4.place(x=220,y=100)
                    checkbutton_5.place(x=20,y=135)
                    
                    
                    
                    # Ocultar otros widgets si no es la opción correcta
                    label_nombre_modelo.place_forget()
                    label_descripcion_modelo.place_forget()
                    entry_nombre_modelo.place_forget()
                    text_detalles_modelo.place_forget()
                    labelFrame_complementos.place_forget()
                    checkbutton_2.place_forget()
                    checkbutton_3.place_forget()
                    checkbutton_4.place_forget()
                    label_nombre_usuario.place_forget()
                    entry_nombre_usuario.place_forget()
                    label_fecha_entrada.place_forget()
                    entry_fecha_entrada.place_forget()
                    labelFrame_archivo_abrir.place_forget()
                    label_ruta_archivo.place_forget()
                    entry_ruta_archivo.place_forget()
                    labelFrame_archivo_información.place_forget()
                    label_ruta_usuario.place_forget()
                    entry_ruta_usuario.place_forget()
                    labelFrame_opciones.place_forget()
                    checkbutton_1.place_forget()
                    labelFrame_estilo.place_forget()
                    canvas_viga.place_forget()
                    labelFrame_contenido.place_forget()
                    combobox.place_forget()
                    label_tipo_viga.place_forget()
                    label_mensaje_ayuda.place_forget()
                    label_contenido_1.place_forget()
                    label_mensaje_ayuda_1.place_forget()
                    boton_aplicar.place_forget()
                    label_prueba.place_forget()
                    labelFrame_Esfuerzos.place_forget()
                    label_longitud.place_forget()
                    label_fuerza.place_forget()
                    label_Momento.place_forget()
                    label_Tension.place_forget()
                    longitud_1.place_forget()
                    Fuerza_1.place_forget()
                    entry_momento.place_forget()
                    entry_tension.place_forget()
                    checkbutton_6.place_forget()
                    labelFrame_Nota.place_forget()
                    label_mensaje_nota.place_forget()
                    labelFrame_Materiales.place_forget()
                    label_concreto.place_forget()
                    label_descripcion_concreto.place_forget()
                    label_acero.place_forget()
                    label_descripcion_acero.place_forget()
                    combo_concreto.place_forget()
                    entry_descripcion_concreto.place_forget()
                    combo_acero.place_forget()
                    entry_descripcion_acero.place_forget()
                    labelFrame_boton.place_forget()
                    label_configuracion.place_forget()
                    
                    
                    
                    
                # Mostrar el contenido para 'Unidades / Fuerzas'
                elif treeview.item(item)['text'] == 'Esfuerzos':
                    labelFrame_Esfuerzos.place(x=50,y=60,width=460,height=250)
                    label_longitud.place(x=20,y=30)
                    label_fuerza.place(x=20,y=70)
                    label_Momento.place(x=20,y=110)
                    label_Tension.place(x=20,y=150)
                    longitud_1.place(x=200,y=30)
                    Fuerza_1.place(x=200,y=70)
                    entry_momento.place(x=200,y=110,width=143)
                    entry_tension.place(x=200,y=150,width=143)
                    checkbutton_6.place(x=30,y=200)
                    labelFrame_Nota.place(x=50,y=320,width=460,height=50)
                    label_mensaje_nota.place(x=10,y=10)
                    
                    
                    
                    
                    
                    # Ocultar otros widgets si no es la opción correcta
                    label_nombre_modelo.place_forget()
                    label_descripcion_modelo.place_forget()
                    entry_nombre_modelo.place_forget()
                    text_detalles_modelo.place_forget()
                    label_nombre_usuario.place_forget()
                    entry_nombre_usuario.place_forget()
                    label_fecha_entrada.place_forget()
                    entry_fecha_entrada.place_forget()
                    labelFrame_archivo_abrir.place_forget()
                    label_ruta_archivo.place_forget()
                    entry_ruta_archivo.place_forget()
                    labelFrame_archivo_información.place_forget()
                    label_ruta_usuario.place_forget()
                    entry_ruta_usuario.place_forget()
                    labelFrame_opciones.place_forget()
                    checkbutton_1.place_forget()
                    labelFrame_complementos.place_forget()
                    checkbutton_2.place_forget()
                    checkbutton_3.place_forget()
                    checkbutton_4.place_forget()
                    labelFrame_estilo.place_forget()
                    canvas_viga.place_forget()
                    labelFrame_contenido.place_forget()
                    combobox.place_forget()
                    label_tipo_viga.place_forget()
                    label_mensaje_ayuda.place_forget()
                    label_contenido_1.place_forget()
                    label_mensaje_ayuda_1.place_forget()
                    boton_aplicar.place_forget()
                    label_prueba.place_forget()
                    label_formato.place_forget()
                    formato_decimal.place_forget()
                    slider_1.place_forget()
                    label_mensaje_formato.place_forget()
                    label_formato_unidades.place_forget()
                    label_unidades_1.place_forget()
                    label_unidades_2.place_forget()
                    label_unidades_3.place_forget()
                    label_unidades_4.place_forget()
                    combo1.place_forget()
                    combo2.place_forget()
                    combo3.place_forget()
                    combo4.place_forget()
                    checkbutton_5.place_forget()
                    labelFrame_Materiales.place_forget()
                    label_concreto.place_forget()
                    label_descripcion_concreto.place_forget()
                    label_acero.place_forget()
                    label_descripcion_acero.place_forget()
                    combo_concreto.place_forget()
                    entry_descripcion_concreto.place_forget()
                    combo_acero.place_forget()
                    entry_descripcion_acero.place_forget()
                    labelFrame_boton.place_forget()
                    label_configuracion.place_forget()
                    
                    
                    # Mostrar el contenido para 'Unidades / Fuerzas'
                if treeview.item(item)['text'] == "Concreto / Acero":
                    labelFrame_Materiales.place(x=50,y=60,width=460,height=260)
                    label_concreto.place(x=80,y=30)
                    label_descripcion_concreto.place(x=80,y=80)
                    label_acero.place(x=80,y=130)
                    label_descripcion_acero.place(x=80,y=180)
                    combo_concreto.place(x=200,y=30)
                    entry_descripcion_concreto.place(x=200,y=80,width=142)
                    combo_acero.place(x=200,y=130)
                    entry_descripcion_acero.place(x=200,y=180,width=142)
                    labelFrame_boton.place(x=50,y=30,width=460,height=30)
                    boton_concreto_acero = tk.Button(labelFrame_Materiales, image=icono_concreto_acero, compound="top",command=abrir_subventana)
                    boton_concreto_acero.place(x=420,y=1)
                    label_configuracion.place(x=1,y=5)
                    
                    
                    # Ocultar todos los widgets si se selecciona otra opción
                    label_nombre_modelo.place_forget()
                    label_descripcion_modelo.place_forget()
                    entry_nombre_modelo.place_forget()
                    text_detalles_modelo.place_forget()
                    label_nombre_usuario.place_forget()
                    entry_nombre_usuario.place_forget()
                    label_fecha_entrada.place_forget()
                    entry_fecha_entrada.place_forget()
                    labelFrame_archivo_abrir.place_forget()
                    label_ruta_archivo.place_forget()
                    entry_ruta_archivo.place_forget()
                    labelFrame_archivo_información.place_forget()
                    label_ruta_usuario.place_forget()
                    entry_ruta_usuario.place_forget()
                    labelFrame_opciones.place_forget()
                    checkbutton_1.place_forget()
                    labelFrame_complementos.place_forget()
                    checkbutton_2.place_forget()
                    checkbutton_3.place_forget()
                    checkbutton_4.place_forget()
                    labelFrame_estilo.place_forget()
                    canvas_viga.place_forget()
                    labelFrame_contenido.place_forget()
                    combobox.place_forget()
                    label_tipo_viga.place_forget()
                    label_mensaje_ayuda.place_forget()
                    label_contenido_1.place_forget()
                    label_mensaje_ayuda_1.place_forget()
                    boton_aplicar.place_forget()
                    label_prueba.place_forget()
                    label_formato.place_forget()
                    formato_decimal.place_forget()
                    slider_1.place_forget()
                    label_mensaje_formato.place_forget()
                    label_formato_unidades.place_forget()
                    label_unidades_1.place_forget()
                    label_unidades_2.place_forget()
                    label_unidades_3.place_forget()
                    label_unidades_4.place_forget()
                    combo1.place_forget()
                    combo2.place_forget()
                    combo3.place_forget()
                    combo4.place_forget()
                    checkbutton_5.place_forget()
                    labelFrame_Esfuerzos.place_forget()
                    label_longitud.place_forget()
                    label_fuerza.place_forget()
                    label_Momento.place_forget()
                    label_Tension.place_forget()
                    longitud_1.place_forget()
                    Fuerza_1.place_forget()
                    entry_momento.place_forget()
                    entry_tension.place_forget()
                    checkbutton_6.place_forget()
                    labelFrame_Nota.place_forget()
                    label_mensaje_nota.place_forget()
                    
                    
                    

        # Vincular el evento de selección para mostrar información
        treeview.bind('<<TreeviewSelect>>', mostrar_informacion)
        
        
        # Crear el frame para mostrar la información (lado derecho)
        frame_derecha = tk.Frame(Ventana_Nuevo, bd=2, relief="raise")
        frame_derecha.place(x=220, y=17, width=560, height=393)

        # Crear una etiqueta para mostrar la información
        label_info = tk.LabelFrame(frame_derecha, text="")
        label_info.place(x=12, y=12, width=535, height=366)

        # Agregar un Label y Entry para "Nuevo modelo" y widgets
        label_nombre_modelo = tk.Label(frame_derecha, text="Nombre del modelo:")
        label_descripcion_modelo= tk.Label(frame_derecha, text="Descripción:") 
        entry_nombre_modelo = tk.Entry(frame_derecha)
        text_detalles_modelo = tk.Text(frame_derecha)
        labelFrame_complementos = tk.LabelFrame(frame_derecha,text="Complementos adicionales")
        
        # Agregar un Label y Entru para "General" y widgets
        label_nombre_usuario =tk.Label(frame_derecha, text="Nombre de usuario:")
        entry_nombre_usuario =tk.Entry(frame_derecha)
        label_fecha_entrada = tk.Label(frame_derecha, text="Fecha:")
        entry_fecha_entrada = tk.Entry(frame_derecha)
        labelFrame_archivo_abrir = tk.LabelFrame(frame_derecha,text="Guardar \ Archivo")
        label_ruta_archivo = tk.Label(labelFrame_archivo_abrir, text="Ruta del archivo:")
        entry_ruta_archivo = tk.Entry(labelFrame_archivo_abrir)
        labelFrame_archivo_información = tk.LabelFrame(frame_derecha, text="Guardar \ Información \ Usuario")
        label_ruta_usuario = tk.Label(labelFrame_archivo_información,text="Ruta del usuario:")
        entry_ruta_usuario = tk.Entry(labelFrame_archivo_información)
        labelFrame_opciones = tk.LabelFrame(frame_derecha,text="Opciones de autoguardado")
        
        # Agregar un Label y Entru para "Estilo de Modelo" y widgets
        labelFrame_estilo = tk.LabelFrame(frame_derecha,text="Plantilla")
        canvas_viga = tk.Canvas(labelFrame_estilo)
        labelFrame_contenido = tk.LabelFrame(frame_derecha,text="Selección de modelo")
        label_tipo_viga = tk.Label(labelFrame_contenido,text="Tipo Viga:")
        label_mensaje_ayuda = tk.Label(labelFrame_contenido,text="",width=30, height=5,bg="white",bd=2,relief="groove",anchor="w", justify="left", wraplength=230)
        label_contenido_1 = tk.LabelFrame(frame_derecha,text="Visualización de modelo")
        label_mensaje_ayuda_1 = tk.Label(label_contenido_1,text="Para ver la visualización del modelo en la ventana principal, haz clic en el botón 'Aplicar'")
        label_prueba = tk.Label(label_contenido_1,text="")
        
        
        # Agregar un Label y Entru para "Unidades / Esfuerzos" y widgets
        label_formato =tk.LabelFrame(frame_derecha,text="")
        formato_decimal= tk.Label(label_formato,text="Valor numérico en formato decimal:")
        label_mensaje_formato = tk.Label(label_formato,text="")
        label_formato_unidades = tk.LabelFrame(frame_derecha,text="")
        label_unidades_1 = tk.Label(label_formato_unidades,text="Dimensiones de la viga:")
        label_unidades_2 = tk.Label(label_formato_unidades,text="Dimensiones de la sección:")
        label_unidades_3 = tk.Label(label_formato_unidades,text="Diamentro barras de refuerzo:")
        label_unidades_4 = tk.Label(label_formato_unidades,text="Área de sección de refuerzo:")
        
        # Agregar un Label y Entru para " Esfuerzos" y widgets
        labelFrame_Esfuerzos = tk.LabelFrame(frame_derecha,text="")
        label_longitud = tk.Label(labelFrame_Esfuerzos,text="Unidad de longitud:")
        label_fuerza = tk.Label(labelFrame_Esfuerzos,text="Unidad de Fuerza:")
        label_Momento = tk.Label(labelFrame_Esfuerzos,text="Unidad de Momento:")
        label_Tension = tk.Label(labelFrame_Esfuerzos,text="Unidad de Tensión:")
        entry_momento = tk.Entry(labelFrame_Esfuerzos)
        entry_tension =  tk.Entry(labelFrame_Esfuerzos)
        labelFrame_Nota = tk.LabelFrame(frame_derecha,text="",bd=0, relief="flat")
        label_mensaje_nota = tk.Label(labelFrame_Nota,text="")
        
        # Agregar un Label y Entru para "Concreto / Acero" y widgets
        labelFrame_Materiales = tk.LabelFrame(frame_derecha,text="Materiales")
        label_concreto = tk.Label(labelFrame_Materiales,text= "Concreto [f'c]:")
        label_descripcion_concreto = tk.Label(labelFrame_Materiales,text="Descripción:")
        label_acero = tk.Label(labelFrame_Materiales,text= "Acero [fy]:")
        label_descripcion_acero = tk.Label(labelFrame_Materiales,text="Descripción:")
        combo_concreto= ttk.Combobox(labelFrame_Materiales)
        entry_descripcion_concreto= tk.Entry(labelFrame_Materiales)
        combo_acero = ttk.Combobox(labelFrame_Materiales)
        entry_descripcion_acero= tk.Entry(labelFrame_Materiales)
        labelFrame_boton = tk.LabelFrame(frame_derecha,text="",bd=0, relief="flat")
        label_configuracion = tk.Label(labelFrame_boton,text="Nota: Haz clic en el ícono en la esquina superior derecha para cargar los materiales.")
        
        # Cargar datos si existen y asignar valores al Combobox
        datos_cargados = cargar_datos()
        opciones_concreto = [
        "f'c = 17.5 MPa",
        "f'c = 21 MPa",
        "f'c = 24.5 MPa",
        "f'c = 28 MPa",
        "f'c = 35 MPa",
        "f'c = 42 MPa",
        ]
        opciones_acero = [
        "fy = 240 MPa",
        "fy = 420 MPa",
        ]
        combo_concreto["values"] = opciones_concreto  
        combo_acero["values"] = opciones_acero
        
        if datos_cargados:
            entry_nombre_usuario.insert(0, datos_cargados.get("nombre_usuario", ""))
            entry_nombre_modelo.insert(0, datos_cargados.get("nombre_modelo", ""))
            text_detalles_modelo.insert("1.0", datos_cargados.get("detalles_modelo", ""))
            combo_concreto.set(datos_cargados.get("combo_concreto", opciones_concreto[0]))
            combo_acero.set(datos_cargados.get("combo_acero", opciones_acero[0]))
        
        else:
            Ventana_Nuevo.focus_set()
        
        
        # Botón "Aceptar" para guardar los datos
        boton_aceptar = tk.Button(Ventana_Nuevo, text="Aceptar",command=guardar_datos)
        boton_aceptar.place(x=350,y=430,width=100)
        
        
        # Lista con las opciones de unidades Longitud/Fuerza
        
        Longitud= ["m"]
        Fuerza =  ["kN"]
        
        # Crear el ComboBox y agregar las opciones
        longitud_1 = ttk.Combobox(labelFrame_Esfuerzos, values=Longitud)
        longitud_1.set("Seleccionar")
        Fuerza_1 = ttk.Combobox(labelFrame_Esfuerzos, values=Fuerza)
        Fuerza_1.set("Seleccionar")
        
        
        # Función que actualiza los valores en los Entry cuando se seleccionan las unidades
        def actualizar_unidades(event):
        # Obtener los valores seleccionados en los ComboBox
            unidad_fuerza = Fuerza_1.get()
            unidad_longitud = longitud_1.get()
        
        # Comprobar si ambos ComboBox tienen opciones seleccionadas
            if unidad_fuerza != "Seleccionar" and unidad_longitud != "Seleccionar":
        # Actualizar el valor del momento y la tensión
                entry_momento.delete(0, tk.END)
                entry_tension.delete(0, tk.END)
        
                entry_momento.insert(0, f"{unidad_fuerza}{unidad_longitud}")  # Ejemplo: kNm
                entry_tension.insert(0, f"{unidad_fuerza}{unidad_longitud}²")  # Ejemplo: kNm²
        
        # Vincular la función al evento de cambio de selección en los ComboBox
        Fuerza_1.bind("<<ComboboxSelected>>", actualizar_unidades)
        longitud_1.bind("<<ComboboxSelected>>", actualizar_unidades)
        
        # Lista con las opciones de unidades
        unidades = ["metros", "centímetos", "milímetros"]
        
        # Crear el ComboBox y agregar las opciones
        combo1 = ttk.Combobox(label_formato_unidades, values=unidades)
        combo1.set("Seleccionar")  # Establecer el valor por defecto
        
        combo2 = ttk.Combobox(label_formato_unidades, values=unidades)
        combo2.set("Seleccionar")  # Establecer el valor por defecto
        
        combo3 = ttk.Combobox(label_formato_unidades, values=unidades)
        combo3.set("Seleccionar")  # Establecer el valor por defecto
        
        combo4= ttk.Combobox(label_formato_unidades, values=unidades)
        combo4.set("Seleccionar")  # Establecer el valor por defecto
        
        
        # Combobox dentro de labelFrame_contenido
        combobox = ttk.Combobox(labelFrame_contenido, values=["Viga apoyada","Viga empotrada "])
        combobox.set("Selecciona una opción")
        combobox.bind("<<ComboboxSelected>>", lambda event: on_combobox_select(event, canvas_viga,label_mensaje_ayuda,label_prueba))
        
        # Botón para visualizar modelo viga 
        boton_aplicar= tk.Button(label_contenido_1,text="Aplicar",command=lambda: on_boton_aplicar_click(label_contenido_1, label_prueba))
        
        def update_label(val):
        # Convertir el valor a entero y calcular cuántos ceros agregar
            num_zeros = int(val)  # El valor del slider es un número entero que indica los ceros
            formatted_value = "0." + "0" * num_zeros  # Construir el número con 'num_zeros' ceros
            label_mensaje_formato.config(text=formatted_value)  # Actualizar la etiqueta con el valor formateado
        
        # Crear el mensaje con el valor del slider y la recomendación
            mensaje_slider = f"Seleccionaste el valor en formato decimal con una precisión de: {formatted_value}"
            label_mensaje_formato.config(text=mensaje_slider)  # Actualizar el mensaje en el label
        
        
        # Configurar el slider (de 0 a 4, con incremento de 1, orientado horizontalmente)
        slider_1 = tk.Scale(label_formato, from_=0, to=4, resolution=1, orient="horizontal", command=update_label)
        slider_1.set(0)  # Establecer valor inicial en 0
        
        #Crear widgets para "General"
        # Variable de control para el checkbutton
        var = tk.IntVar()
        var1 = tk.IntVar()
        var2 = tk.IntVar()
        var3 = tk.IntVar()
        var4 = tk.IntVar()
        var5 = tk.IntVar()
        
        # Función para cambiar el color del chulito cuando se marca o desmarca
        def cambiar_color(checkbutton,var):
            if var.get() == 1:
                checkbutton.config(selectcolor="blue")
            else:
                checkbutton.config(selectcolor="")
        
        
        # Función para cambiar el formato de los ComboBoxes cuando se activa el Checkbutton
        def aplicar_formato_predefinido():
            if var4.get() == 1:  # Si el Checkbutton está activado
                combo1.set("metros")  # Primer ComboBox -> "metros"
                combo2.set("metros")  # Segundo ComboBox -> "metros"
                combo3.set("milímetros")  # Tercer ComboBox -> "milímetros"
                combo4.set("milímetros")  # Cuarto ComboBox -> "milímetros"
            else:
        # Si el Checkbutton está desactivado, los ComboBoxes se reinician a "Seleccionar"
                combo1.set("Seleccionar")
                combo2.set("Seleccionar")
                combo3.set("Seleccionar")
                combo4.set("Seleccionar")
        
        # Función para manejar el Checkbutton y seleccionar valores por defecto
        def cambiar_a_valores_por_defecto():
            if var5.get():  # Si el Checkbutton está marcado
        # Establecer los valores predeterminados en los ComboBox
                Fuerza_1.set("kN")
                longitud_1.set("m")
        
        # Actualizar los campos de entrada
                entry_momento.delete(0, tk.END)
                entry_tension.delete(0, tk.END)
                entry_momento.insert(0, "kNm")  # Valor predeterminado para el momento
                entry_tension.insert(0, "kNm²")  # Valor predeterminado para la tensión
                
                # Mostrar un mensaje interactivo en el label
                label_mensaje_nota.config(text="¡Muy bien! Ahora continua con la configuración de los materiales.")
        
            else:
        # Si el Checkbutton está desmarcado, dejar las opciones en blanco o por defecto
                Fuerza_1.set("Seleccionar")
                longitud_1.set("Seleccionar")
                entry_momento.delete(0, tk.END)
                entry_tension.delete(0, tk.END)
                entry_momento.insert(0, "Momento")  # Valor predeterminado (opcional)
                entry_tension.insert(0, "Tensión")  # Valor predeterminado (opcional)
        
        # Crear el Checkbutton personalizado
        checkbutton_1 = tk.Checkbutton(
        labelFrame_opciones,
        text="Guardar información predeterminada",   
        variable=var,                                
        onvalue=1,                                    
        offvalue=0,                                   
        indicatoron=True,                             
        selectcolor="",                               
        command=lambda: cambiar_color(checkbutton_1, var)                   
        )
        
        # Crear el Checkbutton para "Generar documento Word"
        checkbutton_2 = tk.Checkbutton(
        labelFrame_complementos,
        text="Generar documento Word",
        variable=var1,
        onvalue=1,
        offvalue=0,
        indicatoron=True,
        selectcolor="",
        command=lambda: cambiar_color(checkbutton_2, var1)
        )
        
        # Crear el Checkbutton para "Generar archivo PDF"
        checkbutton_3 = tk.Checkbutton(
        labelFrame_complementos,
        text="Generar archivo PDF",
        variable=var2,
        onvalue=1,
        offvalue=0,
        indicatoron=True,
        selectcolor="",
        command=lambda: cambiar_color(checkbutton_3, var2)
        )
        
        
        # Crear el Checkbutton para "Exportar datos a Excel"
        checkbutton_4 = tk.Checkbutton(
        labelFrame_complementos,
        text="Exportar datos a Excel",
        variable=var3,
        onvalue=1,
        offvalue=0,
        indicatoron=True,
        selectcolor="",
        command=lambda: cambiar_color(checkbutton_4, var3)
        )
        # Crear el Checkbutton para seleccionar formato predefinido
        checkbutton_5 = tk.Checkbutton(
        label_formato_unidades, 
        text="Seleccionar formato predefinido",
        variable=var4,
        onvalue=1,
        offvalue=0,
        indicatoron=True,
        selectcolor="",
        command=lambda: [aplicar_formato_predefinido(), cambiar_color(checkbutton_5, var4)] 
        )        
        # Crear el Checkbutton para seleccionar formato predefinido
        checkbutton_6 = tk.Checkbutton(
        labelFrame_Esfuerzos, 
        text="Seleccionar configuración por defecto",
        variable=var5,
        onvalue=1,
        offvalue=0,
        indicatoron=True,
        selectcolor="",
        command=lambda: [cambiar_a_valores_por_defecto(), cambiar_color(checkbutton_6, var5)]
        )
        
        def actualizar_fecha():
        # Obtener la fecha actual en la zona horaria de Colombia
            zona_horaria_colombia = timezone('America/Bogota')
            fecha_actual = datetime.now(zona_horaria_colombia).strftime('%d-%m-%Y') 
        
        # Verificar si el widget sigue existiendo antes de actualizarlo
            if entry_fecha_entrada.winfo_exists():  # Verifica si el widget sigue existiendo
            # Limpiar el Entry y poner la nueva fecha
                entry_fecha_entrada.delete(0, tk.END)
                entry_fecha_entrada.insert(0, fecha_actual)
        
        # Llamar a esta función de nuevo después de 1000 ms (1 segundo) para actualizar la fecha
            ventana.after(1000, actualizar_fecha)
            
        # Llamar a la función para actualizar la fecha
        actualizar_fecha()
        
        # Función para obtener la ruta de la carpeta "Archivos_Pilot" en el escritorio
        def obtener_ruta_archivos_pilot():
        # Obtenemos el directorio de "Escritorio" según el sistema operativo
            sistema = platform.system()
        
            if sistema == "Windows":
        # En Windows, obtenemos el "Desktop" del usuario
                ruta_base = os.path.join(os.environ["USERPROFILE"], "Desktop")
            elif sistema == "Darwin":  # macOS
        # En macOS, obtenemos el "Desktop" del usuario
                ruta_base = os.path.join(os.path.expanduser("~"), "Desktop")
            elif sistema == "Linux":
        # En Linux, igualmente el "Desktop"
                ruta_base = os.path.join(os.path.expanduser("~"), "Desktop")
            else:
        # Si no es Windows, macOS ni Linux, retornamos una ruta genérica
                ruta_base = os.path.expanduser("~")
        
        # Ruta final donde guardaremos los archivos
            ruta_archivos_pilot = os.path.join(ruta_base, "Archivos_Pilot")
            
        # Si la carpeta "Archivos_Pilot" no existe, la creamos
            if not os.path.exists(ruta_archivos_pilot):
                os.makedirs(ruta_archivos_pilot)
        
            return ruta_archivos_pilot
        
        # Función para mostrar la ruta en el Entry
        def mostrar_ruta_archivos_pilot():
        # Obtener la ruta de "Archivos_Pilot" dependiendo del sistema
            ruta_archivos = obtener_ruta_archivos_pilot()
        
        # Mostrar la ruta en el Entry
            entry_ruta_archivo.delete(0, tk.END)  # Limpiar el Entry
            entry_ruta_archivo.insert(0, ruta_archivos)  # Insertar la ruta correcta
        
        # Llamamos a la función para mostrar la ruta al iniciar la aplicación
        mostrar_ruta_archivos_pilot()


# Ruta de la carpeta base_datos en tu entorno de programa
carpeta_base_datos = "base_datos"
archivo_datos_materiales = os.path.join(carpeta_base_datos, "datos_materiales.txt")  # Archivo donde se guardarán los datos

# Crear la carpeta base_datos si no existe
if not os.path.exists(carpeta_base_datos):
    os.makedirs(carpeta_base_datos)

ventana_materiales_abierta = False
# Variables globales para los Entry y ComboBox
entry_resistencia_concreto = None
entry_modulo_concreto = None
combo_resistencia_concreto = None
label_mensaje_materiales = None

# Función para guardar los datos de los materiales
def guardar_datos_materiales():
    """Guarda los datos de los widgets en un archivo de texto (ventana materiales)."""
    # Obtener los datos de los Entry y ComboBox
    resistencia_concreto = entry_resistencia_concreto.get().strip()
    modulo_concreto = entry_modulo_concreto.get().strip()
    #Obtener el texto del Label (mensaje)
    mensaje_materiales = label_mensaje_materiales.cget("text")  


    # Crear un diccionario con los datos que se van a guardar
    datos_materiales = {
        "resistencia_concreto": resistencia_concreto,
        "modulo_concreto": modulo_concreto,
        "mensaje_materiales": mensaje_materiales  
    }

    # Guardar los datos en el archivo de texto
    with open(archivo_datos_materiales, "w") as archivo:
        for clave, valor in datos_materiales.items():
            archivo.write(f"{clave}:{valor}\n")

    

# Función para cargar los datos desde el archivo de materiales
def cargar_datos_materiales():
    """Carga los datos desde el archivo de texto de materiales si existe."""
    datos_materiales = {}
    try:
        with open(archivo_datos_materiales, "r") as archivo:
            for linea in archivo:
                clave, valor = linea.strip().split(":", 1)
                datos_materiales[clave] = valor
    except FileNotFoundError:
        pass  # Si el archivo no existe, no hacemos nada

    # Cargar los datos en los Entry de la ventana de materiales y label
    if datos_materiales:
        entry_resistencia_concreto.insert(0, datos_materiales.get("resistencia_concreto", ""))
        entry_modulo_concreto.insert(0, datos_materiales.get("modulo_concreto", ""))
        # Cargar el mensaje en el Label
        label_mensaje_materiales.config(text=datos_materiales.get("mensaje_materiales", ""))

# Función para manejar la lógica de la ventana de materiales
def on_aceptar_materiales():
    """Función que se ejecuta cuando se hace clic en el botón 'Aceptar'"""
    # Guardar los datos de los Entry y ComboBox en el archivo
    guardar_datos_materiales()
    
    # Aquí puedes agregar más lógica si deseas, como cerrar la ventana o realizar otro proceso
    
    # Cerrar la ventana de materiales
    global ventana_materiales_abierta, ventana_materiales
    ventana_materiales_abierta = False  # Marcar que la ventana ya no está abierta
    ventana_materiales.destroy()  # Cerrar la ventana de materiales

# Función para abrir la ventana materiales

def abrir_ventana_materiales():
    global ventana_materiales_abierta,ventana_materiales
    global entry_resistencia_concreto, entry_modulo_concreto, combo_resistencia_concreto,label_mensaje_materiales
    
    # Verificar si la ventana ya está abierta
    if ventana_materiales_abierta:
        return  # Si ya está abierta, no hacer nada
    
    # Crear una nueva ventana (Toplevel)
    ventana_materiales = tk.Toplevel()
    ventana_materiales.title("Materiales")
    ventana_materiales.geometry("600x600")  # Ajusta el tamaño según sea necesario
    
    # Bloquear la opción de redimensionar la ventana
    ventana_materiales.resizable(False, False)
    
    # Mantener la ventana siempre encima
    ventana_materiales.attributes('-topmost', True)
    
    # Marcar que la ventana está abierta
    ventana_materiales_abierta = True
    
    # Lista de datos para el ComboBox
    opciones_resistencia = ["17.5 Mpa", "21 Mpa", "24.5 Mpa", "28 Mpa", "35 Mpa", "42 Mpa"]
    
    # Crear un LabelFrame para agrupar el contenido de Materiales
    labelframe_materiales= tk.LabelFrame(ventana_materiales,text="")
    labelframe_materiales.pack(padx=20, pady=20, fill="both", expand=True)
    labelframe_titulo = tk.LabelFrame(labelframe_materiales,text="Materiales")
    labelframe_titulo.place(x=30,y=30,width=500,height=200)
    label_resistencia_concreto=tk.Label(labelframe_titulo,text="Resistencia a la compresión del concreto [f'c]:")
    label_resistencia_concreto.place(x=10,y=20)
    label_resistencia_tipo = tk.Label(labelframe_titulo,text="Resistencia concreto tipo [C]:")
    label_resistencia_tipo.place(x=10,y=60)
    label_resistencia_acero= tk.Label(labelframe_titulo,text="Resistencia a la tensión del acero [fy]:")
    label_resistencia_acero.place(x=10,y=100)
    label_peso_concreto = tk.Label(labelframe_titulo,text="Peso específico del concreto [γ]:")
    label_peso_concreto.place(x=10,y=140)
    combo_resistencia_concreto= ttk.Combobox(labelframe_titulo, values=opciones_resistencia)
    combo_resistencia_concreto.place(x=300,y=20)
    entry_resistencia_concreto= tk.Entry(labelframe_titulo)
    entry_resistencia_concreto.place(x=300,y=60,width=143)
    entry_resistencia_acero= tk.Entry(labelframe_titulo)
    entry_resistencia_acero.place(x=300,y=100,width=143)
    entry_resistencia_acero.insert(0, "420 MPa")
    entry_peso_concreto= tk.Entry(labelframe_titulo)
    entry_peso_concreto.place(x=300,y=140,width=143)
    entry_peso_concreto.insert(0,"24.00 kN/m³")
    labelframe_propiedades = tk.LabelFrame(labelframe_materiales,text="Propiedades mecánicas")
    labelframe_propiedades.place(x=30,y=250,width=500,height=200)
    label_modulo_concreto = tk.Label(labelframe_propiedades,text="Módulo elasticidad del concreto [Ec]:")
    label_modulo_concreto.place(x=10,y=20)
    entry_modulo_concreto= tk.Entry(labelframe_propiedades)
    entry_modulo_concreto.place(x=300,y=20,width=143)
    label_modulo_acero = tk.Label(labelframe_propiedades,text="Módulo elasticidad del acero [Es]:")
    label_modulo_acero.place(x=10,y=60)
    entry_modulo_acero= tk.Entry(labelframe_propiedades)
    entry_modulo_acero.place(x=300,y=60,width=143)
    entry_modulo_acero.insert(0, "200000 MPa")  
    label_deformacion_concreto = tk.Label(labelframe_propiedades,text="Deformación unitaria concreto [Ɛc]: ")
    label_deformacion_concreto.place(x=10,y=100)
    entry_deformacion_concreto = tk.Entry(labelframe_propiedades)
    entry_deformacion_concreto.place(x=300,y=100,width=143)
    entry_deformacion_concreto.insert(0, "0.003")
    label_deformacion_acero = tk.Label(labelframe_propiedades,text="Deformación unitaria acero [Ɛs]: ")
    label_deformacion_acero.place(x=10,y=140)
    entry_deformacion_acero = tk.Entry(labelframe_propiedades)
    entry_deformacion_acero.place(x=300,y=140,width=143)
    entry_deformacion_acero.insert(0, "0.005")  
    labelframe_mensaje_materiales= tk.LabelFrame(labelframe_materiales,text="")
    labelframe_mensaje_materiales.place(x=30,y=460,width=500,height=50)
    label_mensaje_materiales = tk.Label(labelframe_mensaje_materiales,justify="left",anchor="w",wraplength=500)
    label_mensaje_materiales.place(x=10,y=5)
    boton_aceptar_materiales = tk.Button(labelframe_materiales,text="Aceptar",command=on_aceptar_materiales)
    boton_aceptar_materiales.place(x=220,y=520,width=100)
    
    # Cargar datos al abrir la ventana
    cargar_datos_materiales()
    
    # Función para actualizar el Entry según la selección del ComboBox
    def actualizar_entry(event):
        seleccion1 = combo_resistencia_concreto.get()  # Obtener la opción seleccionada
        if seleccion1 == "17.5 Mpa":
            entry_resistencia_concreto.delete(0, tk.END)  # Limpiar el Entry
            entry_resistencia_concreto.insert(0, "Concreto 2500 Psi")
        elif seleccion1 == "21 Mpa":
            entry_resistencia_concreto.delete(0, tk.END)
            entry_resistencia_concreto.insert(0, "Concreto 3000 Psi")
        elif seleccion1 == "24.5 Mpa":
            entry_resistencia_concreto.delete(0, tk.END)
            entry_resistencia_concreto.insert(0, "Concreto 3500 Psi")
        elif seleccion1 == "28 Mpa":
            entry_resistencia_concreto.delete(0, tk.END)
            entry_resistencia_concreto.insert(0, "Concreto 4000 Psi")
        elif seleccion1 == "35 Mpa":
            entry_resistencia_concreto.delete(0, tk.END)
            entry_resistencia_concreto.insert(0, "Concreto 5000 Psi")
        elif seleccion1 == "42 Mpa":
            entry_resistencia_concreto.delete(0, tk.END)
            entry_resistencia_concreto.insert(0, "Concreto 6000 Psi")
            
        #cálculo del módulo de elasticidad del concreto (Ec)
        f_c = float(seleccion1.split(" ")[0])  
        Ec = 3900 * math.sqrt(f_c)  # Calcular el módulo de elasticidad
        # Actualizar el entry_modulo_concreto con el resultado del cálculo
        entry_modulo_concreto.delete(0, tk.END)
        entry_modulo_concreto.insert(0, f"{Ec:.4f} MPa")  
        
        # Actualizar el Label con el mensaje personalizado
        mensaje1 = f"Has seleccionado el material {seleccion1}. Ahora,el siguiente paso es definir las propiedades geométricas de la sección transversal."
        label_mensaje_materiales.config(text=" " + mensaje1)
    
    # Asociar la función de actualización del Entry con el evento de selección del ComboBox
    combo_resistencia_concreto.bind("<<ComboboxSelected>>", actualizar_entry)
    
    # Función para manejar el cierre de la ventana
    def cerrar_ventana():
        global ventana_materiales_abierta
        ventana_materiales_abierta = False
        ventana_materiales.destroy()
    
    # Asociar el cierre de la ventana con la función `cerrar_ventana`
    ventana_materiales.protocol("WM_DELETE_WINDOW", cerrar_ventana)
    


# Variables globales para los Entry y Labels
entry_luz_seccion = None
entry_base_seccion = None
entry_altura_seccion = None
entry_recubrimiento_seccion = None
entry_d_seccion = None
entry_nombre_seccion = None
label_resumen_1 = None
label_resumen_2 = None
label_resumen_3 = None
label_resumen_4 = None
label_resumen_5 = None
label_resumen_6 = None

# Ruta de la carpeta base_datos en tu entorno de programa
carpeta_base_datos = "base_datos"
archivo_datos_seccion = os.path.join(carpeta_base_datos, "datos_seccion.txt")

# Crear la carpeta base_datos si no existe
if not os.path.exists(carpeta_base_datos):
    os.makedirs(carpeta_base_datos)

# Función para guardar los datos de la sección transversal
def guardar_datos_seccion():
    """Guarda los datos de los Entry y Labels en un archivo de texto (ventana secciones)."""
    # Obtener los datos de los Entry y Labels
    luz_seccion = entry_luz_seccion.get().strip()
    base_seccion = entry_base_seccion.get().strip()
    altura_seccion = entry_altura_seccion.get().strip()
    recubrimiento_seccion = entry_recubrimiento_seccion.get().strip()
    d_seccion = entry_d_seccion.get().strip()
    nombre_seccion = entry_nombre_seccion.get().strip()

# Obtener los textos de los Labels (resumen)
    resumen_1 = label_resumen_1.cget("text")
    resumen_2 = label_resumen_2.cget("text")
    resumen_3 = label_resumen_3.cget("text")
    resumen_4 = label_resumen_4.cget("text")
    resumen_5 = label_resumen_5.cget("text")
    resumen_6 = label_resumen_6.cget("text")

# Crear un diccionario con los datos que se van a guardar
    datos_seccion = {
        "luz_seccion": luz_seccion,
        "base_seccion": base_seccion,
        "altura_seccion": altura_seccion,
        "recubrimiento_seccion": recubrimiento_seccion,
        "d_seccion": d_seccion,
        "nombre_seccion": nombre_seccion,
        "resumen_1": resumen_1,
        "resumen_2": resumen_2,
        "resumen_3": resumen_3,
        "resumen_4": resumen_4,
        "resumen_5": resumen_5,
        "resumen_6": resumen_6,
    }

# Guardar los datos en el archivo de texto
    with open(archivo_datos_seccion, "w") as archivo:
        for clave, valor in datos_seccion.items():
            archivo.write(f"{clave}:{valor}\n")

    # Mostrar un mensaje de confirmación
    print("Datos guardados exitosamente en el archivo.")

# Función para cargar los datos desde el archivo de la sección
def cargar_datos_seccion():
    """Carga los datos desde el archivo de texto de la sección si existe."""
    datos_seccion = {}
    
    try:
        with open(archivo_datos_seccion, "r") as archivo:
            for linea in archivo:
                clave, valor = linea.strip().split(":", 1)
                datos_seccion[clave] = valor
    except FileNotFoundError:
        pass  # Si el archivo no existe, no hacemos nada

    # Actualizar los Entry y Labels con los datos cargados
    if datos_seccion:
        entry_luz_seccion.delete(0, tk.END)
        entry_luz_seccion.insert(0, datos_seccion.get("luz_seccion", ""))
        
        entry_base_seccion.delete(0, tk.END)
        entry_base_seccion.insert(0, datos_seccion.get("base_seccion", ""))
        
        entry_altura_seccion.delete(0, tk.END)
        entry_altura_seccion.insert(0, datos_seccion.get("altura_seccion", ""))
        
        entry_recubrimiento_seccion.delete(0, tk.END)
        entry_recubrimiento_seccion.insert(0, datos_seccion.get("recubrimiento_seccion", ""))
        
        entry_d_seccion.delete(0, tk.END)
        entry_d_seccion.insert(0, datos_seccion.get("d_seccion", ""))
        
        entry_nombre_seccion.delete(0, tk.END)
        entry_nombre_seccion.insert(0, datos_seccion.get("nombre_seccion", ""))

        # Cargar los valores en los Labels de resumen
        label_resumen_1.config(text=datos_seccion.get("resumen_1", ""))
        label_resumen_2.config(text=datos_seccion.get("resumen_2", ""))
        label_resumen_3.config(text=datos_seccion.get("resumen_3", ""))
        label_resumen_4.config(text=datos_seccion.get("resumen_4", ""))
        label_resumen_5.config(text=datos_seccion.get("resumen_5", ""))
        label_resumen_6.config(text=datos_seccion.get("resumen_6", ""))

# Variable global para controlar si la ventana ya está abierta
ventana_secundaria_abierta = False



canvas_falso = None  # Canvas donde dibujaremos el rectángulo en frame_ventana_falsa
frame_ventana_seccion = None  # El frame principal donde se encuentra frame_ventana_falsa
frame_ventana_falsa = None  # El frame donde se dibujará el rectángulo
entry_base_seccion = None  # Entry para base del rectángulo
entry_altura_seccion = None  # Entry para altura del rectángulo
combo_resistencia = None


# Constantes para grosor
GROSORES = {
    'outer_thickness': 1.5,  # Grosor del borde externo
}

# Función para dibujar la sección rectangular con base y altura
def draw_section(ax, base, altura):
    ax.clear()

    # Configuración de estilo
    ax.figure.patch.set_facecolor('white')
    ax.set_facecolor('white')
    for spine in ax.spines.values():
        spine.set_edgecolor('black')
    ax.xaxis.label.set_color('black')
    ax.yaxis.label.set_color('black')
    ax.title.set_color('black')
    ax.tick_params(axis='both', colors='black')

    x = 0
    y = 0
    width = base
    height = altura

    # Dibujo del rectángulo exterior (sección completa)
    outer_rect = patches.Rectangle((x, y), width, height, linewidth=GROSORES['outer_thickness'], edgecolor='black', facecolor='grey')
    ax.add_patch(outer_rect)
    
    # Obtener el valor seleccionado del combo_resistencia
    resistencia_value = combo_resistencia.get()  # Obtener el valor seleccionado en el combo
    
    # Agregar la leyenda justo debajo de la etiqueta "Base"
    legend_line = Line2D([0], [0], color='grey', lw=4, label=f'Concreto {resistencia_value}')
    ax.legend(handles=[legend_line], bbox_to_anchor=(0.5, -0.3), loc='upper center', fontsize=8, frameon=True, edgecolor='black')
    
    # Coordenadas para centrar el título dentro del rectángulo
    center_x = base / 2
    center_y = altura / 2

    # Agregar el texto centrado dentro del rectángulo
    ax.text(center_x, center_y, f"VG {int(base)} X {int(altura)}", 
            color='black', fontsize=8, ha='center', va='center')

    # Configuración de los límites y etiquetas del gráfico
    ax.set_xlim(-10, width + 10)
    ax.set_ylim(-10, height + 10)
    ax.set_aspect('equal')
    
    # Reducir tamaño de los ticks
    ax.tick_params(axis='both', which='major', labelsize=6)

    # Ajuste automático de los márgenes
    plt.tight_layout(pad=0.5)

# Función para actualizar el gráfico con los valores ingresados
def update_plot():
    try:
        # Obtener los valores de los entries y multiplicarlos por 100
        base = float(entry_base_seccion.get().strip()) * 100  # Multiplicamos por 100
        altura = float(entry_altura_seccion.get().strip()) * 100  # Multiplicamos por 100

        # Crear la figura y el eje con un tamaño que se ajustará al contenedor
        fig, ax = plt.subplots(figsize=(3, 3))  # Tamaño base para la figura
        draw_section(ax, base, altura)
        
        # Actualizar las etiquetas del eje x e y con el nuevo formato
        ax.set_xlabel(f"Base ({int(base)}cm)", fontsize=8)
        ax.set_ylabel(f"Altura ({int(altura)}cm)", fontsize=8)
        
        # Eliminar los elementos anteriores del canvas
        for widget in frame_ventana_falsa.winfo_children():
            widget.destroy()
        
        # Crear el canvas
        canvas = FigureCanvasTkAgg(fig, master=frame_ventana_falsa)
        canvas.draw()
        
        # Obtener el widget del canvas
        canvas_widget = canvas.get_tk_widget()
        
        # Crear la etiqueta de mensaje (label) que se animará, solo si no existe
        if not hasattr(update_plot, "label_mensaje_falsa"):  # Comprobamos si la etiqueta ya existe
            update_plot.label_mensaje_falsa = tk.Label(label_titulo_falsa, text="¡Muy bien! Ahora, continúa con las opciones de asignar.", bd=0,relief="flat")
            update_plot.label_mensaje_falsa.place(x=1, y=1, width=380, height=20)
            
            # Iniciar la animación de la etiqueta
            animate_label_movement(update_plot.label_mensaje_falsa)
        
        # Ajustar el canvas para que ocupe todo el espacio disponible en el contenedor
        canvas_widget.place(relwidth=1, relheight=1)  # Ocupa el 100% del espacio del frame

    except ValueError as e:
        print(f"Error: {e}")

# Función para animar el movimiento de la etiqueta de mensaje
def animate_label_movement(label):
    def move_label():
        # Obtener la posición actual del texto
        current_x = label.winfo_x()
        new_x = current_x + 2  # Desplazar 2 píxeles hacia la derecha
        
        # Si el texto se sale de la pantalla, reiniciarlo desde el borde izquierdo
        if new_x > label_titulo_falsa.winfo_width():
            new_x = -label.winfo_width()
        
        label.place(x=new_x, y=5)  # Actualizar la posición de la etiqueta
        label.after(50, move_label)  # Llamar a la función cada 50 ms para animar
    
    move_label()  # Llamar la función para iniciar la animación


# Función para abrir la ventana seccion transversal

def abrir_ventana_seccion_transversal():
    global ventana_secundaria_abierta
    global frame_ventana_seccion,frame_ventana_falsa,label_titulo_falsa,label_mensaje_falsa
    global entry_luz_seccion, entry_base_seccion, entry_altura_seccion, entry_recubrimiento_seccion, entry_d_seccion, entry_nombre_seccion
    global label_resumen_1, label_resumen_2, label_resumen_3, label_resumen_4, label_resumen_5, label_resumen_6,combo_resistencia
    if ventana_secundaria_abierta:
        return
    
    # Crear la ventana secundaria
    ventana_secundaria = tk.Toplevel()
    ventana_secundaria.title("Propiedades geométricas de la sección")
    
    # Evitar que la ventana sea maximizada o redimensionada
    ventana_secundaria.resizable(False, False)
    
    # Mantener la ventana siempre encima
    ventana_secundaria.attributes('-topmost', True)
    
    # Definir el tamaño de la ventana
    ventana_secundaria.geometry("500x530")
    
    # Crear contenido dentro de la ventana secundaria
    label_frame_seccion = tk.LabelFrame(ventana_secundaria, text="")
    label_frame_seccion.place(x=20,y=20,width=460,height=460)
    
    label_frame_caracteristicas = tk.LabelFrame(label_frame_seccion,text="Características adicionales")
    label_frame_caracteristicas.place(x=30,y=30,width=400,height=80)
    
    label_tipo_viga= tk.Label(label_frame_caracteristicas,text="Elemento tipo:")
    label_tipo_viga.place(x=30,y=15)
    entry_tipo_viga= tk.Entry(label_frame_caracteristicas)
    entry_tipo_viga.place(x=120,y=15 ,width=70)
    entry_tipo_viga.insert(0, "Viga")  
    label_seccion_viga= tk.Label(label_frame_caracteristicas,text="Sección:")
    label_seccion_viga.place(x=200,y=15)
    entry_seccion_viga = tk.Entry(label_frame_caracteristicas)
    entry_seccion_viga.place(x=260,y=15,width=70)
    entry_seccion_viga.insert(0,"Rectangular")
    frame_seccion_viga= tk.Frame(label_frame_seccion,bd=2,relief="ridge")
    frame_seccion_viga.place(x=30,y=120,width=400,height=300)
    
    # Crear un objeto Style para personalizar el estilo del Notebook
    style = ttk.Style()
    
    # Cambiar el fondo de las pestañas y del notebook
    style.configure("TNotebook", background="lightgrey", relief="flat")  
    style.configure("TNotebook.Tab", background="lightgrey", foreground="black")
    
    # Cambiar el color del área de contenido dentro de la pestaña
    style.map("TNotebook.Tab", background=[("selected", "lightgrey")])  # Color de la pestaña seleccionada
    
    # Crear un Notebook para las pestañas
    notebook = ttk.Notebook(frame_seccion_viga,style="TNotebook")
    notebook.pack(fill="both", expand=True)
    
    # Crear la pestaña "Sección transversal"
    pestaña_seccion = tk.Frame(notebook)
    notebook.add(pestaña_seccion, text="Sección transversal")
    
    # Crear la pestaña "Resumén"
    pestaña_resumen = tk.Frame(notebook)
    notebook.add(pestaña_resumen, text="Resumen")
    
    # Crear un Frame dentro de la pestaña "Sección transversal"
    frame_pest_seccion = tk.Frame(pestaña_seccion, bd=2, relief="flat",bg="white")
    frame_pest_seccion.pack(fill="both", expand=True)
    
    variable_seccion = tk.StringVar()
    
    labelframe_dimensiones= tk.LabelFrame(frame_pest_seccion,text="Dimensiones [m]",bg="white")
    labelframe_dimensiones.place(x=30,y=10,width=330,height=190)
    label_luz_seccion = tk.Label(labelframe_dimensiones,text="L:",bg="white")
    label_luz_seccion.place(x=10,y=10)
    label_base_seccion = tk.Label(labelframe_dimensiones,text="b:",bg="white")
    label_base_seccion.place(x=10,y=40)
    label_altura_seccion = tk.Label(labelframe_dimensiones,text="h:",bg="white")
    label_altura_seccion.place(x=10,y=70)
    label_recubrimiento_seccion = tk.Label(labelframe_dimensiones,text="r:",bg="white")
    label_recubrimiento_seccion.place(x=10,y=100)
    label_d_seccion = tk.Label(labelframe_dimensiones,text="d:",bg="white")
    label_d_seccion.place(x=10,y=130)
    label_nombre_seccion = tk.Label(frame_pest_seccion, text="Viga:",bg="white")
    label_nombre_seccion.place(x=30,y=220)
    entry_nombre_seccion = tk.Entry(frame_pest_seccion,bd=2, relief="ridge",textvariable=variable_seccion)
    entry_nombre_seccion.place(x=80,y=220,width=80)
    label_fc_seccion = tk.Label(frame_pest_seccion,text="f'c:",bg="white")
    label_fc_seccion.place(x=200,y=220)
    
    # Tarea interna de la función (esto puede ser cualquier acción que modifique el contenido del Entry)
    variable_seccion.set("Algunos datos")  # Ejemplo de cómo poner datos en el Entry
    
    # Ahora el Label fuera de la función puede acceder a la variable_seccion
    label_seccion_cargas.config(textvariable=variable_seccion)
    
    # Crear un ComboBox con los valores de resistencia a la compresión
    valores_resistencia = [
    "17.5 Mpa", "21 Mpa", "24.5 Mpa", "28 Mpa", "35 Mpa", "42 Mpa"
    ]
    combo_resistencia = ttk.Combobox(frame_pest_seccion, values=valores_resistencia, state="readonly")
    combo_resistencia.place(x=240,y=220,width=80)
    
    frame_pest_resumen = tk.Frame(pestaña_resumen,bd=2,relief="flat",bg="white")
    frame_pest_resumen.pack(fill="both",expand=True)
    
    labelframe_resumen = tk.LabelFrame(frame_pest_resumen,bg="white")
    labelframe_resumen.place(x=10,y=10,width=370,height=250)
    label_resumen = tk.Label(labelframe_resumen, 
                        text="A continuación se presenta un resumen de las configuraciones utilizadas para definir la sección transversal de la viga.",
                        justify="left", 
                        anchor="w",
                        wraplength=350,
                        bg="white")
    label_resumen.place(x=10,y=10)
    
    label_resumen_nombre = tk.Label(labelframe_resumen,text="Nombre [VG]:",bg="white")
    label_resumen_nombre.place(x=10,y=60) 
    label_resumen_1 = tk.Label(labelframe_resumen,text="",bg="white")
    label_resumen_1.place(x=90,y=60)
    
    label_resumen_luz = tk.Label(labelframe_resumen,text="Longitud [L]:",bg="white")
    label_resumen_luz.place(x=10,y=90)
    label_resumen_2 = tk.Label(labelframe_resumen,text="",bg="white")
    label_resumen_2.place(x=85,y=90)
    
    label_resumen_base = tk.Label(labelframe_resumen,text="Base [b]:",bg="white")
    label_resumen_base.place(x=10,y=120)
    label_resumen_3 = tk.Label(labelframe_resumen,text="",bg="white")
    label_resumen_3.place(x=65,y=120)
    
    label_resumen_altura = tk.Label(labelframe_resumen,text="Altura [h]:",bg="white")
    label_resumen_altura.place(x=10,y=150)
    label_resumen_4 = tk.Label(labelframe_resumen,text="",bg="white")
    label_resumen_4.place(x=70,y=150)
    
    
    label_resumen_recubrimiento = tk.Label(labelframe_resumen,text="Recubrimiento [r]:",bg="white")
    label_resumen_recubrimiento.place(x=10,y=180)
    label_resumen_5 = tk.Label(labelframe_resumen,text="",bg="white")
    label_resumen_5.place(x=115,y=180)
    
    
    label_resumen_d = tk.Label(labelframe_resumen,text="Altura efectiva [d]:",bg="white")
    label_resumen_d.place(x=10,y=210)
    label_resumen_6 = tk.Label(labelframe_resumen,text="",bg="white")
    label_resumen_6.place(x=115,y=210)
    
    
    def actualizar_label(*args):
    # Obtener el valor del Entry
        valor_1 = entry_luz_seccion.get()
    # Actualizar el Label con el texto fijo + el valor ingresado
        label_resumen_2.config(text=f"La viga presenta una luz de {valor_1} metros.")
        
    
    def actualizar_label_base(*args):
    # Obtener el valor del Entry y actualizar el Label
        valor_2 = entry_base_seccion.get() 
        label_resumen_3.config(text=f"La viga presenta una base de {valor_2} metros.")
    
        
        
    # Función para actualizar d_seccion en tiempo real
    def actualizar_d_seccion(*args):
        try:
            altura = float(var_altura.get())  
        except ValueError:
            altura = 0  
        
        try:
            recubrimiento = float(var_recubrimiento.get())  
        except ValueError:
            recubrimiento = 0  
        
        # Realizar la resta
        d_seccion = altura - recubrimiento
        
        # Mostrar el resultado en el campo entry_d_seccion
        entry_d_seccion.delete(0, tk.END)  
        entry_d_seccion.insert(0, str(d_seccion))  
        
        # Actualizar el texto del label_resumen_5 con el valor de d_seccion
        label_resumen_5.config(text=f"El recubrimiento a emplear será de {recubrimiento * 100:.1f} cm")  
        # Actualizar el texto del label_resumen_6 con el valor de d_seccion desde entry_d_seccion
        label_resumen_6.config(text=f"La altura efectiva a utilizar es de {d_seccion:.2f} metros") 
        
    
    def actualizar_nombre_seccion(*args):
    # Recuperamos los valores de los Entry
        base_nombre = entry_base_seccion.get()
        altura_nombre = entry_altura_seccion.get()
    
        try:
    # Convertimos los valores a números flotantes y los multiplicamos por 100
            base_nombre = round(float(base_nombre) * 100, 2)  
            altura_nombre = round(float(altura_nombre) * 100, 2)  
        
    # Formateamos la cadena con los valores modificados
            nombre_seccion = f"VG {base_nombre} X {altura_nombre}"
        
    # Actualizamos el campo entry_nombre_seccion
            entry_nombre_seccion.delete(0, tk.END)  
            entry_nombre_seccion.insert(0, nombre_seccion)  
            
            # Actualizamos el texto del label_resumen_1
            label_resumen_1.config(text=f"Elemento viga,sección - {nombre_seccion}")
            # Actualizamos el texto del label_resumen_4 con la altura
            altura_metros = round(altura_nombre * 0.01, 2)  
            label_resumen_4.config(text=f"La viga presenta una altura de {altura_metros} metros") 
            
        except ValueError:
    # Si los valores no son numéricos, no hacemos nada
            pass
    
    # Función para dibujar el rectángulo en el canvas
    def dibujar_rectangulo():
        try:
            base = float(var_base.get())  
            altura = float(var_altura.get())  
        except ValueError:
            base = 0
            altura = 0
        
        # Definir un factor de escala para que los valores en metros se ajusten al canvas
        factor_escala_base = 120  
        factor_escala_altura = 142  
        
        # Escalar las dimensiones del rectángulo en píxeles
        base_pixel = base * factor_escala_base  
        altura_pixel = altura * factor_escala_altura  
        
        # Limpiar el canvas antes de dibujar
        canvas_seccion.delete("all")
        
        # Calcular el margen para centrar el rectángulo
        canvas_width = 120  # Ancho del Canvas
        canvas_height = 142  # Altura del Canvas
        x_offset = (canvas_width - base_pixel) / 2 - 5  
        y_offset = (canvas_height - altura_pixel) / 2  
        
        # Dibujar el rectángulo en el canvas
        canvas_seccion.create_rectangle(
            x_offset, y_offset, x_offset + base_pixel, y_offset + altura_pixel,
            outline="black", fill="medium blue", width=1
        )
        # Calcular el valor escalado de base y altura (multiplicados por 100)
        base_multiplicada = base * 100
        altura_multiplicada = altura * 100
        
        # Agregar el título centrado arriba del rectángulo
        texto_titulo = f"VG {base_multiplicada:.0f} X {altura_multiplicada:.0f}"  
        canvas_seccion.create_text(
        (canvas_width / 2)-6, y_offset - 20,  
        text=texto_titulo,  
        font=("Arial", 8, "bold"),  
        fill="black" 
        )   
        # Agregar las cotas a la base (en la parte inferior central del rectángulo)
        canvas_seccion.create_text(
        x_offset + base_pixel / 2, y_offset + altura_pixel + 10,  
        text=f"{base:.2f} m",  
        font=("Arial", 8,"bold"),  
        fill="black"  
        )
        
        # Agregar las cotas a la altura (en la parte izquierda central del rectángulo)
        canvas_seccion.create_text(
        x_offset -8, y_offset + altura_pixel / 2,  
        text=f"{altura:.2f} m", 
        font=("Arial", 8,"bold"),  
        fill="black",  
        angle=90  
        )
    
    
    # Crear los StringVar para monitorizar cambios en los Entry
    var_base = tk.StringVar()
    var_altura = tk.StringVar()
    var_recubrimiento = tk.StringVar()
    
    
    entry_luz_seccion = tk.Entry(labelframe_dimensiones,bd=2, relief="ridge")
    entry_luz_seccion.place(x=50,y=10,width=50)
    entry_base_seccion = tk.Entry(labelframe_dimensiones,bd=2, relief="ridge")
    entry_base_seccion.place(x=50,y=40,width=50)
    entry_base_seccion.config(textvariable=var_base)
    entry_altura_seccion = tk.Entry(labelframe_dimensiones,bd=2, relief="ridge")
    entry_altura_seccion.place(x=50,y=70,width=50)
    entry_altura_seccion.config(textvariable=var_altura)
    entry_recubrimiento_seccion = tk.Entry(labelframe_dimensiones,bd=2, relief="ridge")
    entry_recubrimiento_seccion.place(x=50,y=100,width=50)
    entry_recubrimiento_seccion.config(textvariable=var_recubrimiento)
    entry_d_seccion = tk.Entry(labelframe_dimensiones,bd=2,relief="ridge")
    entry_d_seccion.place(x=50,y=130,width=50)
    frame_dibujo_seccion = tk.Frame(labelframe_dimensiones,bd=4,relief="ridge")
    frame_dibujo_seccion.place(x=170,y=10,width=120,height=142)
    # Crear el Canvas dentro del frame_dibujo_seccion
    canvas_seccion = tk.Canvas(frame_dibujo_seccion, bg="lightgrey", width=120, height=142)
    canvas_seccion.pack(fill="both", expand=True)
    
    #Crear el boton aceptar para guardar datos
    boton_aceptar_seccion= tk.Button(ventana_secundaria,text="Aceptar",command=guardar_datos_seccion)
    boton_aceptar_seccion.place(x=100,y=490,width=100)
    
    # Cargar los datos guardados al abrir la ventana
    cargar_datos_seccion()
    
    
    #Crar el boton aplicar para mostrar grafico dinamico
    boton_aplicar_seccion= tk.Button(ventana_secundaria,text="Aplicar",command=update_plot)
    boton_aplicar_seccion.place(x=280,y=490,width=100)
    
    
    # Agregar el trace a las variables para actualizar en tiempo real
    var_base.trace("w", lambda *args: dibujar_rectangulo())
    var_altura.trace("w", lambda *args: dibujar_rectangulo())
    
    
    # Agregar el trace a las variables para actualizar en tiempo real
    var_altura.trace("w", actualizar_d_seccion)
    var_recubrimiento.trace("w", actualizar_d_seccion)
    
    # Asociar el cambio de valor de los Entry a la función de actualización
    entry_base_seccion.bind("<KeyRelease>", actualizar_nombre_seccion)
    entry_altura_seccion.bind("<KeyRelease>", actualizar_nombre_seccion)
    
    # Configurar un evento que se active cada vez que el valor del Entry cambie
    entry_luz_seccion.bind("<KeyRelease>", actualizar_label)  
    
    # Configurar un evento que se active cada vez que el valor del Entry cambie
    entry_base_seccion.bind("<KeyRelease>", actualizar_label_base)
    
    # Marcar la ventana como abierta
    ventana_secundaria_abierta = True
    
    
    # Configurar para que cuando se cierre la ventana, se pueda volver a abrir
    ventana_secundaria.protocol("WM_DELETE_WINDOW", lambda: cerrar_ventana(ventana_secundaria))
    
    def cerrar_ventana(ventana_secundaria):
        global ventana_secundaria_abierta
        ventana_secundaria.destroy()
        ventana_secundaria_abierta = False

# Variables globales
ventana_apoyos_abierta = False
ventana_apoyos = None
labelframe_apoyos = None  # Definir globalmente
combo_tipo_apoyo = None  # Declarar globalmente para acceso en ambas funciones
label_restriccion_apoyo = None  # Declarar el label globalmente para actualizarlo

# Función para cerrar la ventana de apoyos y actualizar la variable
def cerrar_ventana_apoyos():
    global ventana_apoyos_abierta, ventana_apoyos
    ventana_apoyos_abierta = False
    if ventana_apoyos:
        ventana_apoyos.destroy()  # Cierra la ventana
        ventana_apoyos = None  # Elimina la referencia

# Función para actualizar los RadioButtons en función del tipo de apoyo seleccionado
def actualizar_radio_buttons(event):
    global labelframe_apoyos, combo_tipo_apoyo  # Acceder a las variables globales
    
    # Limpiar los RadioButtons previos
    for widget in labelframe_apoyos.winfo_children():
        widget.destroy()
    
    tipo_apoyo = combo_tipo_apoyo.get()  # Obtener el valor seleccionado en el ComboBox
    
    # Actualizar el texto del label con el tipo de apoyo seleccionado
    label_restriccion_apoyo.config(text=f"{tipo_apoyo}")
    
    if tipo_apoyo == "Apoyo móvil":
        # Mostrar los RadioButtons para el apoyo móvil
        radio_desplazamiento_y = tk.Radiobutton(labelframe_apoyos, text="No permite desplazamiento vertical")
        radio_desplazamiento_y.grid(row=0, column=0, sticky="w", padx=10, pady=5)
        
        radio_rotacion = tk.Radiobutton(labelframe_apoyos, text="No permite rotación")
        radio_rotacion.grid(row=1, column=0, sticky="w", padx=10, pady=5)
        
        radio_resistencia_y = tk.Radiobutton(labelframe_apoyos, text="Sí permite movimiento horizontal")
        radio_resistencia_y.grid(row=2, column=0, sticky="w", padx=10, pady=5)
    
    elif tipo_apoyo == "Apoyo empotrado":
        # Mostrar los RadioButtons para el apoyo empotrado
        radio_no_desplazamiento = tk.Radiobutton(labelframe_apoyos, text="No permite desplazamiento en ninguna dirección")
        radio_no_desplazamiento.grid(row=0, column=0, sticky="w", padx=10, pady=5)
        
        radio_resistencia_vertical = tk.Radiobutton(labelframe_apoyos, text="Resistencia a fuerzas verticales")
        radio_resistencia_vertical.grid(row=1, column=0, sticky="w", padx=10, pady=5)
        
        radio_resistencia_horizontal = tk.Radiobutton(labelframe_apoyos, text="Resistencia a fuerzas horizontales")
        radio_resistencia_horizontal.grid(row=2, column=0, sticky="w", padx=10, pady=5)
        
        radio_resistencia_momentos = tk.Radiobutton(labelframe_apoyos, text="Resistencia a momentos")
        radio_resistencia_momentos.grid(row=3, column=0, sticky="w", padx=10, pady=5)


# Función para abrir la ventana de apoyos
def abrir_ventana_apoyos():
    global ventana_apoyos_abierta, ventana_apoyos, labelframe_apoyos, combo_tipo_apoyo,label_restriccion_apoyo
    
    # Si la ventana ya está abierta, no hacemos nada
    if ventana_apoyos_abierta:
        return
    
    # Crear la ventana secundaria
    ventana_apoyos = tk.Toplevel()
    ventana_apoyos.title("Definir apoyos")
    
    # Evitar que la ventana sea maximizada o redimensionada
    ventana_apoyos.resizable(False, False)
    
    # Mantener la ventana siempre encima
    ventana_apoyos.attributes('-topmost', True)
    
    # Definir el tamaño de la ventana
    ventana_apoyos.geometry("500x255")
    
    # Actualizar el estado de la ventana
    ventana_apoyos_abierta = True
    
    # Crear contenido en la venta_apoyos
    label_tipo_apoyo =tk.Label(ventana_apoyos,text="Tipo de apoyo:")
    label_tipo_apoyo.place(x=80,y=20)
    labelframe_apoyos = tk.LabelFrame(ventana_apoyos,text="Restricciones de apoyo")
    labelframe_apoyos.place(x=20,y=50,width=465,height=160)
    
    
    #Crear combobox para tipo de apoyo
    # Lista de opciones para el ComboBox
    tipos_de_apoyo = ["Apoyo móvil", "Apoyo empotrado"]
    combo_tipo_apoyo = ttk.Combobox(ventana_apoyos, values=tipos_de_apoyo, state="readonly")
    combo_tipo_apoyo.place(x=200,y=20)
    combo_tipo_apoyo.set("Seleccionar")
    
    # Asignar el manejador de cambio de selección en el ComboBox
    combo_tipo_apoyo.bind("<<ComboboxSelected>>", actualizar_radio_buttons)
    
    # Agregar botón "Aceptar" que cierra la ventana
    boton_aceptar_apoyo = tk.Button(ventana_apoyos, text="Aceptar", command=cerrar_ventana_apoyos)
    boton_aceptar_apoyo.place(x=200, y=220, width=100)  
    
    # Asignar el manejador de cierre de la ventana
    ventana_apoyos.protocol("WM_DELETE_WINDOW", cerrar_ventana_apoyos)


label_restriccion_apoyo = None
entry_base_cargas = None
entry_altura_cargas = None
ventana_cargas_abierta = None
combo_seccion_analisis = None
entry_Wpp_cargas = None

import tkinter as tk

def calcular_Wpp(*args):
    try:
        # Obteniendo los valores de las entradas y convirtiéndolos a flotantes
        base_wpp = float(entry_base_cargas.get())
        altura_wpp = float(entry_altura_cargas.get())
        
        # Calculando Wpp
        Wpp_1 = base_wpp * altura_wpp * 24.00
        
        # Mostrando el resultado en el entry_Wpp_cargas
        entry_Wpp_cargas.delete(0, tk.END)
        entry_Wpp_cargas.insert(0, f"{Wpp_1:.2f}")  # Formato con dos decimales
    except ValueError:
        # Si hay un error en la conversión, limpiar el entry_Wpp_cargas
        entry_Wpp_cargas.delete(0, tk.END)

def calcular_Wtotal(*args):
    try:
        # Obtener los valores de los Entry
        WD = float(entry_WD_cargas.get() or 0)  # Si está vacío, se toma como 0
        WL = float(entry_WL_cargas.get() or 0)  # Si está vacío, se toma como 0
        Wpp = float(entry_Wpp_cargas.get() or 0)  # Este ya es calculado internamente
        
        # Calcular Wtotal
        Wtotal = WD + WL + Wpp
        
        # Mostrar el resultado en el entry_Wtotal_cargas
        entry_Wtotal_cargas.delete(0, tk.END)
        entry_Wtotal_cargas.insert(0, f"{Wtotal:.2f}")  # Formato con dos decimales
        
        # Calcular Wu después de Wtotal
        calcular_Wu()
    except ValueError:
        # Si hay un error en la conversión, limpiar el entry_Wtotal_cargas
        entry_Wtotal_cargas.delete(0, tk.END)

# Dentro de la función calcular_Wu, asegúrate de que Wu_var se actualice correctamente
def calcular_Wu(*args):
    try:
        # Obtener los valores de los Entry
        WD = float(entry_WD_cargas.get() or 0)  # Si está vacío, se toma como 0
        WL = float(entry_WL_cargas.get() or 0)  # Si está vacío, se toma como 0
        Wpp = float(entry_Wpp_cargas.get() or 0)  # Este ya es calculado internamente

        # Calcular Wu
        Wu_carga = 1.2 * (WD + Wpp) + 1.6 * WL

        # Mostrar el resultado en el entry_Wu_cargas
        entry_Wu_cargas.delete(0, tk.END)
        entry_Wu_cargas.insert(0, f"{Wu_carga:.2f}")  # Formato con dos decimales
        
        # Actualizar Wu_var con el nuevo valor calculado
        Wu_var.set(f"{Wu_carga:.2f}")  # Esto actualiza la variable vinculada

    except ValueError:
        # Si hay un error en la conversión, limpiar el entry_Wu_cargas
        entry_Wu_cargas.delete(0, tk.END)
        Wu_var.set("0")  # Opcional: Resetear Wu_var si hay un error

def actualizar_entries(event):
    # Obtener la opción seleccionada en el ComboBox
    seleccion_1 = combo_seccion_analisis.get()
    
    try:
        # Separar la cadena seleccionada
        partes = seleccion_1.replace("VG", "").replace("X", "").split()
        
        # Convertir los valores a flotantes y dividir entre 100
        base_valor = float(partes[0]) / 100
        altura_valor = float(partes[1]) / 100

        # Actualizar los valores en los Entry
        entry_base_cargas.delete(0, tk.END)
        entry_base_cargas.insert(0, f"{base_valor:.2f}") 
        
        entry_altura_cargas.delete(0, tk.END)
        entry_altura_cargas.insert(0, f"{altura_valor:.2f}")  
        
        # Recalcular Wpp
        calcular_Wpp()
    except (ValueError, IndexError):
        print("Error: El formato de la opción seleccionada no es correcto.")


def actualizar_combo_seccion(combo_seccion_analisis):
    # Obtener el valor de label_seccion_cargas
    valor_seccion = label_seccion_cargas.cget("text")
    
    # Si el valor no está vacío, actualizar el ComboBox con ese valor
    if valor_seccion:
        combo_seccion_analisis['values'] = ("Seleccionar", valor_seccion)
    else:
        # Si el valor está vacío, solo mostrar la opción "Seleccionar"
        combo_seccion_analisis['values'] = ("Seleccionar",)

def dibujar_viga_apoyada_1(canvas_viga_analisis,valor_carga,valor_Wu):
    # Obtener el tamaño del canvas
    ancho_canvas = canvas_viga_analisis.winfo_width()
    alto_canvas = canvas_viga_analisis.winfo_height()

    # Calcular la posición central para la viga
    x_inicio = ancho_canvas // 4
    x_fin = 3 * ancho_canvas // 4
    y_viga = alto_canvas // 2

    # Dibujar la viga (línea horizontal) centrada en el canvas
    canvas_viga_analisis.create_line(x_inicio, y_viga, x_fin, y_viga, width=3, fill="black")
    
    # Dibujar los triángulos debajo de la línea, con la punta hacia abajo
    # Triángulo izquierdo
    canvas_viga_analisis.create_polygon(x_inicio, y_viga, x_inicio - 10, y_viga + 20, x_inicio + 10, y_viga + 20, fill="blue", outline="black")
    
    # Triángulo derecho
    canvas_viga_analisis.create_polygon(x_fin, y_viga, x_fin - 10, y_viga + 20, x_fin + 10, y_viga + 20, fill="blue", outline="black")
    
    # Obtener el valor de carga desde el Entry
    valor_carga_texto = valor_carga if valor_carga else "0"
    
    # Dibujar la cota (dimensión de la viga) con flechas en ambos extremos
    canvas_viga_analisis.create_line(x_inicio, y_viga + 30, x_fin, y_viga + 30, width=1, fill="red")  # Línea de la cota (más fina)
    canvas_viga_analisis.create_text((x_inicio + x_fin) / 2, y_viga + 40, text=f"Longitud: {valor_carga_texto} m ", font=("Arial", 10, "bold"), fill="red")  # Longitud de la viga
    
    
    # Dibujar las flechas en ambos extremos de la línea de cota (más pequeñas)
    canvas_viga_analisis.create_polygon(x_inicio - 3, y_viga + 30, x_inicio + 3, y_viga + 25, x_inicio + 3, y_viga + 35, fill="red", outline="red")
    canvas_viga_analisis.create_polygon(x_fin + 3, y_viga + 30, x_fin - 3, y_viga + 25, x_fin - 3, y_viga + 35, fill="red", outline="red")

    # Dibujar la línea verde horizontal justo encima de las líneas de carga distribuida
    canvas_viga_analisis.create_line(x_inicio, y_viga - 20, x_fin, y_viga - 20, width=2, fill="green")  # Línea verde horizontal
    
    # Dibujar la carga distribuida a lo largo de la viga (líneas cortas con flechas hacia abajo)
    num_lineas = 20  # Número de segmentos para la carga distribuida
    carga_espaciado = (x_fin - x_inicio) / (num_lineas - 1)  # Espaciado entre las líneas de carga

    for i in range(num_lineas):
        x_pos = x_inicio + i * carga_espaciado
        # Dibujar línea de carga distribuida
        canvas_viga_analisis.create_line(x_pos, y_viga - 10, x_pos, y_viga - 20, width=2, fill="green")  # Línea de carga distribuida
        
        # Dibujar la flecha apuntando hacia abajo (ubicada justo debajo de la línea verde)
        canvas_viga_analisis.create_polygon(x_pos - 3, y_viga - 10, x_pos + 3, y_viga - 10, x_pos, y_viga, fill="green", outline="green")
    
    # Eliminar el texto anterior (si existe) para actualizar la carga distribuida
    canvas_viga_analisis.delete("carga_Wu_texto")  # Borrar el texto viejo
    
    # Agregar texto a la carga distribuida
    canvas_viga_analisis.create_text((x_inicio + x_fin) / 2, y_viga - 40, text=f"Carga Wu: {valor_Wu} kN/m", font=("Arial", 10, "bold"), fill="green")


def dibujar_viga_empotrada_1(canvas_viga_analisis,valor_carga,valor_Wu):
    # Obtener el tamaño del canvas
    ancho_canvas = canvas_viga_analisis.winfo_width()
    alto_canvas = canvas_viga_analisis.winfo_height()

    # Calcular la posición central para la viga
    x_inicio = ancho_canvas // 4
    x_fin = 3 * ancho_canvas // 4
    y_viga = alto_canvas // 2

    # Dibujar la viga (línea horizontal) centrada en el canvas
    canvas_viga_analisis.create_line(x_inicio, y_viga, x_fin, y_viga, width=3, fill="black")
    
    # Dibujar las líneas verticales en los extremos (empotradas)
    canvas_viga_analisis.create_line(x_inicio, y_viga - 20, x_inicio, y_viga + 20, width=3, fill="blue")
    canvas_viga_analisis.create_line(x_fin, y_viga - 20, x_fin, y_viga + 20, width=3, fill="blue")
    
    # Obtener el valor de carga desde el Entry
    valor_carga_texto = valor_carga if valor_carga else "0"
    
    # Dibujar la cota (dimensión de la viga) con flechas en ambos extremos
    canvas_viga_analisis.create_line(x_inicio, y_viga + 30, x_fin, y_viga + 30, width=1, fill="red")  # Línea de la cota (más fina)
    canvas_viga_analisis.create_text((x_inicio + x_fin) / 2, y_viga + 40, text=f"Longitud: {valor_carga_texto} m ", font=("Arial", 10, "bold"), fill="red")  # Longitud de la viga
    
    # Dibujar las flechas en ambos extremos de la línea de cota (más pequeñas)
    canvas_viga_analisis.create_polygon(x_inicio - 3, y_viga + 30, x_inicio + 3, y_viga + 25, x_inicio + 3, y_viga + 35, fill="red", outline="red")
    canvas_viga_analisis.create_polygon(x_fin + 3, y_viga + 30, x_fin - 3, y_viga + 25, x_fin - 3, y_viga + 35, fill="red", outline="red")

    # Dibujar la carga distribuida a lo largo de la viga (líneas cortas con flechas hacia abajo)
    num_lineas = 20  # Número de segmentos para la carga distribuida
    carga_espaciado = (x_fin - x_inicio) / (num_lineas - 1)  # Espaciado entre las líneas de carga

    for i in range(1, num_lineas - 1):  # Excluir la primera y la última línea
        x_pos = x_inicio + i * carga_espaciado
        # Dibujar línea de carga distribuida
        canvas_viga_analisis.create_line(x_pos, y_viga - 10, x_pos, y_viga - 20, width=2, fill="green")  # Línea de carga distribuida
        
        # Dibujar la flecha apuntando hacia abajo (ubicada justo debajo de la línea verde)
        canvas_viga_analisis.create_polygon(x_pos - 3, y_viga - 10, x_pos + 3, y_viga - 10, x_pos, y_viga, fill="green", outline="green")

    # Dibujar la línea verde horizontal justo encima de las líneas de carga distribuida
    canvas_viga_analisis.create_line(x_inicio + carga_espaciado, y_viga - 20, x_fin - carga_espaciado, y_viga - 20, width=2, fill="green")
    
    # Eliminar el texto anterior (si existe) para actualizar la carga distribuida
    canvas_viga_analisis.delete("carga_Wu_texto")  # Borrar el texto viejo
    
    # Agregar texto a la carga distribuida
    canvas_viga_analisis.create_text((x_inicio + x_fin) / 2, y_viga - 40, text=f"Carga Wu: {valor_Wu} kN/m", font=("Arial", 10, "bold"), fill="green")


def actualizar_diagrama_viga(event, combo_viga_cargas, canvas_viga_analisis, entry_luz_cargas, Wu_var, label_tipo_viga_cargas):
    # Obtener el valor ingresado en el Entry
    valor_carga = entry_luz_cargas.get()
    
    # Obtener el valor calculado de la carga distribuida desde Wu_var (la variable vinculada al entry)
    valor_Wu = Wu_var.get()  # Este es el valor calculado de Wu
    
    # Verificar la opción seleccionada en el ComboBox
    seleccion_1 = combo_viga_cargas.get()
    
    # Actualizar el texto del label con el tipo de viga seleccionado
    label_tipo_viga_cargas.config(text=seleccion_1)  
    
    # Limpiar el canvas antes de dibujar un nuevo diagrama
    canvas_viga_analisis.delete("all")
    
    if seleccion_1 == "Viga apoyada":
        dibujar_viga_apoyada_1(canvas_viga_analisis, valor_carga,valor_Wu)
    elif seleccion_1 == "Viga empotrada":
        dibujar_viga_empotrada_1(canvas_viga_analisis, valor_carga,valor_Wu)

# Inicializar Wu_var globalmente para que no se cree nuevamente al abrir la ventana
Wu_var = tk.StringVar()



def aplicar_cargas():
    global label_tipo_viga_cargas, entry_Wu_cargas, entry_luz_cargas, entry_WD_cargas, entry_WL_cargas, label_titulo_viga, label_titulo_cargas, combo_seccion_analisis
    global label_texto_cargas
    # Verificar que los elementos existan antes de usarlos
    if label_tipo_viga_cargas is None or entry_Wu_cargas is None or entry_luz_cargas is None or entry_WD_cargas is None or entry_WL_cargas is None:
        return

    # Obtener el tipo de viga desde el label
    tipo_viga = label_tipo_viga_cargas.cget("text")  # Obtener el texto del label
    if not tipo_viga:  # Si el texto está vacío, no hacer nada
        return
    
    # Obtener la sección seleccionada del combobox
    seccion_viga = combo_seccion_analisis.get()
    if not seccion_viga:  # Si no se selecciona una sección, no hacer nada
        return
    
    def animar_texto():
        
    # Obtiene el texto actual
        texto = label_texto_cargas.cget("text")

    # Obtiene el tamaño de la ventana y la posición actual del texto
        x_actual = label_texto_cargas.winfo_x()

    # Definir el límite del movimiento (puedes cambiar estos valores)
        limite_derecha = 380  
        limite_izquierda = -len(texto) * 7  
    
    # Mover el texto
        if x_actual < limite_derecha:
            label_texto_cargas.place(x=x_actual + 1, y=3)
            label_texto_cargas.after(50, animar_texto) 
        else:
    # Si llega al final, vuelve a la posición inicial
            label_texto_cargas.place(x=limite_izquierda, y=3)
            label_texto_cargas.after(50, animar_texto)
    
    # Iniciar la animación
    animar_texto()
    
    try:
        # Longitud de la viga en unidades
        longitud = 6 * 100  # Longitud fija de 6 metros (600 unidades)

        # Obtener Wu como flotante
        try:
            carga_distribuida = float(entry_Wu_cargas.get())
        except ValueError:
            carga_distribuida = 0  # Si no es válido, usar 0 como carga

        # Obtener el valor de la luz de la viga desde entry_luz_cargas
        try:
            luz_viga = float(entry_luz_cargas.get())
        except ValueError:
            luz_viga = 0  # Si no es válido, usar 0 como valor de luz
        
        # Obtener los valores de WD y WL
        try:
            WD = float(entry_WD_cargas.get())
        except ValueError:
            WD = 0  # Si no es válido, usar 0 como valor de WD
        
        try:
            WL = float(entry_WL_cargas.get())
        except ValueError:
            WL = 0  # Si no es válido, usar 0 como valor de WL
        
        
        # Inicializar momento_A y momento_B como 0 por defecto
        momento_A = 0
        momento_B = 0


        # Calcular las reacciones
        if tipo_viga == "Viga apoyada":
            # Reacciones en los apoyos para viga apoyada
            reaccion_apoyo = carga_distribuida * luz_viga / 2  # R = (Wu * L) / 2
            texto_reacciones = [f"Ray = {reaccion_apoyo:.2f} kN", f"Rby = {reaccion_apoyo:.2f} kN"]
            # Actualizar el título de la viga
            label_titulo_viga.config(text="Análisis de Viga apoyada")
        elif tipo_viga == "Viga empotrada":
            # Reacciones en los apoyos para viga empotrada
            reaccion_apoyo = carga_distribuida * luz_viga / 2  # Similar a viga apoyada para este ejemplo
            texto_reacciones = [f"Ray = {reaccion_apoyo:.2f} kN", f"Rby = {reaccion_apoyo:.2f} kN"]
            # Reacciones de momentos en los apoyos para viga empotrada
            momento_A = carga_distribuida * luz_viga**2 / 12  # MA = Wu * L^2 / 12
            momento_B = -carga_distribuida * luz_viga**2 / 12  # MB = -Wu * L^2 / 12
            texto_reacciones = [f"Ray = {reaccion_apoyo:.2f} kN", f"Rby = {reaccion_apoyo:.2f} kN"]
            texto_momentos = [f"MA = {momento_A:.2f} kN·m", f"MB = {momento_B:.2f} kN·m"]
            # Actualizar el título de la viga      
            label_titulo_viga.config(text="Análisis de Viga empotrada")
        else:
            texto_reacciones = ["Reacciones no calculadas"]
        
        # Aquí es donde actualizamos el texto de `label_texto_cargas`
        mensaje_analisis = f"!Muy bien! El análisis de la viga con sección {seccion_viga} es correcto."
        label_texto_cargas.config(text=mensaje_analisis)  # Actualizar el texto del label_texto_cargas

        # Crear figura y eje para el dibujo
        fig = Figure(figsize=(6, 4), dpi=100)
        ax = fig.add_subplot(111)

        # Configuración general
        desplazamiento_x = 10
        eje_y_central = 0
        altura_triangulo = 40
        altura_carga = 60

        # Dibujar la viga
        ax.plot([desplazamiento_x, longitud + desplazamiento_x],
                [eje_y_central, eje_y_central],
                color='black', linewidth=3, label="Viga")

        # Dibujar apoyos según el tipo de viga
        if tipo_viga == "Viga apoyada":
            # Apoyo inicial (rellenar triángulo con color azul y borde negro)
            ax.fill([desplazamiento_x - 20, desplazamiento_x, desplazamiento_x + 20],
                    [eje_y_central - altura_triangulo, eje_y_central, eje_y_central - altura_triangulo],
                    color='blue', edgecolor='black', linewidth=2)  # Contorno negro

            # Apoyo final (rellenar triángulo con color azul y borde negro)
            ax.fill([longitud + desplazamiento_x - 20, longitud + desplazamiento_x, longitud + desplazamiento_x + 20],
                    [eje_y_central - altura_triangulo, eje_y_central, eje_y_central - altura_triangulo],
                    color='blue', edgecolor='black', linewidth=2)  # Contorno negro

        if tipo_viga == "Viga empotrada":
            # Empotramiento inicial (línea vertical)
            ax.plot([desplazamiento_x, desplazamiento_x],
                    [eje_y_central - 50, eje_y_central + 50],
                    color='black', linewidth=3)
            # Empotramiento final (línea vertical)
            ax.plot([longitud + desplazamiento_x, longitud + desplazamiento_x],
                    [eje_y_central - 50, eje_y_central + 50],
                    color='black', linewidth=3)

        # Dibujar la carga distribuida si Wu > 0
        if carga_distribuida > 0:
            x_inicio = desplazamiento_x
            x_fin = longitud + desplazamiento_x
            num_flechas = 10
            espacio_flechas = (x_fin - x_inicio) / num_flechas

            # Dibujar fondo de la carga
            ax.fill_between([x_inicio, x_fin],
                            eje_y_central + altura_carga + 5,
                            eje_y_central,
                            color='lime', alpha=0.5)

            # Dibujar flechas de la carga
            for i in range(num_flechas + 1):
                x_pos = x_inicio + i * espacio_flechas
                ax.arrow(x_pos, eje_y_central + altura_carga, 0, -40,
                         head_width=10, head_length=15, fc='blue', ec='blue')

            # Dibujar línea superior de la carga
            ax.plot([x_inicio, x_fin],
                    [eje_y_central + altura_carga, eje_y_central + altura_carga],
                    color='blue', linewidth=2, label=f"Wu={carga_distribuida}")
            
            # Agregar el texto de la carga distribuida en el gráfico
            texto_carga = f"Wu = {carga_distribuida} kN/m"
            ax.text(longitud / 2 + desplazamiento_x, eje_y_central + altura_carga + 30,
                    texto_carga, ha='center', va='center', fontsize=8, color='blue')

        # Mostrar el texto de la cota debajo de la viga
        texto_cota = f"Luz = {luz_viga} m"
        ax.text(longitud / 2 + desplazamiento_x, eje_y_central - 40,
                texto_cota, ha='center', va='center', fontsize=8, color='black')
        
        # Crear marcadores personalizados para la leyenda
        handles_reacciones = [
            Line2D([0], [0], linestyle='None', color='none', label="Reacciones:"),  # Subtítulo como línea vacía
            Line2D([0], [0], marker='^', color='black', markerfacecolor='blue', linestyle='None', markersize=8),
            Line2D([0], [0], marker='^', color='black', markerfacecolor='blue', linestyle='None', markersize=8)
        ]
        handles_reacciones_M = [
            Line2D([0], [0], linestyle='None', color='none', label="Reacciones:"),  # Subtítulo como línea vacía
            Line2D([0], [0], marker='^', color='black', markerfacecolor='black', linestyle='None', markersize=8),
            Line2D([0], [0], marker='^', color='black', markerfacecolor='black', linestyle='None', markersize=8)
        ]
        handles_momentos = [
            Line2D([0], [0], linestyle='None', color='none', label="Momentos:"),  # Subtítulo como línea vacía
            Line2D([0], [0], marker='o', color='black', markerfacecolor='red', linestyle='None', markersize=8),
            Line2D([0], [0], marker='o', color='black', markerfacecolor='red', linestyle='None', markersize=8)
        ]
        
        # Crear leyendas para las cargas WD y WL
        handles_WD = [
            Line2D([0], [0], linestyle='None', color='none', label="Carga muerta:"),
            Line2D([0], [0], marker='s', color='black', markerfacecolor='lime', linestyle='None', markersize=8)
        ]
        handles_WL = [
            Line2D([0], [0], linestyle='None', color='none', label="Carga viva:"),
            Line2D([0], [0], marker='s', color='black', markerfacecolor='lime', linestyle='None', markersize=8)
        ]
        
        # Leyendas para la viga apoyada
        if tipo_viga == "Viga apoyada":
            ax.legend(
                handles=handles_reacciones,
                labels=["Reacciones:",  # Subtítulo
                    f"Ray = {reaccion_apoyo:.2f} kN",  # Reacción en A
                    f"Rby = {reaccion_apoyo:.2f} kN"],  # Reacción en B
                loc='upper left',
                bbox_to_anchor=(0.5, 1.8),
                fontsize=8,
                frameon=True,
                edgecolor='black',
                facecolor='lightgray'
            )
            fig.legend(
                handles=handles_WD + handles_WL,
                labels=["Carga muerta:",  # Subtítulo
                    f"WD = {WD:.2f} kN/m",  # WD
                    "Carga viva:",         # Subtítulo
                    f"WL = {WL:.2f} kN/m"],  # WL
                loc='upper left',
                bbox_to_anchor=(0.1, 0.98),  # Ajusta la posición
                fontsize=8,
                frameon=True,
                edgecolor='black',
                facecolor='lightgray'
            )
            
        # Leyendas para la viga empotrada
        elif tipo_viga == "Viga empotrada":
        # Leyenda para reacciones
            fig.legend(
                handles=handles_reacciones_M,
                labels=["Reacciones:",  # Subtítulo
                    f"Ray = {reaccion_apoyo:.2f} kN",  # Reacción en A
                    f"Rby = {reaccion_apoyo:.2f} kN"],  # Reacción en B
                loc='upper left',
                bbox_to_anchor=(0.55, 0.98),  # Ajusta la posición
                fontsize=8,
                frameon=True,
                edgecolor='black',
                facecolor='lightgray'
            )
        
        # Leyenda para momentos
            fig.legend(
                handles=handles_momentos,
                labels=["Momentos:",  # Subtítulo
                    f"MA = {momento_A:.2f} kNm",  # Momento en A
                    f"MB = {momento_B:.2f} kNm"],  # Momento en B
                loc='upper left',
                bbox_to_anchor=(0.1, 0.98),  # Ajusta la posición debajo de la leyenda de reacciones
                fontsize=8,
                frameon=True,
                edgecolor='black',
                facecolor='lightgray'
            )
            
        # Añadir leyenda de cargas WD y WL al gráfico
            fig.legend(
                handles=handles_WD,
                labels=["Carga muerta:",f"WD = {WD:.2f} kN/m"],
                loc='upper left',
                bbox_to_anchor=(0.55, 0.3),  # Ajustar la posición de la leyenda
                fontsize=8,
                frameon=True,
                edgecolor='black',
                facecolor='lightgray'
            )
            fig.legend(
                handles=handles_WL,
                labels=["Carga viva:",f"WL = {WL:.2f} kN/m"],
                loc='upper left',
                bbox_to_anchor=(0.1, 0.3),  # Ajustar la posición de la leyenda
                fontsize=8,
                frameon=True,
                edgecolor='black',
                facecolor='lightgray'
            )
        
        # Ajustar límites y limpiar canvas
        ax.set_xlim(desplazamiento_x - 50, longitud + desplazamiento_x + 50)
        ax.set_ylim(eje_y_central - 100, eje_y_central + 150)
        ax.set_aspect('equal', adjustable='box')
        ax.axis('off')
        
        # Limpiar canvas antes de mostrar nueva figura
        for widget in canvas_1.winfo_children():
            widget.destroy()
        
        # Mostrar figura en canvas
        canvas_viga_cargas = FigureCanvasTkAgg(fig, master=canvas_1)
        canvas_viga_cargas.draw()
        canvas_viga_cargas.get_tk_widget().place(x=1, y=1, width=380, height=280)

    except Exception as e:
        print(f"Error al dibujar la viga: {e}")

# Variables globales para los Label y StringVar
label_seccion_luz = None
label_seccion_Wu = None
var_luz_cargas = None
var_Wu_cargas = None

def abrir_ventana_cargas():
    global ventana_cargas_abierta ,combo_seccion_analisis, entry_base_cargas, entry_altura_cargas,entry_luz_cargas
    global entry_Wpp_cargas, entry_WD_cargas, entry_WL_cargas, entry_Wtotal_cargas, entry_Wu_cargas
    global Wu_var,label_tipo_viga_cargas,combo_viga_cargas,canvas_1,label_titulo_viga,label_titulo_cargas,label_texto_cargas
    global var_luz_cargas, var_Wu_cargas, label_seccion_luz, label_seccion_Wu
    # Verificar si ya hay una ventana abierta
    if ventana_cargas_abierta is not None and ventana_cargas_abierta.winfo_exists():
        # Si la ventana ya está abierta, no hacemos nada
        return
    
    # Crear una nueva ventana solo si no existe
    ventana_cargas_abierta = tk.Toplevel()  # Toplevel crea una ventana secundaria
    
    # Configurar la ventana
    ventana_cargas_abierta.title("Análisis de cargas")
    ventana_cargas_abierta.geometry("560x600")  # Tamaño de la ventana
    
    # Evitar que la ventana sea maximizada o redimensionada
    ventana_cargas_abierta.resizable(False, False)
    
    # Mantener la ventana siempre encima
    ventana_cargas_abierta.attributes('-topmost', True)
    
    
    # Crear contenido en la ventana cargas
    labelframe_cargas= tk.LabelFrame(ventana_cargas_abierta,text="")
    labelframe_cargas.place(x=30,y=30,width=500,height=500)
    label_apoyo_cargas = tk.Label(labelframe_cargas,text="Tipo de apoyo:")
    label_apoyo_cargas.place(x=20,y=20)
    entry_apoyo_cargas = tk.Entry(labelframe_cargas)
    entry_apoyo_cargas.place(x=120,y=20,width=100)
    # Obtener el valor del Label 'label_restriccion_apoyo' y mostrarlo en el Entry
    valor_restriccion = label_restriccion_apoyo.cget("text")  # Obtener el texto del Label
    entry_apoyo_cargas.insert(0, valor_restriccion)  # Insertamos el valor en el Entry
    label_viga_cargas = tk.Label(labelframe_cargas,text="Tipo de viga:")
    label_viga_cargas.place(x=270,y=20)
    # Crear el Combobox con las opciones
    combo_viga_cargas = ttk.Combobox(labelframe_cargas, values=["Viga apoyada", "Viga empotrada"])
    combo_viga_cargas.place(x=350, y=20, width=120)
    combo_viga_cargas.set("Seleccionar")  # Establecer el valor inicial
    
    labelframe_viga_cargas= tk.LabelFrame(labelframe_cargas,text="Diagrama viga")
    labelframe_viga_cargas.place(x=20,y=70,width=457,height=205)
    canvas_viga_analisis = tk.Canvas(labelframe_viga_cargas,bg="white",bd=2,relief="ridge")
    canvas_viga_analisis.pack(fill=tk.BOTH, expand=True, padx=0, pady=0)  # Incrustar el canvas con ajuste
    
    #Crear botones Aceptar, Calcular , Aplicar
    boton_aceptar_cargas= tk.Button(ventana_cargas_abierta,text="Aceptar")
    boton_aceptar_cargas.place(x=110,y=550,width=100)
    
    boton_aplicar_cargas= tk.Button(ventana_cargas_abierta,text="Aplicar", command=aplicar_cargas)
    boton_aplicar_cargas.place(x=330,y=550,width=100)
    
    
    # Crear las variables de tipo StringVar para vincular con los Entry
    var_luz_cargas = tk.StringVar()
    var_Wu_cargas = tk.StringVar()
    
    labelframe_analisis = tk.LabelFrame(labelframe_cargas,text="Análisis de cargas")
    labelframe_analisis.place(x=20,y=280,width=457,height=180)
    label_seccion_analisis =tk.Label(labelframe_analisis,text="Sección:")
    label_seccion_analisis.place(x=10,y=40)
    combo_seccion_analisis=ttk.Combobox(labelframe_analisis)
    combo_seccion_analisis.place(x=70,y=40,width=95)
    combo_seccion_analisis.set("Seleccionar")
    label_unicad_cargas1= tk.Label(labelframe_analisis,text="[VG]")
    label_unicad_cargas1.place(x=175,y=40)
    luz_cargas = tk.Label(labelframe_analisis,text="Luz:")
    luz_cargas.place(x=10,y=10)
    entry_luz_cargas =tk.Entry(labelframe_analisis,textvariable=var_luz_cargas)
    entry_luz_cargas.place(x=70,y=10,width=95)
    label_unicad_cargas2= tk.Label(labelframe_analisis,text="[m]")
    label_unicad_cargas2.place(x=175,y=10)
    base_cargas = tk.Label(labelframe_analisis,text="Base:")
    base_cargas.place(x=10,y=70)
    entry_base_cargas = tk.Entry(labelframe_analisis)
    entry_base_cargas.place(x=70,y=70,width=95)
    label_unicad_cargas3= tk.Label(labelframe_analisis,text="[m]")
    label_unicad_cargas3.place(x=175,y=70)
    altura_cargas = tk.Label(labelframe_analisis,text="Altura:")
    altura_cargas.place(x=10,y=100)
    entry_altura_cargas = tk.Entry(labelframe_analisis)
    entry_altura_cargas.place(x=70,y=100,width=95)
    label_unicad_cargas4= tk.Label(labelframe_analisis,text="[m]")
    label_unicad_cargas4.place(x=175,y=100)
    peso_concreto_cargas = tk.Label(labelframe_analisis,text="γConcreto:")
    peso_concreto_cargas.place(x=5,y=130)
    entry_concreto_cargas = tk.Entry(labelframe_analisis)
    entry_concreto_cargas.place(x=70,y=130,width=95)
    entry_concreto_cargas.insert(0, "24.00")
    label_unicad_cargas5= tk.Label(labelframe_analisis,text="[kN/m³]")
    label_unicad_cargas5.place(x=165,y=130)
    frame_cargas = tk.Frame(labelframe_analisis,bg="grey",bd=4,relief="ridge")
    frame_cargas.place(x=230,y=10,width=1,height=140)
    WD_cargas = tk.Label(labelframe_analisis,text="WD:")
    WD_cargas.place(x=250,y=10)
    entry_WD_cargas= tk.Entry(labelframe_analisis)
    entry_WD_cargas.place(x=290,y=10,width=95)
    label_unidad_WD = tk.Label(labelframe_analisis,text="[kN/m]")
    label_unidad_WD.place(x=390,y=10)
    WL_cargas = tk.Label(labelframe_analisis,text="WL:")
    WL_cargas.place(x=250,y=40)
    entry_WL_cargas= tk.Entry(labelframe_analisis)
    entry_WL_cargas.place(x=290,y=40,width=95)
    label_unidad_WL = tk.Label(labelframe_analisis,text="[kN/m]")
    label_unidad_WL.place(x=390,y=40)
    Wpp_cargas = tk.Label(labelframe_analisis,text="Wpp:")
    Wpp_cargas.place(x=250,y=70)
    entry_Wpp_cargas= tk.Entry(labelframe_analisis)
    entry_Wpp_cargas.place(x=290,y=70,width=95)
    label_unidad_Wpp = tk.Label(labelframe_analisis,text="[kN/m]")
    label_unidad_Wpp.place(x=390,y=70)
    Wtotal_cargas = tk.Label(labelframe_analisis,text="Wtotal:")
    Wtotal_cargas.place(x=245,y=100)
    entry_Wtotal_cargas= tk.Entry(labelframe_analisis)
    entry_Wtotal_cargas.place(x=290,y=100,width=95)
    label_unidad_Wtotal = tk.Label(labelframe_analisis,text="[kN/m]")
    label_unidad_Wtotal.place(x=390,y=100)
    Wu_cargas = tk.Label(labelframe_analisis,text="Wu:")
    Wu_cargas.place(x=250,y=130)
    entry_Wu_cargas= tk.Entry(labelframe_analisis,textvariable=var_Wu_cargas)
    entry_Wu_cargas.place(x=290,y=130,width=95)
    label_unidad_Wu = tk.Label(labelframe_analisis,text="[kN/m]")
    label_unidad_Wu.place(x=390,y=130)
    
    # Vincular eventos
    combo_viga_cargas.bind("<<ComboboxSelected>>", lambda event: actualizar_diagrama_viga(event, combo_viga_cargas, canvas_viga_analisis, entry_luz_cargas,Wu_var,label_tipo_viga_cargas))
    entry_luz_cargas.bind("<KeyRelease>", lambda event: actualizar_diagrama_viga(event, combo_viga_cargas, canvas_viga_analisis, entry_luz_cargas,Wu_var,label_tipo_viga_cargas))
    # Llamamos a la función para actualizar el ComboBox con el valor de label_seccion_cargas
    actualizar_combo_seccion(combo_seccion_analisis)
    
    # Asociar el evento de selección del ComboBox a la función actualizar_entries
    combo_seccion_analisis.bind("<<ComboboxSelected>>", actualizar_entries)
    # Asociar eventos para actualizar automáticamente Wtotal
    entry_WD_cargas.bind("<KeyRelease>", calcular_Wtotal)
    entry_WL_cargas.bind("<KeyRelease>", calcular_Wtotal)
    
    # Vincular el trace solo una vez cuando se cree la ventana
    Wu_var.trace_add("write", lambda name, index, mode: actualizar_diagrama_viga(None, combo_viga_cargas, canvas_viga_analisis, entry_luz_cargas, Wu_var,label_tipo_viga_cargas))
    
        
    # Función para actualizar los labels con los valores de los Entry
    def actualizar_labels(*args):
        label_seccion_luz.config(text=var_luz_cargas.get())  # Actualiza el label con el valor de luz de cargas
        label_seccion_Wu.config(text=var_Wu_cargas.get())  # Actualiza el label con el valor de Wu de cargas
    
    # Vincular las variables de los Entry con la función de actualización
    var_luz_cargas.trace("w", actualizar_labels)  # Cuando cambia la variable, actualiza el label correspondiente
    var_Wu_cargas.trace("w", actualizar_labels)    # Lo mismo para Wu de Cargas
    
    # Función para cerrar la ventana y liberar la referencia
    def cerrar_ventana():
        global ventana_cargas_abierta
        ventana_cargas_abierta.destroy()
        ventana_cargas_abierta = None


label_seccion_luz = tk.Label(ventana,text="",bg="red")
#label_seccion_luz.place(x=500,y=450,width=100)         #<---- Dato que hare salto de codigo luz de viga

label_seccion_Wu = tk.Label(ventana,text="",bg="red")  #<---- Dato que hare salto de codigo Wu 
#label_seccion_Wu.place(x=500,y=480,width=100)

label_tipo_viga_cargas = tk.Label(ventana,text="",bg="red")
#label_tipo_viga_cargas.place(x=500,y=520,width=100)        #<--- Dato que hare salto de codigo tipo viga apoyada o viga empotrada

label_restriccion_apoyo= tk.Label(ventana,text="",bg="red")
#label_restriccion_apoyo.place(x=500,y=400,width=100)   #<---- Dato que hare salto de codigo condicion de apoyos

label_seccion_cargas = tk.Label(ventana,text="",bg="red")
#label_seccion_cargas.place(x=500,y=420,width=100)       #<----- Dato que hare salto de codigo nombre de seccion transversal

frame_ventana_seccion = tk.Frame(ventana, bd=10, relief="ridge",bg="white")
frame_ventana_seccion.place(x=36, y=405, width=400, height=370)

frame_ventana_falsa = tk.Frame(frame_ventana_seccion,bd=2,relief="flat",bg="white")
frame_ventana_falsa.place(x=1,y=35,width=378,height=280)

label_titulo_seccion = tk.Label(frame_ventana_seccion  ,text="Diagrama sección transversal",bd=2,relief="raise")
label_titulo_seccion.place(x=1,y=1,width=380,height=35)

label_titulo_falsa = tk.Frame(frame_ventana_seccion,bd=2,relief="raise")
label_titulo_falsa.place(x=1,y=315,width=380,height=35)

frame_ventana_viga= tk.Frame(ventana, bd=10, relief="ridge",bg="white")
frame_ventana_viga.place(x=437, y=35, width=400, height=370)

label_titulo_viga = tk.Label(frame_ventana_viga,text="Análisis de Viga", bd=2, relief="raise")
label_titulo_viga.place(x=1,y=1,width=380,height=35)

label_titulo_cargas = tk.Frame(frame_ventana_viga,bd=2,relief="raise")
label_titulo_cargas.place(x=1,y=315,width=380,height=35)


label_texto_cargas = tk.Label(label_titulo_cargas, text="")
label_texto_cargas.pack(fill=tk.BOTH, expand=True)

canvas_1 = tk.Canvas(frame_ventana_viga, bd=2, relief="flat", bg="white")
canvas_1.place(x=1, y=36, width=380, height=280)

def actualizar_contenido_graficos(label_seccion_cargas, label_seccion_luz, label_seccion_Wu, label_tipo_viga_cargas, label_graficos_viga, label_graficos_luz, label_graficos_Wu, combo_graficos_Wu, label_graficos_tipo_viga):
    """
    Función para actualizar varios widgets en la ventana de gráficos, pasando como parámetros
    los widgets necesarios.
    """
    # Tomamos el texto de label_seccion_cargas de la ventana principal
    valor_cargas = label_seccion_cargas.cget("text")
    
    # Actualizamos el texto del label_graficos_viga con el valor de label_seccion_cargas
    label_graficos_viga.config(text=valor_cargas)
    
    # Actualizar el texto del label_graficos_luz con el valor de label_seccion_luz
    valor_luz = label_seccion_luz.cget("text")
    valor_luz_formateado = f"{valor_luz} m"  
    label_graficos_luz.config(text=valor_luz_formateado)
    
    # Agregar el valor de label_seccion_Wu como opción al combo 
    valor_Wu_graficos = label_seccion_Wu.cget("text")
    
    # Añadir el valor real del Wu al ComboBox, sin seleccionarlo por defecto
    combo_graficos_Wu['values'] = ["Seleccionar", valor_Wu_graficos]  
    combo_graficos_Wu.set("Seleccionar") 
    
    # Tomamos el valor de label_tipo_viga_cargas y actualizamos label_graficos_tipo_viga
    valor_tipo_viga = label_tipo_viga_cargas.cget("text")
    label_graficos_tipo_viga.config(text=valor_tipo_viga)

# Función para mostrar la ventana emergente
def mostrar_ventana_emergente():
    messagebox.showinfo("Pilot Structural", "¡Muy bien! Ahora puedes iniciar con las configuraciones de diseño a flexión.")

# Función para cerrar la ventana de gráficos
def cerrar_ventana_graficos():
    global ventana_graficos_abierta, ventana_graficos
    # Mostrar la ventana emergente antes de cerrar
    mostrar_ventana_emergente()
    
    ventana_graficos.destroy()  # Cerrar la ventana de gráficos
    ventana_graficos_abierta = False  # Permitir reabrir la ventana

# Definir las variables globales
ventana_graficos_abierta = False
ventana_graficos = None

# Variables globales para los labels y combobox
label_valor_M1 = None
label_valor_M2 = None
label_valor_M3 = None
Momento_Mu = None
label_valor_Mmax =None

# Función para abrir la ventana de gráficos
def abrir_ventana_graficos():
    global ventana_graficos_abierta, ventana_graficos, combo_graficos_Wu, label_graficos_luz, label_graficos_tipo_viga, label_frame_graficos_V_M
    global datos_exportar,boton_cancelar_graficos
    global fig
    global label_valor_M1, label_valor_M2, label_valor_M3,label_valor_Mmax
    # Verificar si la ventana ya está abierta
    if ventana_graficos_abierta:
        return  # Si ya está abierta, no hacer nada
    
    # Si no está abierta, crear la ventana secundaria
    ventana_graficos = tk.Toplevel()  
    ventana_graficos.title("Diagramas cortante y momento")  
    ventana_graficos.geometry("600x620")  
    
    # Configuración adicional: no redimensionable y siempre encima de otras ventanas
    ventana_graficos.resizable(False, False)  
    ventana_graficos.attributes('-topmost', True) 
    # Marcar la ventana como abierta
    ventana_graficos_abierta = True
    
    # Crear contenido en la ventana graficos
    
    label_frame_graficos = tk.LabelFrame(ventana_graficos, text="")
    label_frame_graficos.place(x=20,y=20,width=560,height=550)
    label_frame_carga = tk.LabelFrame(label_frame_graficos,text="Condiciones de carga [Wu]")
    label_frame_carga.place(x=10,y=10,width=200,height=100)
    label_graficos_Wu = tk.Label(label_frame_carga,text="Wu:")
    label_graficos_Wu.place(x=10,y=40)
    combo_graficos_Wu = ttk.Combobox(label_frame_carga)
    combo_graficos_Wu.place(x=40,y=40,width=130)
    combo_graficos_Wu.set("Seleccionar")
    label_graficos_info =tk.Label(label_frame_carga,text="Carga mayorada",bd=1,relief="sunken")
    label_graficos_info.place(x=10,y=10,width=160)
    label_frame_graficos_seccion =tk.LabelFrame(label_frame_graficos,text="Sección [VG]")
    label_frame_graficos_seccion.place(x=220,y=10,width=150,height=100)
    label_graficos_viga = tk.Label(label_frame_graficos_seccion,text="",bd=1,relief="sunken")
    label_graficos_viga.place(x=10,y=10,width=120)
    label_luz_viga = tk.Label(label_frame_graficos_seccion,text="Luz:")
    label_luz_viga.place(x=10,y=40)
    label_graficos_luz =tk.Label(label_frame_graficos_seccion,text="",bd=1,relief="sunken")
    label_graficos_luz.place(x=50,y=40,width=80)
    label_graficos_tipo_viga = tk.Label(label_frame_graficos,text="",bg="red")
    #label_graficos_tipo_viga.place(x=10,y=80,width=100)
    label_frame_graficos_slider = tk.LabelFrame(label_frame_graficos,text="Ajuste de valor")
    label_frame_graficos_slider.place(x=380,y=10,width=165,height=100)
    # Crear un slider
    slider_valor = tk.Scale(label_frame_graficos_slider, orient="horizontal",from_=0, to=10,resolution=0.1) 
    slider_valor.place(x=25,y=0)
    label_graficos_cortante = tk.Label(label_frame_graficos_slider,text="Cortante:")
    label_graficos_cortante.place(x=10,y=40)
    label_graficos_V = tk.Label(label_frame_graficos_slider,text="")
    label_graficos_V.place(x=70,y=40,width=75)
    label_graficos_momento = tk.Label(label_frame_graficos_slider,text="Momento:")
    label_graficos_momento.place(x=7,y=60)
    label_graficos_M = tk.Label(label_frame_graficos_slider,text="")
    label_graficos_M.place(x=70,y=60,width=75)
    
    #Crear labelframe valores max y min Cortante
    label_frame_Valores_V = tk.LabelFrame(label_frame_graficos,text="Valores max y min [V]")
    label_frame_Valores_V.place(x=380,y=120,width=165,height=100)
    label_valor_max = tk.Label(label_frame_Valores_V,text="V[+]:")
    label_valor_max.place(x=10,y=10)
    label_valor_min = tk.Label(label_frame_Valores_V,text="V[-]:")
    label_valor_min.place(x=10,y=45)
    label_max= tk.Label(label_frame_Valores_V,text="")
    label_max.place(x=50,y=10,width=75)
    label_min= tk.Label(label_frame_Valores_V,text="")
    label_min.place(x=50,y=45,width=75)
    
    #Crear labelframe valores max y min Momento viga empotrada
    label_frame_Valores_M = tk.LabelFrame(label_frame_graficos,text="Valores max y min [M]")
    label_frame_Valores_M.place(x=380,y=230,width=165,height=100)
    label_valor_min_M1 = tk.Label(label_frame_Valores_M ,text="M[-]:")
    label_valor_min_M1.place(x=10,y=5)
    label_valor_max_M2= tk.Label(label_frame_Valores_M ,text="M[+]:")
    label_valor_max_M2.place(x=10,y=30)
    label_valor_min_M3= tk.Label(label_frame_Valores_M ,text="M[-]:")
    label_valor_min_M3.place(x=10,y=55)
    label_valor_M1=tk.Label(label_frame_Valores_M,text="")
    label_valor_M1.place(x=50,y=5,width=75)
    label_valor_M2=tk.Label(label_frame_Valores_M,text="")
    label_valor_M2.place(x=50,y=30,width=75)
    label_valor_M3=tk.Label(label_frame_Valores_M,text="")
    label_valor_M3.place(x=50,y=55,width=75)
    
    #Crear labelFrame valor Mmax viga simplemente apoyada
    label_frame_Mmax= tk.LabelFrame(label_frame_graficos,text="")
    label_frame_Mmax.place(x=380,y=340,width=165,height=60)
    label_intervalo = tk.Label(label_frame_Mmax,text="")
    label_intervalo.place(x=50,y=5,width=85)
    label_Mmax = tk.Label(label_frame_Mmax,text="Mmax:")
    label_Mmax.place(x=5,y=30)
    label_valor_Mmax=tk.Label(label_frame_Mmax,text="")
    label_valor_Mmax.place(x=50,y=30,width=75)
    
    #Crear contenido Graficos V y M
    label_frame_graficos_V_M = tk.LabelFrame(label_frame_graficos,text="Diagrama Fuerza Cortante y Momento Flector [V,M]")
    label_frame_graficos_V_M.place(x=10,y=120,width=360,height=400)
    
    #Crear contendio y botones.
    label_frame_datos = tk.LabelFrame(label_frame_graficos,text="Exportar/Generar")
    label_frame_datos.place(x=380,y=410,width=165,height=110)
    
    boton_generar_pdf = tk.Button(label_frame_datos,text="Generar",command=generar_pdf)
    boton_generar_pdf.place(x=30,y=50,width=100)
    
    boton_exportar_datos = tk.Button(label_frame_datos,text="Exportar",command=exportar_datos_a_excel)
    boton_exportar_datos.place(x=30,y=10,width=100)
    
    boton_aceptar_graficos = tk.Button(ventana_graficos,text="Aceptar")
    boton_aceptar_graficos.place(x=150,y=580,width=100)
    
    boton_cancelar_graficos = tk.Button(ventana_graficos,text="Cancelar",command=cerrar_ventana_graficos)
    boton_cancelar_graficos.place(x=330,y=580,width=100)
    
    # Asociar la acción de cerrar con el protocolo WM_DELETE_WINDOW
    ventana_graficos.protocol("WM_DELETE_WINDOW", cerrar_ventana_graficos)
    
    # Llamar a la función de actualización, pasando los labels como parámetros
    actualizar_contenido_graficos(
        label_seccion_cargas, label_seccion_luz, label_seccion_Wu, label_tipo_viga_cargas,
        label_graficos_viga, label_graficos_luz, label_graficos_Wu, combo_graficos_Wu,
        label_graficos_tipo_viga
    )
    
    boton_cancelar_graficos=None
    def mostrar_grafico(event):
        global datos_exportar,boton_cancelar_graficos
        global fig
        tipo_viga = label_graficos_tipo_viga.cget("text")
        Wu = combo_graficos_Wu.get()
        Luz = label_graficos_luz.cget("text")

        try:
            Wu = float(Wu)
            Luz = float(Luz.split()[0])
        except (ValueError, AttributeError):
            return
    
        # Reacciones en los apoyos
        Apoyo_A = Wu * Luz / 2
        Apoyo_B = Wu * Luz / 2
        
        # Actualizar los Labels con los valores estáticos
        label_max.config(text=f"{Apoyo_A:.2f} kN")
        label_min.config(text=f"{Apoyo_B:.2f} kN")
        
        # Crear listas para cortante
        posiciones_cortante = [0, Luz]
        cortante = [Apoyo_A, -Apoyo_B]  # Línea diagonal
    
        # Crear puntos intermedios para la curva parabólica
        x_momento = np.linspace(0, Luz, 100)  # 100 puntos para suavizar la curva
        momento = []
        
        if tipo_viga == "Viga apoyada":
        # Cortante: Línea diagonal desde Apoyo_A hacia -Apoyo_B
            cortante = [Apoyo_A, 0, -Apoyo_B]
            posiciones_cortante = [0, Luz / 2, Luz]
            
        # Momento flector: Curva parabólica
            momento = Wu * x_momento * (Luz - x_momento) / 2  
            
        # Actualizar labels específicos para viga apoyada
            label_valor_Mmax.config(text=f"{max(momento):.2f} kNm")
            label_intervalo.config(text=f"[0.0 ≤ X ≤ {Luz:.2f}]")
            
            label_valor_M1.config(text="N/A")
            label_valor_M2.config(text="N/A")
            label_valor_M3.config(text="N/A")
            
        # Actualizar el combobox con los valores de Mmax
            actualizar_combobox("Viga apoyada")
            
        elif tipo_viga == "Viga empotrada":
        # Cortante: Línea diagonal desde Apoyo_A hacia -Apoyo_B
            cortante = [Apoyo_A, 0, -Apoyo_B]
            posiciones_cortante = [0, Luz / 2, Luz]
            
        # Momento flector: Curva parabólica con momentos en los extremos
            MA =  Wu * (Luz ** 2) / 12  # Momento en apoyo izquierdo
            MB = -Wu * (Luz ** 2) / 12   # Momento en apoyo derecho
            
        # Fórmula general del momento en viga empotrada
            momento = -(MB + Apoyo_B * x_momento - (Wu * x_momento ** 2) / 2)
            
            label_valor_M1.config(text=f"{MA:.2f} kNm")
            label_valor_M2.config(text=f"{max(momento)/2:.2f} kNm")
            label_valor_M3.config(text=f"{MB:.2f} kNm")
            
            label_valor_Mmax.config(text="   N/A")
            label_intervalo.config(text="N/A")
            
            # Actualizar el combobox con los valores de M1, M2, M3
            actualizar_combobox("Viga empotrada")
            
        # Guardar datos en una lista global para exportar
        datos_exportar = {
            "Longitud": x_momento,
            "Cortante": [cortante[0] if x <= Luz / 2 else cortante[2] for x in x_momento],
            "Momento": momento
        }
            
        
        
    # Crear el gráfico en el LabelFrame
        fig, axs = plt.subplots(2, 1, figsize=(5, 6), dpi=100, sharex=True)
        fig.subplots_adjust(hspace=0.3)

    # Diagrama de Fuerza Cortante
        axs[0].fill_between(posiciones_cortante, 0, cortante, where=np.array(cortante) >= 0, 
                        interpolate=True, color="Darkblue", alpha=1)
        axs[0].fill_between(posiciones_cortante, 0, cortante, where=np.array(cortante) < 0, 
                        interpolate=True, color="red", alpha=1)
        axs[0].plot(posiciones_cortante, cortante, label="Fuerza Cortante", color="blue", linestyle="-")
        axs[0].axhline(0, color="black", linewidth=0.8, linestyle="-")
        axs[0].set_title("Diagrama de Fuerza Cortante", fontsize=10)
        axs[0].set_xlabel("Longitud (m)", fontsize=9,)
        axs[0].set_ylabel("Cortante (kN)", fontsize=9)
        axs[0].tick_params(axis="both", labelsize=9)
        
        # Personalización de la leyenda del Cortante
        axs[0].legend(loc='upper right',fontsize=9, edgecolor='black', facecolor='white',bbox_to_anchor=(0.95, 0.95), framealpha=0.5)
        
        axs[0].set_facecolor('lightgray')
        axs[0].set_xticks([])  
        axs[0].set_yticks([])  

    # Diagrama de Momento Flector 
        axs[1].fill_between(x_momento, 0, momento, where=momento  >= 0, 
                        interpolate=True, color="Darkblue", alpha=1)
        axs[1].fill_between(x_momento, 0,  momento, where=momento  < 0, 
                        interpolate=True, color="red", alpha=1)
        axs[1].plot(x_momento,  momento, label="Momento Flector", color="black", linestyle="-")
        axs[1].axhline(0, color="black", linewidth=0.8, linestyle="-")  # Línea horizontal en 0
        axs[1].set_title("Diagrama de Momento Flector", fontsize=10)
        axs[1].set_xlabel("Longitud (m)", fontsize=9)
        axs[1].set_ylabel("Momento (kNm)", fontsize=9)
        axs[1].tick_params(axis="both", labelsize=9)
        
        # Personalización de la leyenda del Momento Flector
        axs[1].legend(loc='center', fontsize=9, bbox_to_anchor=(0.5, 0.8), edgecolor='black', facecolor='white', framealpha=0.5)
        
        
        axs[1].set_facecolor('lightgray') 
        axs[1].set_xticks([])  
        axs[1].set_yticks([])  
        
    # Fijar los límites del eje Y para mantener el 0 fijo en la intersección
        momento_min = min( momento)
        momento_max = max( momento)
        axs[1].set_ylim(momento_min - abs(momento_min * 0.1), momento_max + abs(momento_max * 0.1))
        
        
        
    # Limpiar contenido previo y mostrar el gráfico en el LabelFrame
        for widget in label_frame_graficos_V_M.winfo_children():
            widget.destroy()
        
        canvas = FigureCanvasTkAgg(fig, master=label_frame_graficos_V_M)
        canvas.draw()
        canvas.get_tk_widget().pack(fill="both", expand=True)
        
        # Configurar el rango del slider basado en la longitud de la viga
        slider_valor.config(from_=0, to=Luz, resolution=0.1)
        slider_valor.set(0)
        
        # Función para actualizar los marcadores y contenido widgets
        def actualizar_marcadores(valor):
            posicion = float(valor)
            
            # Eliminar marcadores previos
            for line in axs[0].lines[1:]:
                line.remove()
            for line in axs[1].lines[1:]:
                line.remove()
            
            # Interpolación para obtener los valores de cortante y momento en la posición actual
            cortante_y = np.interp(posicion, posiciones_cortante, cortante)
            momento_y = np.interp(posicion, x_momento,  momento)

            cortante_y = np.interp(posicion, posiciones_cortante, cortante)
            axs[0].plot(posicion, cortante_y, marker="o", color="black", linestyle=' ', label=f"[V]: {cortante_y:.2f} kN")

            momento_y = np.interp(posicion, x_momento,  momento)
            axs[1].plot(posicion, momento_y, marker="o", color="black",linestyle=' ', label=f"[M]: {-momento_y:.2f} kNm",)
            
            # Actualizar el texto del eje X con la longitud dinámica basada en la posición del slider
            axs[0].set_xlabel(f"Longitud ({posicion:.2f} m)", fontsize=9)
            axs[1].set_xlabel(f"Longitud ({posicion:.2f} m)", fontsize=9)
            
            # Personalizar leyendas: borde negro y fondo blanco transparente
            axs[0].legend(loc='upper right', fontsize=7,bbox_to_anchor=(0.95, 0.95), edgecolor='black', facecolor='white', framealpha=0.5)
            axs[1].legend(loc='center', fontsize=7, bbox_to_anchor=(0.5, 0.8), edgecolor='black', facecolor='white', framealpha=0.5)
            
            # Actualizar los Labels con los valores dinámicos
            label_graficos_V.config(text=f"{cortante_y:.2f} kN")
            label_graficos_M.config(text=f"{-momento_y:.2f} kNm")
            
            
            canvas.draw()
            
        slider_valor.config(command=actualizar_marcadores)
            
        
    # Asociar evento después de crear los widgets
    combo_graficos_Wu.bind("<<ComboboxSelected>>", mostrar_grafico)


#Crear widgets para hacer saltos de codigo 
# combobox para momentos ultimos de viga empotrada
Momento_Mu= ttk.Combobox(ventana)
#Momento_Mu.place(x=500,y=600)


# Función para actualizar el Combobox con los valores de los labels
def actualizar_combobox(tipo_viga):
    if tipo_viga == "Viga apoyada":
        # Solo actualizar el combobox con el valor de Mmax en caso de viga apoyada
        valores_Mu = [label_valor_Mmax.cget("text")]
    elif tipo_viga == "Viga empotrada":
        # Obtener los valores de M1, M2
        valor_M1 = label_valor_M1.cget("text")
        valor_M2 = label_valor_M2.cget("text")
        
        # Obtener el valor de M3, eliminar solo el signo negativo y mantener el texto "kNm"
        valor_M3 = label_valor_M3.cget("text")
        if valor_M3.startswith('-'):
            valor_M3 = valor_M3[1:]  # Eliminar el primer carácter (el signo negativo)
        
        # Actualizar los valores para viga empotrada
        valores_Mu = [valor_M1, valor_M2, valor_M3]
    
    # Actualizar las opciones del combobox
    Momento_Mu['values'] = valores_Mu
    if valores_Mu:
        Momento_Mu.set(valores_Mu[0])  # Establecer el valor por defecto en el primer elemento




def exportar_datos_a_excel():
    global datos_exportar
    global fig
    if not datos_exportar:
        print("No hay datos para exportar.")
        return

    # Convertir los datos en un DataFrame
    df = pd.DataFrame(datos_exportar)

    # Definir el directorio y archivo de salida
    directorio = "Archivos_Excel"
    if not os.path.exists(directorio):
        os.makedirs(directorio)
    archivo_salida = os.path.join(directorio, "datos_graficos.xlsx")

    # Guardar el DataFrame en un archivo Excel
    df.to_excel(archivo_salida, index=False)
    print(f"Datos exportados correctamente a {archivo_salida}")

    # Abrir el archivo Excel en el programa predeterminado
    if os.name == 'nt':  # Si es Windows
        os.startfile(archivo_salida)
    elif os.name == 'posix':  # Si es MacOS o Linux
        os.system(f'open "{archivo_salida}"')  # Para MacOS
        # os.system(f'xdg-open "{archivo_salida}"')  # Para Linux

# Definir las variables globales necesarias
cortante = []  # Lista de valores de cortante
posiciones_cortante = []  # Lista de posiciones para el cortante
momento = []  # Lista de valores de momento
x_momento = []  # Lista de posiciones para el momento
Luz = None  # Longitud de la viga
label_frame_graficos_V_M = None  # Definir esto según sea necesario
slider_valor = None  # Definir esto según sea necesario
label_graficos_V = None  # Definir esto según sea necesario
label_graficos_M = None  # Definir esto según sea necesario
# Variable global para la figura
fig = None

# Ruta para guardar la imagen y el PDF
ruta_guardar = r"C:\Users\User\Desktop\Programa\Archivos_Pilot\pdf"

# Función para generar el PDF
def generar_pdf():
    global fig  # Usar la figura global
    if fig is None:
        print("Error: No se ha generado ningún gráfico para guardar.")
        return

    # Crear el PDF
    pdf = FPDF()
    pdf.set_auto_page_break(auto=True, margin=15)
    pdf.add_page()

    # Configurar el título
    pdf.set_font('Arial', 'B', 16)
    pdf.cell(200, 10, txt="Gráficos de Cortante y Momento Flector", ln=True, align="C")

    # Agregar imágenes de los gráficos
    pdf.ln(10)  # Espacio entre el título y la imagen
    imagen_path = f"{ruta_guardar}\\grafico.png"  # Ruta para guardar la imagen del gráfico
    fig.savefig(imagen_path, format="png")
    pdf.image(imagen_path, x=10, y=40, w=180)

    # Guardar el PDF
    pdf_output_path = f"{ruta_guardar}\\diagrama_cortante_momento.pdf"  # Ruta para guardar el PDF
    pdf.output(pdf_output_path)
    print(f"PDF generado y guardado en: {pdf_output_path}")

# Función para actualizar los valores de Momento_Mu
def actualizar_momento_mu():
    # Cambiar los valores de Momento_Mu (esto debe venir de algún evento)
    nuevos_valores = Momento_Mu['values']  # Tomamos los mismos valores de Momento_Mu

    # Si la ventana flexión está abierta, actualizamos el ComboBox de esa ventana
    if ventana_flexion and ventana_flexion.winfo_exists():
    # Aquí sincronizamos la actualización de los valores de combo_flexion_Mu
        combo_flexion_Mu['values'] = nuevos_valores  # Actualizamos los valores de combo_flexion_Mu
        if nuevos_valores:
            combo_flexion_Mu.set(nuevos_valores[0])  # Establecemos el primer valor como valor por defecto

# Variable global para almacenar la referencia de la ventana flexión
ventana_flexion = None

# Variables globales para los Entry
entry_flexion_VG = None
entry_flexion_base = None
entry_flexion_altura = None
entry_flexion_recubrimiento = None
entry_flexion_profundidad = None


# Función para abrir la ventana flexión
def abrir_ventana_flexion():
    global ventana_flexion, entry_flexion_VG, entry_flexion_base, entry_flexion_altura,entry_flexion_recubrimiento, entry_flexion_profundidad
    global combo_flexion_fc, combo_flexion_fy, entry_flexion_β1,entry_flexion_cuantia_min, entry_flexion_cuantia_max
    global combo_flexion_Mu,combo_flexion_Rn, combo_flexion_𝞀req
    
    # Si la ventana flexión ya está abierta, no abrir otra
    if ventana_flexion is None or not ventana_flexion.winfo_exists():
        # Crear una nueva ventana secundaria usando Toplevel
        ventana_flexion = tk.Toplevel()

        # Configurar la ventana
        ventana_flexion.title("Diseño a flexión")  
        ventana_flexion.geometry("850x600")  

        # Hacer que la ventana no sea redimensionable
        ventana_flexion.resizable(False, False)

        # Mantener la ventana siempre en primer plano
        ventana_flexion.attributes('-topmost', True)
        
        #Crear contenido ventana flexion
        labelframe_flexion = tk.LabelFrame(ventana_flexion,text="")
        labelframe_flexion.place(x=20,y=20,width=810,height=560)
        labelframe_flexion_Mu = tk.LabelFrame(labelframe_flexion,text="Momento ultimo/Sección transversal")
        labelframe_flexion_Mu.place(x=20,y=10,width=350,height=100)
        label_flexion_Mu = tk.Label(labelframe_flexion_Mu,text="Momento actuante [Mu]:")
        label_flexion_Mu.place(x=20,y=15)
        combo_flexion_Mu = ttk.Combobox(labelframe_flexion_Mu)
        combo_flexion_Mu.place(x=180,y=15)
        combo_flexion_Mu['values'] = Momento_Mu['values']  
        combo_flexion_Mu.set(Momento_Mu.get())
        label_flexion_VG = tk.Label(labelframe_flexion_Mu,text="Sección elemento [VG]:")
        label_flexion_VG.place(x=20,y=45)
        entry_flexion_VG = tk.Entry(labelframe_flexion_Mu)
        entry_flexion_VG.place(x=180,y=45,width=143)
        entry_flexion_VG.insert(0, label_seccion_cargas.cget("text"))
        entry_flexion_VG.bind("<KeyRelease>", actualizar_dimensiones)
        
        
        labelframe_flexion_dimensiones = tk.LabelFrame(labelframe_flexion ,text="Dimensiones de la viga [VG]")
        labelframe_flexion_dimensiones.place(x=20,y=130,width=350,height=110)
        label_flexion_base=tk.Label(labelframe_flexion_dimensiones,text="Base  [b]:")
        label_flexion_base.place(x=20,y=15)
        entry_flexion_base= tk.Entry(labelframe_flexion_dimensiones)
        entry_flexion_base.place(x=110,y=15,width=143)
        label_flexion_unidad_b= tk.Label(labelframe_flexion_dimensiones,text="[m]")
        label_flexion_unidad_b.place(x=280,y=15)
        label_flexion_altura = tk.Label(labelframe_flexion_dimensiones,text="Altura  [h]:")
        label_flexion_altura.place(x=20,y=45)
        entry_flexion_altura= tk.Entry(labelframe_flexion_dimensiones)
        entry_flexion_altura.place(x=110,y=45,width=143)
        label_flexion_unidad_h= tk.Label(labelframe_flexion_dimensiones,text="[m]")
        label_flexion_unidad_h.place(x=280,y=45)
        labelframe_flexion_r_d = tk.LabelFrame(labelframe_flexion,text="Recubrimiento/Altura efectiva")
        labelframe_flexion_r_d.place(x=20,y=260,width=350,height=110)
        label_flexion_recubrimiento = tk.Label(labelframe_flexion_r_d,text="Recubrimiento [r]:")
        label_flexion_recubrimiento.place(x=5,y=15)
        entry_flexion_recubrimiento= tk.Entry(labelframe_flexion_r_d)
        entry_flexion_recubrimiento.place(x=110,y=15,width=143)
        entry_flexion_recubrimiento.bind("<KeyRelease>", actualizar_profundidad)  
        label_flexion_unidad_r= tk.Label(labelframe_flexion_r_d,text="[m]")
        label_flexion_unidad_r.place(x=280,y=15)
        label_flexion_profundidad = tk.Label(labelframe_flexion_r_d,text="Profundidad [d]:")
        label_flexion_profundidad.place(x=5,y=45)
        entry_flexion_profundidad= tk.Entry(labelframe_flexion_r_d)
        entry_flexion_profundidad.place(x=110,y=45,width=143)
        label_flexion_unidad_d= tk.Label(labelframe_flexion_r_d,text="[m]")
        label_flexion_unidad_d.place(x=280,y=45)
        labelframe_flexion_info= tk.LabelFrame(labelframe_flexion,text="Información adicional")
        labelframe_flexion_info.place(x=20,y=380,width=350,height=100)
        label_flexion_NSR10 = tk.Label(labelframe_flexion_info,text="Norma de diseño:")
        label_flexion_NSR10.place(x=5,y=15)
        L_flexion_NSR10 = tk.Label(labelframe_flexion_info,text="NSR-10")
        L_flexion_NSR10.place(x=110, y=15, width=143)
        label_flexion_estribo= tk.Label(labelframe_flexion_info,text="Estribo de diseño:")
        label_flexion_estribo.place(x=5,y=45)
        
        labelframe_flexion_materiales= tk.LabelFrame(labelframe_flexion,text="Resistencia de materiales [σ]")
        labelframe_flexion_materiales.place(x=380,y=10,width=408,height=100)
        label_flexion_fc= tk.Label(labelframe_flexion_materiales,text="Concreto [f'c]:")
        label_flexion_fc.place(x=5,y=15)
        combo_flexion_fc= ttk.Combobox(labelframe_flexion_materiales)
        combo_flexion_fc.place(x=95,y=15)
        combo_flexion_fc['values'] = ["Seleccionar", "17.5 MPa", "21 MPa", "24.5 MPa", "28 MPa", "35 MPa", "42 MPa"]
        combo_flexion_fc.current(0)  
        combo_flexion_fc.bind("<<ComboboxSelected>>", lambda event: actualizar_β1(event, combo_flexion_fc, combo_flexion_fy, entry_flexion_β1, 
                                entry_flexion_cuantia_min, entry_flexion_cuantia_max,combo_flexion_Rn,combo_flexion_𝞀req,
                                combo_flexion_Asreq,entry_flexion_base,entry_flexion_profundidad))
        
        label_flexion_fy= tk.Label(labelframe_flexion_materiales,text="Acero [fy]:")
        label_flexion_fy.place(x=5,y=45)
        combo_flexion_fy= ttk.Combobox(labelframe_flexion_materiales)
        combo_flexion_fy.place(x=95,y=45)
        combo_flexion_fy['values'] = ["Seleccionar", "420 MPa"]
        combo_flexion_fy.current(1)  
        label_flexion_β1 = tk.Label(labelframe_flexion_materiales,text="Factor [β1]:")
        label_flexion_β1.place(x=280,y=15)
        entry_flexion_β1=tk.Entry(labelframe_flexion_materiales)
        entry_flexion_β1.place(x=273,y=45,width=80)
        
        labelframe_flexion_cuantia = tk.LabelFrame(labelframe_flexion,text="Cuantia diseño [𝞀]")
        labelframe_flexion_cuantia.place(x=380,y=130,width=180,height=110)
        label_flexion_cuantia_min = tk.Label(labelframe_flexion_cuantia,text="𝞀min:")
        label_flexion_cuantia_min.place(x=10,y=10)
        entry_flexion_cuantia_min = tk.Entry(labelframe_flexion_cuantia)
        entry_flexion_cuantia_min.place(x=70,y=10,width=90)
        label_flexion_cuantia_max = tk.Label(labelframe_flexion_cuantia,text="𝞀max:")
        label_flexion_cuantia_max.place(x=10,y=50)
        entry_flexion_cuantia_max = tk.Entry(labelframe_flexion_cuantia)
        entry_flexion_cuantia_max.place(x=70,y=50,width=90)
        
        labelframe_flexion_calculos = tk.LabelFrame(labelframe_flexion,text="Cálculos previos")
        labelframe_flexion_calculos.place(x=570,y=130,width=218,height=110) 
        label_flexion_Rn = tk.Label(labelframe_flexion_calculos,text="Rn:")
        label_flexion_Rn.place(x=30,y=10)
        combo_flexion_Rn = ttk.Combobox(labelframe_flexion_calculos)
        combo_flexion_Rn.place(x=80,y=10,width=90)
        label_flexion_𝞀req = tk.Label(labelframe_flexion_calculos,text="𝞀req:")
        label_flexion_𝞀req.place(x=30,y=35)
        combo_flexion_𝞀req = ttk.Combobox(labelframe_flexion_calculos)
        combo_flexion_𝞀req.place(x=80,y=35,width=90)
        label_flexion_Asreq = tk.Label(labelframe_flexion_calculos,text="Asreq:")
        label_flexion_Asreq.place(x=30,y=60)
        combo_flexion_Asreq = ttk.Combobox(labelframe_flexion_calculos)
        combo_flexion_Asreq.place(x=80,y=60,width=90)
        
        # Configurar un estilo personalizado para el Notebook
        style = ttk.Style()
        style.configure("CustomNotebook.TNotebook", background="lightgray", tabmargins=[0, 0, 0, 0])
        style.configure("CustomNotebook.TNotebook.Tab", background="white", foreground="black", padding=[10, 2])
        style.map("CustomNotebook.TNotebook.Tab", background=[("selected", "lightgray")])
        
        frame_flexion_tabla = tk.Frame(labelframe_flexion,bd=2,relief="groove")
        frame_flexion_tabla.place(x=380,y=268,width=409,height=212)
        
        # Crear el notebook_tabla con el estilo personalizado
        notebook_tabla = ttk.Notebook(frame_flexion_tabla, style="CustomNotebook.TNotebook")
        
        # Crear la pestaña "Tabla"
        tab1 = ttk.Frame(notebook_tabla)
        notebook_tabla.add(tab1, text="Resultados")
        
        # Crear el Treeview (tabla de datos) dentro de la pestaña
        columns = ("Mu [kNm]", "Rn [kN/m²]", "Cuantia\nDiseño", "As") 
        treeview = ttk.Treeview(tab1, columns=columns, show="headings") 
        
        
        # Configurar las columnas del Treeview
        treeview.heading("Mu [kNm]", text="Mu [kNm]")
        treeview.heading("Rn [kN/m²]", text="Rn [kN/m²]")
        treeview.heading("Cuantia\nDiseño", text="Cuantia")
        treeview.heading("As", text="As [mm²]")
        
        # Configurar el ancho de cada columna individualmente
        treeview.column("Mu [kNm]", width=80)  
        treeview.column("Rn [kN/m²]", width=80)  
        treeview.column("Cuantia\nDiseño", width=80)  
        treeview.column("As", width=80)  
        
        
        # Insertar filas de datos en el Treeview
        data = [
            ("Dato 1", "Dato 2", "Dato 3", "Dato 4"),
            ("Dato 5", "Dato 6", "Dato 7", "Dato 8"),
            ("Dato 9", "Dato 10", "Dato 11", "Dato 12")
        ]
        
        for row in data:
            treeview.insert("", "end", values=row)  
        
        treeview.place(x=10, y=10, width=380, height=90)
        
        # Función para evitar el redimensionamiento de las columnas
        def no_resize(event):
        # Restaurar el tamaño original de las columnas
            for col in treeview["columns"]:
                treeview.column(col, width=94)
        
        # Vincular el evento para evitar la acción de cambiar el tamaño de las columnas
        treeview.bind("<ButtonRelease-1>", no_resize)
        
        # Mostrar el notebook_tabla dentro del frame
        notebook_tabla.pack(expand=True, fill="both")
        
        entry_flexion_recubrimiento.bind("<FocusOut>", lambda event: calcular_Rn_al_modificar_recubrimiento(
        event, combo_flexion_Mu, entry_flexion_base, entry_flexion_profundidad, entry_flexion_recubrimiento, combo_flexion_Rn))
        
        
        # Crear radiobutton No.3 No.4 con comandos para actualizar el valor
        radiobutton_flexion_No3 = tk.Radiobutton(labelframe_flexion_info, text="No.3", 
                                                    variable=estado_estribo,
                                                    value="9.5", 
                                                    command=lambda: actualizar_label_estribo(9.5))
        radiobutton_flexion_No3.place(x=150, y=45)

        radiobutton_flexion_No4 = tk.Radiobutton(labelframe_flexion_info, text="No.4", 
                                                    variable=estado_estribo,
                                                    value="12.7", 
                                                    command=lambda: actualizar_label_estribo(12.7))
        radiobutton_flexion_No4.place(x=250, y=45)
        

def calcular_Rn_al_modificar_recubrimiento(event=None, combo_flexion_Mu=None, entry_flexion_base=None, entry_flexion_profundidad=None, entry_flexion_recubrimiento=None, combo_flexion_Rn=None):
    try:
        # Leer el valor de b desde el Entry (base)
        b = float(entry_flexion_base.get())
        
        # Leer el valor de d desde el Entry (profundidad)
        d = float(entry_flexion_profundidad.get())
        
        # Leer el valor del recubrimiento 
        recubrimiento = float(entry_flexion_recubrimiento.get())
        
        # Validar que d sea positivo
        if d <= 0:
            raise ValueError("La profundidad (d) debe ser positiva.")
        
        # Leer los valores de Mu desde el combobox (como lista de texto)
        mu_values = combo_flexion_Mu['values']
        mu_numeric_values = []
        
        for mu in mu_values:
            try:
                # Extraer el valor numérico, ignorando "kNm"
                mu_numeric_values.append(float(mu.split()[0]))
            except ValueError:
                pass  # Ignorar valores no válidos
        
        # Constante de diseño
        phi = 0.90
        
        # Calcular Rn para cada Mu
        rn_values = []
        for mu in mu_numeric_values:
            try:
                rn = mu / (phi * b * (d ** 2))  # Usar directamente d en lugar de d_util
                rn_values.append(f"{rn:.4f}")  # Formatear con 4 decimales
            except ZeroDivisionError:
                rn_values.append("Error")  # Manejar divisiones por cero
        
        # Actualizar el combo_flexion_Rn con los resultados
        combo_flexion_Rn['values'] = rn_values
        
        # Si hay resultados, seleccionar el primero por defecto
        if rn_values:
            combo_flexion_Rn.set(rn_values[0])
        else:
            combo_flexion_Rn.set("")  # Limpiar selección si no hay resultados

    except ValueError as e:
        # Manejar entradas no válidas
        combo_flexion_Rn['values'] = []
        combo_flexion_Rn.set("")
        print(f"Error: {e}")

def actualizar_β1(
    event, 
    combo_flexion_fc, 
    combo_flexion_fy, 
    entry_flexion_β1, 
    entry_flexion_cuantia_min, 
    entry_flexion_cuantia_max, 
    combo_flexion_Rn, 
    combo_flexion_𝞀req, 
    combo_flexion_Asreq,  # Nuevo combo para mostrar As
    entry_flexion_base,   # Entry para base_As
    entry_flexion_profundidad  # Entry para d_As
):
    
    # Obtener los valores de f'c y fy desde los combos
    fc_value = combo_flexion_fc.get()
    fy_value = combo_flexion_fy.get()

    # Convertir los valores a solo los números (ignorando "MPa")
    try:
        fc_numeric = float(fc_value.split()[0])  # Extraer el número antes de "MPa"
    except ValueError:
        fc_numeric = 0.0

    try:
        fy_numeric = float(fy_value.split()[0])  # Extraer el número antes de "MPa"
    except ValueError:
        fy_numeric = 0.0

    # Asignar el valor de β1 basado en f'c
    if fc_numeric == 17.5 or fc_numeric == 21 or fc_numeric == 24.5 or fc_numeric == 28:
        β1 = 0.85
    elif fc_numeric == 35:
        β1 = 0.80
    elif fc_numeric == 42:
        β1 = 0.75
    else:
        β1 = None

    if β1 is not None:
        entry_flexion_β1.delete(0, tk.END)
        entry_flexion_β1.insert(0, f"{β1:.2f}")
    else:
        entry_flexion_β1.delete(0, tk.END)

    # Calcular cuantía mínima: 𝞀min = (0.25 * sqrt(f'c)) / fy
    if fc_numeric > 0 and fy_numeric > 0:
        cuantia_min = max((0.25 * math.sqrt(fc_numeric)) / fy_numeric, 0.0033)
        entry_flexion_cuantia_min.delete(0, tk.END)
        entry_flexion_cuantia_min.insert(0, f"{cuantia_min:.4f}")
    else:
        entry_flexion_cuantia_min.delete(0, tk.END)

    # Calcular cuantía máxima: 𝞀max = 0.85 * β1 * (f'c / fy) * 0.63
    if β1 is not None and fc_numeric > 0 and fy_numeric > 0:
        cuantia_max = 0.85 * β1 * (fc_numeric / fy_numeric) * 0.63
        entry_flexion_cuantia_max.delete(0, tk.END)
        entry_flexion_cuantia_max.insert(0, f"{cuantia_max:.4f}")
    else:
        entry_flexion_cuantia_max.delete(0, tk.END)

    # Obtener los valores de Rn desde el combo
    rn_values = combo_flexion_Rn['values']

    # Calcular cuantía requerida: 𝞀requerida = 0.85*f'c/fy * (1 - sqrt(1 - 2*Rn*0.001 / (0.85*f'c)))
    cuantia_req_values = []
    for rn_value in rn_values:
        try:
            rn_numeric = float(rn_value)
            if fc_numeric > 0 and fy_numeric > 0:
                cuantia_req = 0.85 * fc_numeric / fy_numeric * (
                    1 - math.sqrt(1 - 2 * rn_numeric * 0.001 / (0.85 * fc_numeric))
                )
                cuantia_req_values.append(f"{cuantia_req:.4f}")
        except (ValueError, ZeroDivisionError):
            cuantia_req_values.append("Error")

    # Actualizar el combo_flexion_𝞀req con los resultados
    combo_flexion_𝞀req['values'] = cuantia_req_values

    # Seleccionar el primer valor si hay resultados
    if cuantia_req_values:
        combo_flexion_𝞀req.set(cuantia_req_values[0])
    else:
        combo_flexion_𝞀req.set("")

    # Cálculo del acero requerido As = 𝞀req × base_As × d_As
    try:
        base_As = float(entry_flexion_base.get())
        d_As = float(entry_flexion_profundidad.get())
    except ValueError:
        base_As, d_As = 0.0, 0.0

    acero_req_values = []
    for cuantia_req_str in cuantia_req_values:
        try:
            cuantia_req = float(cuantia_req_str)
            As = cuantia_req * (base_As * 1000) * (d_As * 1000)
            acero_req_values.append(f"{As:.3f}")
        except ValueError:
            acero_req_values.append("Error")

    # Actualizar el combo_flexion_Asreq con los resultados
    combo_flexion_Asreq['values'] = acero_req_values

    # Seleccionar el primer valor si hay resultados
    if acero_req_values:
        combo_flexion_Asreq.set(acero_req_values[0])
    else:
        combo_flexion_Asreq.set("")


# Función para actualizar las dimensiones
def actualizar_dimensiones(event):
    global entry_flexion_base, entry_flexion_altura, entry_flexion_VG, entry_flexion_recubrimiento, entry_flexion_profundidad
    
    
    vg_text = entry_flexion_VG.get()

    if "X" in vg_text:
        try:
            
            dimensiones_1 = vg_text.split("X")
            base_1 = float(dimensiones_1[0].strip().split()[1])  
            altura_1 = float(dimensiones_1[1].strip())           
            
            # Multiplicar por 0.01 para convertir a metros
            base_resultado = base_1 * 0.01
            altura_resultado = altura_1 * 0.01
            
            
            base_resultado = round(base_resultado, 2)
            altura_resultado = round(altura_resultado, 2)
            
            
            entry_flexion_base.delete(0, tk.END)
            entry_flexion_base.insert(0, str(base_resultado))
            
            entry_flexion_altura.delete(0, tk.END)
            entry_flexion_altura.insert(0, str(altura_resultado))
            
            
            recubrimiento_1 = float(entry_flexion_recubrimiento.get()) if entry_flexion_recubrimiento.get() else 0.0
            
            
            recubrimiento_cm = recubrimiento_1 * 100
            
            
            altura_d = (altura_1 - recubrimiento_cm) * 0.01
            
            
            altura_d = round(altura_d, 2)
            
            
            entry_flexion_profundidad.delete(0, tk.END)
            entry_flexion_profundidad.insert(0, str(altura_d))
            
        except ValueError:
            
            pass


# Función para actualizar cuando se cambia el valor en entry_flexion_recubrimiento
def actualizar_profundidad(event):
    # Llamar a actualizar_dimensiones para recalcular Altura_d cuando recubrimiento cambie
    actualizar_dimensiones(event)

# Variable para controlar el estado de los radiobuttons (marca inicial)
estado_estribo = tk.StringVar()

# Función para actualizar el label_prueba_estribo
def actualizar_label_estribo(valor):
    label_prueba_estribo.config(text=f"{valor} mm")
    # Cambiar el valor de la variable para asegurar que solo uno esté seleccionado
    estado_estribo.set(valor)

label_prueba_estribo= tk.Label(ventana,text="",bg="red")
#label_prueba_estribo.place(x=500,y=680,width=100)


# Menú "Definir" con opciones
menu_seccion_transversal = tk.Menu(menu_definir, tearoff=0)
menu_definir.add_command(label="Materiales", image=icono_materiales, compound="left",command=abrir_ventana_materiales)
menu_seccion_transversal.add_command(label="Propiedades geométricas de la sección", image=icono_seccion_viga, compound="left",command=abrir_ventana_seccion_transversal)
menu_definir.add_cascade(label="Sección transversal", menu=menu_seccion_transversal, image=icono_seccion_transversal, compound="left")
menu_bar.add_cascade(label="Definir", menu=menu_definir)

# Menú "Asignar"
menu_asignar = tk.Menu(menu_bar, tearoff=0)
menu_bar.add_cascade(label="Asignar", menu=menu_asignar)
menu_asignar.add_command(label="Apoyos",image=icono_asignar_apoyos,compound="left",command=abrir_ventana_apoyos)
menu_asignar.add_command(label="Cargas",image=icono_asignar_cargas,compound="left",command=abrir_ventana_cargas)

# Menú "Gráficos"
menu_graficos = tk.Menu(menu_bar, tearoff=0)
menu_bar.add_cascade(label="Gráficos", menu=menu_graficos)
menu_graficos.add_command(label="Diagramas V & M",image=icono_graficos,compound="left",command=abrir_ventana_graficos)

# Menú "Diseño Flexión"
menu_diseño_flexion = tk.Menu(menu_bar, tearoff=0)
menu_bar.add_cascade(label="Diseño Flexión", menu=menu_diseño_flexion)
# Crear un submenú para "Concreto reforzado" y agregar la opción "Cálculos previos"
submenu_calculos = tk.Menu(menu_diseño_flexion, tearoff=0)
submenu_calculos.add_command(label="Cálculos previos",image=icono_calculos,compound="left",command=abrir_ventana_flexion)
# Agregar "Concreto reforzado" con el submenú "Cálculos previos"
menu_diseño_flexion.add_cascade(label="Concreto reforzado", image=icono_flexion, compound="left", menu=submenu_calculos)


# Menú "Diseño Cortante"
menu_diseño_cortante = tk.Menu(menu_bar, tearoff=0)
menu_bar.add_cascade(label="Diseño Cortante", menu=menu_diseño_cortante)

# Mostrar la barra de menús
ventana.config(menu=menu_bar)

# ----------------------------
# Crear la barra de herramientas (Toolbar)
# ----------------------------

# Crear un frame para la barra de herramientas
toolbar = tk.Frame(ventana, bd=2, relief=tk.RAISED)
# Añadir la barra de herramientas a la ventana
toolbar.pack(side=tk.TOP, fill=tk.X)

# Crear un frame para la barra de herramientas
toolbar_1 = tk.Frame(ventana, bd=2, relief=tk.RAISED)  # Barra de herramientas con un ancho fijo
toolbar_1.place(x=1,y=35,width=35,height=738)

# Crear los botones de la barra de herramientas toolbar
boton_nuevo_modelo = tk.Button(toolbar, image=icono_modelo_nuevo, compound="top",command=lambda: abrir_ventana_nueva())
boton_nuevo_modelo.pack(side=tk.LEFT, padx=2, pady=2)
boton_abrir_archivo = tk.Button(toolbar,image=icono_abrir_archivo,compound="top",command=abrir_archivo)
boton_abrir_archivo.pack(side=tk.LEFT, padx=2, pady=2)
boton_guardar    = tk.Button(toolbar,image=icono_guardar,compound="top",command=guardar_archivo)
boton_guardar.pack(side=tk.LEFT, padx=2, pady=2)
boton_materiales = tk.Button(toolbar, image=icono_materiales, compound="top",command=abrir_ventana_materiales)
boton_materiales.pack(side=tk.LEFT, padx=2, pady=2)
boton_seccion_viga = tk.Button(toolbar, image=icono_seccion_viga, compound="top",command=abrir_ventana_seccion_transversal)
boton_seccion_viga.pack(side=tk.LEFT, padx=2, pady=2)
boton_apoyos = tk.Button(toolbar,image=icono_asignar_apoyos,compound="top",command=abrir_ventana_apoyos)
boton_apoyos.pack(side=tk.LEFT,padx=2,pady=2)
boton_cargas = tk.Button(toolbar,image=icono_asignar_cargas,compound="top",command=abrir_ventana_cargas)
boton_cargas.pack(side=tk.LEFT,padx=2,pady=2)
boton_graficas= tk.Button(toolbar,image=icono_graficos,compound="top",command=abrir_ventana_graficos)
boton_graficas.pack(side=tk.LEFT,padx=2,pady=2)
# Crear los botones de la barra de herramientas toolbar_1
boton_calculos_previos = tk.Button(toolbar_1,image=icono_calculos,compound="top",command=abrir_ventana_flexion)
boton_calculos_previos.pack(side=tk.TOP, padx=2, pady=2, anchor="n")


# Mostrar la ventana
ventana.mainloop()